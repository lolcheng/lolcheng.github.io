<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>yolov5学习</title>
      <link href="/2024/03/31/yolov5/"/>
      <url>/2024/03/31/yolov5/</url>
      
        <content type="html"><![CDATA[<p>安装yolov5：<br>下载地址 <a href="https://github.com/ultralytics/yolov5.git">https://github.com/ultralytics/yolov5.git</a><br>进入anaconda虚拟环境并在yolov5文件夹下键入命令下载依赖：<br>pip install -r requirements.txt<br>检验：打开yolov5文件夹，键入python detect.py或直接运行detect.py<br>当终端打印Result saved to runs/detect/exp时进入对应文件夹寻找图片，如果成功识别位置、物体和置信度则安装成功。</p><p>python detect.py —source data/images/bus.jpg</p><p>大目标<br>中目标<br>小目标</p><p>使用自己的训练集：<br>在datasets下创建自己的训练集文件夹xxx，在xxx中再创建子文件夹images和labels<br>其中images中存放图片，labels中存放标签（包括1个种类+4个矩形位置）<br>在环境下安装labelImg，这是一个打标签的工具。<br>使用pip install labelImg安装后键入labelImg打开。</p><p>首先找到左下角最后一个Change Save Format到YOLO<br>然后点击Open Dir打开images目录，然后点击Change Save Dir选择labels作为标签txt输出的保存目录，然后View-&gt;Auto Save Mode会自动保存标签txt到对应目录。<br>左侧Create RectBox（或快捷键W）框定矩形边缘，右侧box labels中键入标签种类。<br>点击Next Image（或快捷键D）就会切到下一张需要打标签的图片，上一张图片的标签txt被自动保存。<br>重复这一过程直到所有的图片都被打上标签，然后进入yolov5：<br>拷贝一份yolov5s.yaml，重命名作为自己模型的参数文件，需要修改nc的值<br>拷贝一份coco128.yaml，重命名作为自己数据的参数文件，需要修改names对应的键值对，以及各数据集所在的位置和名字path、train、val、test<br>然后训练参数：python train.py —cfg=”模型参数文件” —data=”数据参数文件”<br>训练完成后找到最佳的模型权重文件runs/train/exp/weights/best.pt<br>输入图片得到结果：python detect.py —weights=”模型权重文件” —source=”检测图片文件” —data=”数据参数文件”</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV学习</title>
      <link href="/2024/03/15/opencv/"/>
      <url>/2024/03/15/opencv/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu-opencv-vscode-cmakelists："><a href="#ubuntu-opencv-vscode-cmakelists：" class="headerlink" title="ubuntu+opencv+vscode+cmakelists："></a>ubuntu+opencv+vscode+cmakelists：</h1><p>1.下载opencv4压缩包：<a href="https://opencv.org/releases/的.zip文件">https://opencv.org/releases/的.zip文件</a><br>2.生成opencv4文件：解压完发现opencv是一个cmake工程，里面有CMakeList.txt，因此需要cmake生成Makefile。建一个build文件夹并进去使用cmake ..，而后使用make或者make -j4，make -j8 ， make -12，来编译，j后面这个数字时调用多线程进行编译。此时opencv便被安装到了/usr/local/include/opencv4，对应库文件的路径则为/usr/local/lib。此时opencv4便被安装好了，使用pkg-config opencv —modversion可以检验是否安装成功。<br>3.配置vscode：<br>需要修改c_cpp_properties.json，tasks.json和launch.json<br>1&gt;按下ctrl+shift+p搜索Edit Configuration进入编辑配置（JSON），在includePath中新增opencv4的路径/usr/local/include/opencv4<br>2&gt;ctrl+shift+p搜索Tasks:Configure Task后选择用g++编译，修改tasks.json为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;cppbuild&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;C/C++: g++ build active file&quot;,  /* 与launch.json文件里的preLaunchTask的内容保持一致 */</span><br><span class="line">            &quot;command&quot;: &quot;/usr/bin/g++&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-std=c++11&quot;,</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                //&quot;$&#123;file&#125;&quot;,   /* 编译单个文件 */</span><br><span class="line">                &quot;$&#123;fileDirname&#125;/*.cpp&quot;,  /* 编译多个文件 */</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;,  /* 输出文件路径 */</span><br><span class="line"> </span><br><span class="line">                /* 项目所需的头文件路径 */</span><br><span class="line">                &quot;-I&quot;,&quot;$&#123;workspaceFolder&#125;/&quot;,</span><br><span class="line">                &quot;-I&quot;,&quot;/usr/local/include/&quot;,</span><br><span class="line">                &quot;-I&quot;,&quot;/usr/local/include/opencv4/&quot;,</span><br><span class="line">                &quot;-I&quot;,&quot;/usr/local/include/opencv4/opencv2&quot;,</span><br><span class="line"> </span><br><span class="line">                /* 项目所需的库文件路径 */</span><br><span class="line">                &quot;-L&quot;, &quot;/usr/local/lib&quot;,</span><br><span class="line"> </span><br><span class="line">                /* OpenCV的lib库 */</span><br><span class="line">                &quot;/usr/local/lib/libopencv_*&quot;,</span><br><span class="line"> </span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;detail&quot;: &quot;Task generated by Debugger.&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2&gt;<br>3&gt;按下ctrl+shift+D后点击创建项目的launch.json文件，修改为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;g++ - Build and debug active file&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;,  //程序文件路径</span><br><span class="line">            &quot;args&quot;: [],  //程序运行需传入的参数</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,   //运行时是否显示控制台窗口</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;C/C++: g++ build active file&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>4.编写CMakeLists.txt文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line">project(test)</span><br><span class="line"></span><br><span class="line"># 查找OpenCV包</span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"># 包含OpenCV头文件目录</span><br><span class="line">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(TEST src/test.cpp)</span><br><span class="line"></span><br><span class="line"># 将OpenCV库链接到目标</span><br><span class="line">target_link_libraries(TEST $&#123;OpenCV_LIBS&#125;)</span><br></pre></td></tr></table></figure><br>5.至此，完成配置<br>在ubuntu中启用与禁用anaconda：<br>sudo gedit ~/.bashrc打开.bashrc文件<br>启用则写入：export PATH=~/anaconda3/bin:$PATH<br>要实现bash环境的自动启动写入：source ~/anaconda3/bin/activate<br>否则需要在终端中键入source activate才能进入<br>禁用则把上述两行代码注释掉即可<br>最后记得source ~/.bashrc刷新文件</p><h1 id="常用的anaconda命令："><a href="#常用的anaconda命令：" class="headerlink" title="常用的anaconda命令："></a>常用的anaconda命令：</h1><p>查询虚拟环境：conda env list<br>创建虚拟环境：conda create -n name python=3.xx<br>删除虚拟环境：conda remove -n name —all<br>进入虚拟环境：conda activate name<br>退出虚拟环境：conda deactivate</p><h1 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h1><p>二值图像：<br>一幅二值图像的二维矩阵仅由0、1两个值构成，“0”代表黑色，“1”代表白色。由于每一像素（矩阵中每一元素）取值仅有0、1两种可能，所以计算机中二值图像的数据类型通常为1个二进制位。二值图像通常用于文字、线条图的扫描识别（OCR）和掩膜图像的存储。<br>灰度图：<br>每个像素只有一个采样颜色的图像，这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑色与白色两种颜色；但是，灰度图像在黑色与白色之间还有许多级的颜色深度。灰度图像经常是在单个电磁波频谱如可见光内测量每个像素的亮度得到的，用于显示的灰度图像通常用每个采样像素8位的非线性尺度来保存，这样可以有256级灰度（如果用16位，则有65536级）。<br>彩色图：<br>每个像素通常是由红（R）、绿（G）、蓝（B）三个分量来表示的，分量介于（0，255）。RGB图像与索引图像一样都可以用来表示彩色图像。与索引图像一样，它分别用红（R）、绿（G）、蓝（B）三原色的组合来表示每个像素的颜色。但与索引图像不同的是，RGB图像每一个像素的颜色值（由RGB三原色表示）直接存放在图像矩阵中，由于每一像素的颜色需由R、G、B三个分量来表示，M、N分别表示图像的行列数，三个M x N的二维矩阵分别表示各个像素的R、G、B三个颜色分量。RGB图像的数据类型一般为8位无符号整形，通常用于表示和存放真彩色图像。</p><h1 id="一、图像IO操作"><a href="#一、图像IO操作" class="headerlink" title="一、图像IO操作"></a>一、图像IO操作</h1><p>1.读取图像：cv.imread(filename,flags)<br>参数：filename：要读取的图像及其路径<br>flags：读取方式<br>cv.IMREAD_COLOR：彩色模式，忽略透明度（默认参数）<br>cv.IMREAD_GRAYSCALE：灰度模式<br>cv.IMREAD_UNCHANGED：彩色模式，考虑透明度<br>返回值：图片名，numpy类型用于存储图片<br>2.显示图像：cv.imshow(winname,mat)<br>参数：winname：显示图像的窗口名称，以字符串类型表示<br>mat：要加载的图像<br>返回值：无<br>在调用显示图像的API后，要调用cv.waitKey()给图像绘制留下时间。<br>3.保存图像：cv.imwrite(filename,img)<br>参数：filename：保存的文件名机器路径<br>img：要保存的图片名<br>返回值：无</p><h1 id="二、绘制几何图形："><a href="#二、绘制几何图形：" class="headerlink" title="二、绘制几何图形："></a>二、绘制几何图形：</h1><p>1.绘制直线：cv.line(img,start,end,color,thickness)<br>参数：img:要绘制直线的图像<br>Start,end: 直线的起点和终点<br>color: 线条的颜色<br>Thickness: 线条宽度<br>返回值：无<br>2.绘制圆形：cv.circle(img,centerpoint, r, color, thickness)<br>参数：img:要绘制圆形的图像<br>Centerpoint, r: 圆心和半径<br>color: 线条的颜色<br>Thickness: 线条宽度，为-1时生成闭合图案并填充颜色<br>返回值：无<br>3.绘制矩形：cv.rectangle(img,leftupper,rightdown,color,thickness)<br>参数：img:要绘制矩形的图像<br>Leftupper, rightdown: 矩形的左上角和右下角坐标<br>color: 线条的颜色<br>Thickness: 线条宽度<br>返回值：无<br>4.添加文字：cv.putText(img,text,station, font, fontsize,color,thickness,lineType)<br>参数：img: 图像<br>text：要写入的文本数据<br>station：文本的放置位置<br>font：字体<br>Fontsize :字体大小<br>color：颜色<br>Thickness: 线条宽度<br>lineType：线渲染，值越大边缘越光滑，例如cv.LINE_8和cv.LINE_AA</p><h1 id="三、获取并修改图像中的像素点"><a href="#三、获取并修改图像中的像素点" class="headerlink" title="三、获取并修改图像中的像素点"></a>三、获取并修改图像中的像素点</h1><p>我们可以通过行和列的坐标值获取该像素点的像素值。对于BGR图像，它返回一个蓝，绿，红值的数组。对于灰度图像，仅返回相应的强度值。使用相同的方法对像素值进行修改。<br>px = img[100,100]                # 获取某个像素点的值<br>blue = img[100,100,0]            # 仅获取蓝色通道的强度值<br>img[100,100] = [255,255,255]    # 修改某个位置的像素值</p><h1 id="四、获取图像的属性："><a href="#四、获取图像的属性：" class="headerlink" title="四、获取图像的属性："></a>四、获取图像的属性：</h1><p>图像属性包括行数，列数和通道数，图像数据类型，像素数等。对应的API如下所示：<br>其中shape返回元组(高度，宽度，通道数)，size返回高度<em>宽度</em>通道数</p><h1 id="五、图像通道的拆分与合并"><a href="#五、图像通道的拆分与合并" class="headerlink" title="五、图像通道的拆分与合并"></a>五、图像通道的拆分与合并</h1><p>有时需要在B，G，R通道图像上单独工作。在这种情况下，需要将BGR图像分割为单个通道。或者在其他情况下，可能需要将这些单独的通道合并到BGR图像。<br>b,g,r = cv.split(img)            # 通道拆分<br>img = cv.merge((b,g,r))        # 通道合并</p><h1 id="六、色彩空间的转变：cv-cvtColor-img，code"><a href="#六、色彩空间的转变：cv-cvtColor-img，code" class="headerlink" title="六、色彩空间的转变：cv.cvtColor(img，code)"></a>六、色彩空间的转变：cv.cvtColor(img，code)</h1><p>参数：img: 进行颜色空间转换的图像<br>code: 转换类型<br>cv.COLOR_BGR2GRAY : BGR转Gray<br>cv.COLOR_BGR2HSV: BGR转HSV</p><h1 id="七、图像的四则运算与混合操作："><a href="#七、图像的四则运算与混合操作：" class="headerlink" title="七、图像的四则运算与混合操作："></a>七、图像的四则运算与混合操作：</h1><p>OpenCV的四则运算是饱和操作，即存在对应的上下限，例如在RGB图中只可能于[0,255]<br>dst=cv.add(x,y)                            #图像的加法<br>dst=cv.addWeighted(img1,α,img2,β,γ)    #dst = α⋅img1 + β⋅img2 + γ</p><h1 id="八、几何变换："><a href="#八、几何变换：" class="headerlink" title="八、几何变换："></a>八、几何变换：</h1><p>1.图像缩放：cv2.resize(src,dsize,fx=0,fy=0,interpolation=cv2.INTER_LINEAR)<br>参数：src : 输入图像<br>dsize: 绝对尺寸，直接指定调整后图像的大小<br>fx,fy: 相对尺寸，将dsize设置为None，然后将fx和fy设置为比例因子即可<br>interpolation：插值方法</p><p>2.图像旋转（仿射变换的一部分）：cv.warpAffine(img,M,dsize)<br>参数：img: 输入图像<br>M：2∗3移动矩阵，通过cv.getRotationMatrix2D(center, angle, scale)求解<br>center：旋转中心<br>angle：旋转角度<br>scale：缩放比例<br>dsize: 输出图像的大小<br>3.图像平移（仿射变换的一部分）：cv.warpAffine(img,M,dsize)<br>参数：img: 输入图像<br>M：2∗3移动矩阵，np.float32([[1,0,tx],[0,1,ty]])<br>dsize: 输出图像的大小<br>4.仿射变换：cv.warpAffine(img,M,dsize)<br>图像的仿射变换涉及到图像的形状位置角度的变化，是深度学习预处理中常到的功能,仿射变换主要是对图像的缩放，旋转，翻转和平移等操作的组合。<br>以下图为例解释图像的仿射变换，图1中的点1, 2 和 3 与图二中三个点一一映射, 仍然形成三角形, 但形状已经大大改变，通过这样两组三点（感兴趣点）就可以得到一组仿射变换，把这个仿射变换应用到图像中所有的点中，就完成了图像的仿射变换。</p><p>参数：img: 输入图像<br>M：2∗3移动矩阵，通过cv.getAffineTransform(pts1,pts2)求解，其中pts1和      pts2分别是仿射前后三个点的位置，用np.float32([[x,y,z],[x’,y’,z’]])表示<br>dsize: 输出图像的大小<br>5.透射变换：cv.warpPerspective(img,T,dsize)<br>透射变换是视角变化的结果，是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p><p>参数：img: 输入图像<br>T：3∗3透视变换矩阵，通过cv.getPerspectiveTransform(pts1,pts2)求解，      其中pts1和pts2分别是透射前后四个点的位置（任意三个不共线），<br>用np.float32([[x,y,z,a],[x’,y’,z’,a’]])表示<br>dsize: 输出图像的大小<br>6.图像金字塔：cv.pyrUp/Down(img) #上采样/下采样<br>图像金字塔是图像多尺度表达的一种，最主要用于图像的分割，是一种以多分辨率来解释图像的有效但概念简单的结构。图像金字塔用于机器视觉和图像压缩，一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低，且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似，层级越高，图像越小，分辨率越低。</p><h1 id="九、形态学操作："><a href="#九、形态学操作：" class="headerlink" title="九、形态学操作："></a>九、形态学操作：</h1><p>1.腐蚀：cv.erode(img,kernel,iterations)<br>腐蚀使原图中的高亮区域被蚕食，效果图有比原图更小的高亮区域，是求局部最小值的操作。<br>腐蚀的作用是消除物体边界点，使目标缩小，可以消除小于结构元素的噪声点。<br>具体操作是：用一个核结构扫描图像中的每一个像素，用图中的每一个与核结构相同大小的像素块与核结构像素做“与”操作，如果都为1，则该像素块的中心点为1，否则为0。如下图所示，结构A被核结构B腐蚀后：（图有误，点(2,3)应为白色）</p><p>参数：img: 要处理的图像<br>kernel: 核结构<br>iterations: 腐蚀的次数，默认是1<br>2.膨胀： cv.dilate(img,kernel,iterations)<br>膨胀使图像中高亮部分扩张，效果图拥有比原图更大的高亮区域，是求局部最大值的操作。<br>膨胀的作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的孔洞。<br>具体操作是：用一个核结构扫描图像中的每一个像素，用图中的每一个与核结构相同大小的像素块与核结构像素做“或”操作，如果都为0，则该像素块的中心点为0，否则为1。如下图所示，结构A被核结构B膨胀后：</p><p>参数的意义和腐蚀一样，在此不再赘述。</p><p>3.开运算和闭运算：cv.morphologyEx(img, op, kernel)<br>开运算是先腐蚀后膨胀，其作用是分离物体，消除小区域；其特点是消除噪点，去除小的干扰块，而不影响原来的图像。闭运算则与开运算相反，是先膨胀后腐蚀，作用是消除闭合物体里面的孔洞，特点是可以填充闭合区域。</p><p>参数：img: 要处理的图像<br>op: 若进行开运算，则设为cv.MORPH_OPEN<br>若进行闭运算，则设为cv.MORPH_CLOSE<br>Kernel： 核结构<br>4.礼帽与黑帽运算：cv.morphologyEx(img, op, kernel)<br>礼帽运算是原图像与开运算的结果图之差，黑帽运算是原图像与闭运算的结果图之差。<br>因为开运算带来的结果是放大了裂缝或者局部低亮度的区域，因此，从原图中减去开运算后的图，得到的效果图突出了比原图轮廓周围的区域更明亮的区域，故礼帽运算用来分离比邻近点亮一些的斑块。当一幅图像具有大幅的背景的时候，而微小物品比较有规律的情况下，可以使用礼帽运算进行背景提取。而黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域，故黑帽运算用来分离比邻近点暗一些的斑块。<br>参数：img: 要处理的图像<br>op: 若进行礼帽运算，则设为cv.MORPH_TOPHAT<br>若进行黑帽运算，则设为cv.MORPH_BLACKHAT<br>Kernel： 核结构<br>最后来看一些示例：</p><h1 id="十、图像噪声"><a href="#十、图像噪声" class="headerlink" title="十、图像噪声"></a>十、图像噪声</h1><p>1.椒盐噪声：cv.addSaltAndPepperNoise(img, noise_den, noise_val)<br>椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。椒盐噪声的成因可能是影像讯号受到突如其来的强烈干扰而产生、类比数位转换器或位元传输错误等。例如失效的感应器导致像素值为最小值，饱和的感应器导致像素值为最大值。</p><p>参数：img：源图像<br>noise_den：噪声密度（噪声像素占总像素的比例）<br>noise_val：噪声强度（噪声像素值，可以是0或255）。<br>2.高斯噪声：<br>高斯噪声是指噪声密度函数服从高斯分布的一类噪声。由于高斯噪声在空间和频域中数学上的易处理性，这种噪声(也称为正态噪声)模型经常被用于实践中。高斯随机变量z的概率密度函数由下式给出：</p><p>其中z表示灰度值，μ表示z的平均值或期望值，σ表示z的标准差。标准差的平方σ2​​称为z的方差。高斯函数的曲线如图所示。</p><h1 id="十一、图像平滑："><a href="#十一、图像平滑：" class="headerlink" title="十一、图像平滑："></a>十一、图像平滑：</h1><p>图像平滑从信号处理的角度看就是去除其中的高频信息，保留低频信息。因此我们可以对图像实施低通滤波。低通滤波可以去除图像中的噪声，对图像进行平滑。<br>根据滤波器的不同可分为均值滤波，高斯滤波，中值滤波， 双边滤波。<br>1.均值滤波：cv.blur(src, ksize, anchor, borderType)<br>均值滤波是一种典型的线性滤波算法。它对一个滑动窗口内的所有像素的灰度级求平均值，然后用这个平均值来代替窗口中心像素的原灰度级。这种方法在处理图像时，实质上是将噪声的灰度值也代入了均值中，可能导致噪声向周围扩散，使得图像变得模糊，边缘不清晰。<br>参数：src：输入图像<br>ksize：卷积核的大小<br>anchor：默认值 (-1,-1) ，表示核中心<br>borderType：边界类型<br>2.高斯滤波：cv.GaussianBlur(src,ksize,sigmaX,sigmay,borderType)<br>二维高斯是构建高斯滤波器的基础，其概率分布函数如下所示：</p><p>G(x,y)的分布是一个突起的帽子的形状。这里的σ可以看作两个值，一个是x方向的标准差σx，另一个是y方向的标准差σy。当σx和σy取值越大，整个形状趋近于扁平；当σx和σy越小，整个形状越突起。</p><p>正态分布是一种钟形曲线，越接近中心，取值越大，越远离中心，取值越小。计算平滑结果时，只需要将中心点作为原点，其他点按照其在正态曲线上的位置归一化后分配权重得到一个加权平均值，将该加权平均值赋给中心点即可。高斯平滑在从去除高斯噪声方面非常有效。<br>参数：src: 输入图像<br>ksize:高斯卷积核的大小，注意卷积核的宽度和高度都应为奇数，且可以不同<br>sigmaX: 水平方向的标准差<br>sigmaY: 垂直方向的标准差，默认值为0，表示与sigmaX相同<br>borderType:填充边界类型<br>3.中值滤波：cv.medianBlur(src, ksize )<br>中值滤波采用像素点邻域灰度值的中位数来代替该像素点的灰度值。中值滤波对椒盐噪声来说尤其有用，因为它不依赖于邻域内那些与典型值差别很大的值。<br>参数：src：输入图像<br>ksize：卷积核的大小</p><h1 id="十二、直方图："><a href="#十二、直方图：" class="headerlink" title="十二、直方图："></a>十二、直方图：</h1><p>直方图是对数据进行统计的一种方法，并且将统计值组织到一系列实现定义好的bin当中。bin为直方图中经常用到的一个概念，其数值是从数据中计算出的特征统计量，这些数据可以是诸如梯度、方向、色彩或任何其他特征。<br>图像直方图（Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素个数。这种直方图中，横坐标的左侧为较暗的区域，而右侧为较亮的区域。因此一张较暗图片的直方图中的数据多集中于左侧和中间部分，而整体明亮、只有少量阴影的图像则相反。直方图是根据灰度图进行绘制的，假设有一张图像的信息（灰度值 0 - 255，已知数字的范围包含 256 个值，于是可以按一定规律将这个范围分割成子区域（也就是 bins），[0,255]=[0,15]⋃[16,30]⋯⋃[240,255][0,255]=[0,15]⋃[16,30]⋯⋃[240,255]，然后再统计每一个 bin(i) 的像素数目。可以得到下图（其中 x 轴表示 bin，y 轴表示各个 bin 中的像素个数）：</p><p>直方图的一些术语和细节：<br>dims：需要统计的特征数目。在上例中，dims = 1 ，因为仅仅统计了灰度值。<br>bins：每个特征空间子区段的数目，在上例中， bins = 16。<br>range：要统计特征的取值范围。在上例中，range = [0, 255]。<br>1.直方图的计算：<br>cv2.calcHist(images,channels,mask,histSize,ranges[,hist[,accumulate]])<br>参数：images: 原图像。当传入函数时应该用中括号 [] 括起来，例如：[img]。<br>channels: 如果输入图像是灰度图，它的值就是 [0]；如果是彩色图像的话，传入      的参数可以是 [0]，[1]，[2] 它们分别对应着通道 B，G，R。 　　<br>mask: 掩模图像。要统计整幅图像的直方图就把它设为 None。但是如果你想统计      图像某一部分的直方图的话，你就需要制作一个掩模图像，并使用它。<br>histSize:BIN 的数目。也应该用中括号括起来，例如：[256]。 　　<br>ranges: 像素值范围，通常为 [0，256]<br>返回值：一个规模为1*ranges/bins的矩阵，其中每个值分别是对应bins的像素个数<br>2.掩膜：掩膜是用选定的图像、图形或物体，对要处理的图像进行遮挡，来控制图像处理的区域。在数字图像处理中，我们通常使用二维矩阵数组进行掩膜。掩膜是由0到255组成一个二进制图像，利用该掩膜图像要处理的图像进行掩膜，其中255值的区域被处理，0 值区域被屏蔽，不会处理。中间值则是部分掩膜。<br>我们使用cv.calcHist()来查找完整图像的直方图，如果要查找图像某些区域的直方图，只需在要查找直方图的区域上创建一个白色的掩膜图像，否则创建黑色，然后将其作为掩码mask传递即可。<br>3.直方图均衡化：dst = cv.equalizeHist(img)<br>如果一副图像中的大多数像素点的像素值都集中在某一个小的灰度值值范围之内会怎样呢？如果一幅图像整体很亮，那所有的像素值的取值个数应该都会很高。所以应该把它的直方图做一个横向拉伸，就可以扩大图像像素值的分布范围，提高图像的对比度，这就是直方图均衡化要做的事情。直方图均衡化是把原始图像的灰度直方图从比较集中的某个灰度区间变成在更广泛灰度范围内的分布。直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。这种方法提高图像整体的对比度，特别是有用数据的像素值分布比较接近时，在X光图像中使用广泛，可以提高骨架结构的显示，另外在曝光过度或不足的图像中可以更好的突出细节。<br>参数：img: 灰度图像<br>返回值：均衡化后的结果<br>4.自适应直方图均衡化：cv.createCLAHE(clipLimit, tileGridSize)<br>上述的直方图均衡，我们考虑的是图像的全局对比度。的确在进行完直方图均衡化之后，图片背景的对比度被改变了，在许多情况下，这样做的效果并不好。为了解决这个问题，需要使用自适应的直方图均衡化。此时，整幅图像会被分成很多小块，这些小块被称为tiles（默认8x8），然后再对每一个小块分别进行直方图均衡化。所以在每一个的区域中，直方图会集中在某一个小的区域中。如果有噪声的话，噪声会被放大。为了避免这种情况的出现要使用对比度限制。对于每个小块来说，如果直方图中的 bin 超过对比度的上限的话，就把其中的像素点均匀分散到其他 bins 中，然后在进行直方图均衡化。最后，为了除每一个小块之间的边界，再使用双线性差值，对每一小块进行拼接。<br>参数：clipLimit: 对比度限制，默认是40<br>tileGridSize: 分块的大小，默认为8∗8<br>返回值：自适应均衡化的对象，需要应用于图像cl1 = clahe.apply(img)</p><h1 id="十三、边缘检测："><a href="#十三、边缘检测：" class="headerlink" title="十三、边缘检测："></a>十三、边缘检测：</h1><p>边缘检测是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。<br>图像边缘检测大幅度地减少了数据量，并且剔除了可以认为不相关的信息，保留了图像重要的结构属性。有许多方法用于边缘检测，它们的绝大部分可以划分为两类：基于搜索和基于零穿越。<br>基于搜索：通过寻找图像一阶导数中的最大值来检测边界，然后利用计算结果估计边缘的局部方向，通常采用梯度的方向，并利用此方向找到局部梯度模的最大值，代表算法是Sobel算子和Scharr算子。<br>基于零穿越：通过寻找图像二阶导数零穿越来寻找边界，代表算法是Laplacian算子。<br>1.sobel算子：cv2.Sobel(src, depth, dx, dy, dst, ksize, scale, delta, borderType)<br>参数：src：传入的图像<br>depth: 图像的深度<br>dx和dy: 指求导的阶数，0表示这个方向上没有求导，取值为0、1。<br>ksize: 是Sobel算子（卷积核）的大小，必须为奇数1、3、5、7，默认为3。<br>如果ksize=-1，就演变成为3x3的Scharr算子。<br>scale：缩放导数的比例常数，默认情况为没有伸缩系数。<br>borderType：图像边界的模式，默认值为cv2.BORDER_DEFAULT。<br>Sobel函数求完导数后会有负值，还有会大于255的值。而原图像是uint8，即8位无符号数，所以Sobel建立的图像位数不够，会有截断。因此要使用16位有符号的数据类型，即cv2.CV_16S。处理完图像后，再使用cv2.convertScaleAbs()函数将其转回原来的uint8格式，否则图像无法显示。Sobel算子是在两个方向计算的，最后还需要用cv2.addWeighted( )函数将其组合起来。<br>Scale_abs = cv2.convertScaleAbs(x)  # 格式转换函数<br>result = cv2.addWeighted(src1, alpha, src2, beta) # 图像混合</p><p>2.Laplacian算子：cv2.Laplacian(src,depth,dst,ksize,scale, delta, borderType)</p><p>参数：src: 需要处理的图像，<br>depth: 图像的深度，-1表示采用的是原图像相同的深度，注意目标图像的深度必须      大于等于原图像的深度；<br>ksize：算子的大小，即卷积核的大小，必须为1,3,5,7。<br>3.Canny算子：cv2.Canny(image, threshold1, threshold2)<br>Canny 边缘检测算法是一种非常流行的边缘检测算法，被认为是最优的边缘检测算法。<br>Canny边缘检测算法由4步构成，分别介绍如下：<br>①噪声去除：由于边缘检测很容易受到噪声的影响，所以首先使用5*5高斯滤波器去除噪声，在图像平滑那一章节中已经介绍过。<br>②计算图像梯度：对平滑后的图像使用Sobel算子计算水平方向和竖直方向的一阶导数（Gx 和 Gy）。根据得到的这两幅梯度图（Gx 和 Gy）找到边界的梯度和方向，公式如下:</p><p>如果某个像素点是边缘，则其梯度方向总是垂直与边缘垂直。梯度方向被归为四类：垂直，水平，和两个对角线方向。<br>③非极大值抑制：在获得梯度的方向和大小之后，对整幅图像进行扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。如下图所示：</p><p>A点位于图像的边缘，在其梯度变化方向，选择像素点B和C，用来检验A点的梯度是否为极大值，若为极大值，则进行保留，否则A点被抑制，最终的结果是具有“细边”的二进制图像。<br>④滞后阈值：现在要确定真正的边界。我们设置两个阈值：minVal和maxVal。当图像的灰度梯度高于maxVal时被认为是真的边界，低于minVal的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。<br>参数：image:灰度图，<br>threshold1: minval，较小的阈值将间断的边缘连接起来<br>threshold2: maxval，较大的阈值检测图像中明显的边缘</p><h1 id="十四、模板匹配：cv-matchTemplate-img-template-method"><a href="#十四、模板匹配：cv-matchTemplate-img-template-method" class="headerlink" title="十四、模板匹配：cv.matchTemplate(img,template,method)"></a>十四、模板匹配：cv.matchTemplate(img,template,method)</h1><p>所谓的模板匹配，就是在给定的图片中查找和模板最相似的区域，该算法的输入包括模板和图片，整个任务的思路就是按照滑窗的思路不断的移动模板图片，计算其与图像中对应区域的匹配度，最终将匹配度最高的区域选择为最终的结果。其实现流程是：<br>准备两幅图像：原图像(I)和模板(T)，滑动模板图像和原图像进行比对，将模板块每次移动一个像素 (从左往右，从上往下)，在每一个位置都计算与模板图像的相似程度。<br>对于每一个位置将计算的相似结果保存在结果矩阵（R）中。查找R最大值所在的位置，那么该位置对应的区域就被认为是最匹配的。对应的区域就是以该点为顶点，长宽和模板图像一样大小的矩阵。<br>参数：img: 要进行模板匹配的图像<br>Template：模板<br>method：实现模板匹配的算法，主要有：<br>平方差匹配(CV_TM_SQDIFF)：利用模板与图像之间的平方差进行匹配，最好的匹配    是0，匹配越差，匹配的值越大。<br>相关匹配(CV_TM_CCORR)：利用模板与图像间的乘法进行匹配，数值越大表示匹配    程度较高，越小表示匹配效果差。<br>相关系数匹配(CV_TM_CCOEFF)：利用模板与图像间的相关系数匹配，1表示完美    的匹配，-1表示最差的匹配。<br>完成匹配后，使用cv.minMaxLoc()方法查找最大值所在的位置即可。如果使用平方差作为比较方法，则最小值位置是最佳匹配位置。<br>需要注意的是，模板匹配不适用于尺度变换，视角变换后的图像我们需要使用关键点匹配算法，比较经典的关键点检测算法包括SIFT和SURF等，主要的思路是首先通过关键点检测算法获取模板和测试图片中的关键点；然后使用关键点匹配算法处理即可，这些关键点可以很好的处理尺度变化、视角变换、旋转变化、光照变化等，具有很好的不变性。</p><h1 id="十五、霍夫变换："><a href="#十五、霍夫变换：" class="headerlink" title="十五、霍夫变换："></a>十五、霍夫变换：</h1><p>霍夫变换常用来提取图像中的直线和圆等几何形状，如下图所示：</p><p>霍夫线检测：cv.HoughLines(img, rho, theta, threshold)<br>参数：img: 检测的图像，要求是二值化的图像<br>rho、theta: ρ 和θ的精确度<br>threshold: 阈值，只有累加器中的值高于该阈值时才被认为是直线。<br>霍夫圆检测：OpenCV中使用霍夫梯度法进行圆形的检测。原则上霍夫变换可以检测任何形状，但复杂的形状需要的参数就多，霍夫空间的维数就多，因此在程序实现上所需的内存空间以及运行效率上都不利于把标准霍夫变换应用于实际复杂图形的检测中。霍夫梯度法是霍夫变换的改进，它的目的是减小霍夫空间的维度，提高效率。由于霍夫圆检测对噪声比较敏感，所以首先对图像进行中值滤波。<br>cv.HoughCircles(image, method, dp, minDist, param1, param2, minRadius,<br>maxRadius)<br>参数：image：输入图像，应输入灰度图像<br>method：使用霍夫变换圆检测的算法，它的参数是CV_HOUGH_GRADIENT<br>dp：霍夫空间的分辨率，dp=1时表示霍夫空间与输入图像空间的大小一致，dp=2      时霍夫空间是输入图像空间的一半，以此类推<br>minDist为圆心之间的最小距离，如果检测到的两个圆心之间距离小于该值，则认      为它们是同一个圆心<br>param1：边缘检测时使用Canny算子的高阈值，低阈值是高阈值的一半。<br>param2：检测圆心和确定半径时所共有的阈值<br>minRadius和maxRadius为所检测到的圆半径的最小值和最大值<br>返回值：输出圆向量，包括三个浮点型的元素——圆心横坐标，圆心纵坐标和圆半径</p><h1 id="十六、角点检测："><a href="#十六、角点检测：" class="headerlink" title="十六、角点检测："></a>十六、角点检测：</h1><p>角点是图像很重要的特征,对图像图形的理解和分析有很重要的作用。角点在三维场景重建运动估计，目标跟踪、目标识别、图像配准与匹配等计算机视觉领域起着非常重要的作用。<br>1.Harris角点检测：cv.cornerHarris(src, blockSize, ksize, k)<br>Harris角点检测的思想是通过图像的局部的小窗口观察图像，角点的特征是窗口沿任意方向移动都会导致图像灰度的明显变化<br>参数：img：数据类型为 ﬂoat32 的输入图像。<br>blockSize：角点检测中要考虑的邻域大小。<br>ksize：sobel求导使用的核大小<br>k：角点检测方程中的自由参数，取值参数为 [0.04，0.06].<br>2.Shi-Tomasi角点检测：<br>cv2.goodFeaturesToTrack ( image, maxcorners, qualityLevel, minDistance )<br>Shi-Tomasi算法是对Harris角点检测算法的改进，一般会比Harris算法得到更好的角点。Harris 算法的角点响应函数是将矩阵 M 的行列式值与 M 的迹相减，利用差值判断是否为角点。后来Shi 和Tomasi 提出改进的方法是，若矩阵M的两个特征值中较小的一个大于阈值，则认为他是角点。<br>参数：Image: 输入灰度图像<br>maxCorners : 获取角点数的数目。<br>qualityLevel：该参数指出最低可接受的角点质量水平，在0-1之间。<br>minDistance：角点之间最小的欧式距离，避免得到相邻特征点。<br>返回值：搜索到的角点，在这里所有低于质量水平的角点被排除掉，然后把合格的角点按质量排序，然后将质量较好的角点附近（小于最小欧式距离）的角点删掉，最后找到maxCorners个角点返回。<br>3.SIFT角点检测：前面两节我们介绍了Harris和Shi-Tomasi角点检测算法，这两种算法具有旋转不变性，但不具有尺度不变性，以下图为例，在左侧小图中可以检测到角点，但是图像被放大后，在使用同样的窗口，就检测不到角点了。所以，下面我们来介绍一种计算机视觉的算法，尺度不变特征转换即SIFT (Scale-invariant feature transform)。它用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变量，此算法由 David Lowe在1999年所发表，2004年完善总结。应用范围包含物体辨识、机器人地图感知与导航、影像缝合、3D模型建立、手势辨识、影像追踪和动作比对等领域。SIFT算法的实质是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。<br>①实例化sift：sift = cv.xfeatures2d.SIFT_create()<br>②利用sift.detectAndCompute()检测关键点并计算：<br>kp,des = sift.detectAndCompute(gray,None)<br>参数：gray: 进行关键点检测的图像，注意是灰度图像<br>返回值：kp: 关键点信息，包括位置，尺度，方向信息<br>des: 关键点描述符，每个关键点对应128个梯度信息的特征向量<br>③将关键点检测结果绘制在图像上<br>cv.drawKeypoints(image, keypoints, outputimage, color, flags)<br>参数：image: 原始图像<br>keypoints：关键点信息，将其绘制在图像上<br>outputimage：输出图片，可以是原始图像<br>color：颜色设置，通过修改（b,g,r）的值,更改画笔的颜色<br>flags：绘图功能的标识设置<br>cv2.DRAW_MATCHES_FLAGS_DEFAULT：创建输出图像矩阵，使用现存的输出    图像绘制匹配对和特征点，对每一个关键点只绘制中间点<br>cv2.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG：不创建输出图像矩阵，    而是在输出图像上绘制匹配对<br>cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS：对每一个特征点绘制带大小和方向的关键点图形<br>cv2.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS：单点的特征点不被    绘制<br>4.SURF算法：<br>SIFT在图像的不变特征提取方面拥有无与伦比的优势，但并不完美，仍然存在实时性不高，有时特征点较少，对边缘光滑的目标无法准确提取特征点等缺陷，自SIFT算法问世以来，人们就一直对其进行优化和改进，其中最著名的就是SURF算法。<br>SURF算法的应用与SIFT一致，这里就不在赘述。</p><h1 id="十七、视频读写："><a href="#十七、视频读写：" class="headerlink" title="十七、视频读写："></a>十七、视频读写：</h1><p>1.读取视频：cv.VideoCapture(filepath)<br>参数：filepath: 视频文件路径<br>2.获取视频的属性：cap.get(propId)<br>参数：propId: 视频的某个属性，具体见下</p><p>3.修改视频的属性：cap.set(propId，value)<br>参数：proid: 属性的索引，与上面的表格相对应<br>value: 修改后的属性值<br>4.判断图像是否读取成功：cap.isOpened()<br>5.获取视频的一帧图像：ret, frame = cap.read()<br>参数：ret: 若获取成功返回True，获取失败，返回False<br>Frame: 获取到的某一帧的图像<br>6.调用cv.imshow()显示图像，在显示图像时使用cv.waitkey()设置适当的持续时间，如果太低视频会播放的非常快，如果太高就会播放的非常慢，通常情况下设置25ms就可以。<br>7.释放视频资源：cap.release()<br>8.保存视频：cv2.VideoWriter(filename,fourcc, fps, frameSize)<br>参数：filename：视频保存的位置<br>fourcc：指定视频编解码器的4字节代码<br>fps：帧率<br>frameSize：帧大小<br>设置视频的编解码器，如下所示，retval = cv2.VideoWriter_fourcc( c1, c2, c3, c4 )<br>参数：c1,c2,c3,c4: 是视频编解码器的4字节代码，在fourcc.org中找到可用代码列表，      与平台紧密相关，常用的有：<br>在Windows中：DIVX（.avi）<br>在OS中：MJPG（.mp4），DIVX（.avi），X264（.mkv）。</p><h1 id="十八、视频追踪："><a href="#十八、视频追踪：" class="headerlink" title="十八、视频追踪："></a>十八、视频追踪：</h1><p>1.meanshift算法：cv.meanShift(probImage, window, criteria)<br>假设你有一堆点集，还有一个小的窗口，这个窗口可能是任意形状的，现在你要移动这个窗口到点集密度最大的区域当中。</p><p>最开始的窗口是蓝色圆环的区域，命名为C1。蓝色圆环的圆心用一个蓝色的矩形标注，命名为C1_o。而窗口中所有点的点集构成的质心在蓝色圆形点C1_r处，显然圆环的形心和质心并不重合。所以，移动蓝色的窗口，使得形心与之前得到的质心重合。在新移动后的圆环的区域当中再次寻找圆环当中所包围点集的质心，然后再次移动，通常情况下，形心和质心是不重合的。不断执行上面的移动过程，直到形心和质心大致重合结束。 这样，最后圆形的窗口会落到像素分布最大的地方，也就是图中的绿色圈，命名为C2。meanshift算法除了应用在视频追踪当中，在聚类，平滑等等各种涉及到数据以及非监督学习的场合当中均有重要应用，是一个应用广泛的算法。<br>参数：probImage: ROI区域，即目标的直方图的反向投影<br>window： 初始搜索窗口，就是定义ROI的rect<br>criteria: 确定窗口搜索停止的准则，主要有迭代次数达到设置的最大值，窗口中心      的漂移值大于某个设定的限值等。<br>实现Meanshift的主要流程是：<br>读取视频文件：cv.videoCapture()<br>感兴趣区域设置：获取第一帧图像，并设置目标区域，即感兴趣区域<br>计算直方图：计算感兴趣区域的HSV直方图，并进行归一化<br>目标追踪：设置窗口搜索停止条件，直方图反向投影，进行目标追踪，并在目标位置绘    制矩形框。<br>2.camshift算法：连续自适应MeanShift算法，是对MeanShift算法的改进算法，可随着跟踪目标的大小变化实时调整搜索窗口的大小，具有较好的跟踪效果。Camshift算法首先应用meanshift，一旦meanshift收敛，它就会更新窗口的大小，还计算最佳拟合椭圆的方向，从而根据目标的位置和大小更新搜索窗口。<br>Camshift在OpenCV中实现时，只需将上述的meanshift函数改为Camshift函数即可</p><p>Mat头部：图片的长宽高，参数的数据类型，通道数</p><p>赋值a=b是改变指针，只有拷贝才能创建新的。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习</title>
      <link href="/2024/03/13/mysql/"/>
      <url>/2024/03/13/mysql/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据收集与处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统架构</title>
      <link href="/2024/03/12/linux/"/>
      <url>/2024/03/12/linux/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优控制理论</title>
      <link href="/2024/03/09/MaxControl/"/>
      <url>/2024/03/09/MaxControl/</url>
      
        <content type="html"><![CDATA[<p>最优控制的目标：<br>对于一个状态空间方程表示的系统，在满足约束条件的前提下，将系统状态从起始步x[0]转移到目标步xd的最优控制策略，其中最优控制的评判标准是代价函数J的最小值。</p><p>代价函数J由两部分组成，分别是用hd表示的末端代价，即终止步x[N]（N表示状态转移的总步长）与目标值xd的差距；以及用gd表示的运行代价，其又分为两部分，分别是系统在运行的每个状态转移步x[k]下与对应状态下的目标步xd[k]的差距，以及每个状态转移所需要输入的能耗u[k]的代价。<br>以下面这个离散系统的为例，可以看到随着步进，x[N]实际上是一个关于x[0],u[0],u[1]…u[N-1]的函数，也就是随着输入的进行，将系统状态从起始步x[0]转移到目标步xd的过程，而我们的目标就是找到最优的一系列输入u<em>[0],u</em>[1]…u*[N-1]使系统完成转移的同时代价函数最小。</p><p>最优控制的基本策略是动态规划和逆向分级，其数学原理是贝尔曼最优原理。<br>以下面这个简单的离散系统为例，步长N=2，初始步x[0]=1，目标步xd=0，代价函数如下：</p><p>要设计每步的输入u[k]使代价函数最小，即为最优的控制策略，定义*为最优策略符。<br>由于步长为2，显然进行两次输入就会结束，故要求的输入为u[0]和u[1]。<br>根据贝尔曼最优原理，要使J0-&gt;2最小，J1-&gt;2显然也是最小的，这就是一个逆向分级的思想。<br>那么要求J0-&gt;2的最小值，首先就要求J1-&gt;2的最小值：</p><p>列出J1-&gt;2的方程，此时系统状态为x[1]为已知值，故把终止步x[2]利用状态方程表示为x[1]和u[1]的组合，则此时J1-&gt;2为与x[1]和u[1]有关的函数，而x[1]为已知量，故J1-&gt;2=f(u[1])，只需要dJ1-&gt;2/du[1]=0即可求出该函数的极点（可证明为最小值），对应的u[1]即为能使J1-&gt;2取最小值的最优值u<em>[1]。<br>得到了min{J1-&gt;2}就可以进一步求min{J0-&gt;2}，列出J0-&gt;2的方程不难发现其包含J1-&gt;2部分，这也是贝尔曼最优原理的体现。显然要得到min{J0-&gt;2}，J1-&gt;2要取之前求到的最小值，这个值与x[1]有关，同样我们利用状态方程将其表示为x[0]和u[0]的组合，而此时x[0]为已知量，故求dJ1-&gt;2/du[1]=0同样可求出该函数的极点，对应的u[0]即为能使J0-&gt;2取最小值的最优值u</em>[0]。</p><p>由此可以求出各状态和输入的最优值如下，代价函数的最小值为0.8，可以看到此时系统终止步并不在目标位置x[d]，这是由代价函数的设置决定的，即代价函数只认可将其取值最小的结果，对于是否到达目标位置并不关心，这点在之后会优化。</p><p>LQR控制器：Linear Quadratic Regulator线性二次型调节器<br>LQR控制器由线性状态函数和二次型代价函数组成，这里详细解释一下代价函数。<br>代价函数中的末端代价和运行代价的概念没有变，仍然是当前步与当前目标步的欧几里得范数，而SQR均为参数对角矩阵，表示了对各输入和状态的不同重视程度，值越大越重视。</p><p>对于调节系统（xd=0）来说，代价函数简化成如下形式：</p><p>同样采用逆向分级的思想可以发现JN-k-&gt;N总是包含JN-k+1-&gt;N的部分，故要使JN-k-&gt;N取到最小值，显然JN-k+1-&gt;N也要是最小值</p><p>以求min{JN-1-&gt;N}为例，同样先把x[N]=Ax[N-1]+Bu[N-1]表示：</p><p>求解这个方程即可得到对应的最佳输入：</p><p>将输入u*[N-1]代回JN-1-&gt;N即可得到此时从N-1-&gt;N的最小代价函数值：</p><p>可以看到如果把中间的一长串定义为P[1]，则它具有与JN-&gt;N中P[0]一样的形式<br>类似的，JN-k-&gt;N与JN-1-&gt;N具有相似的形式，如下所示：</p><p>可以看到上述的红框部分即为实现代价函数最小的最佳输入，在求解过程中，P[k]和u[k]的计算总是从终点步开始逆向求解的，而状态转移的进行却是从x[0]开始的，也就是说最优输入的确定完全是离线运算，不依赖于现在的状态。</p><p>把F矩阵看做常数？<br>对于轨迹追踪（xd!=0）系统来说，我们需要引入误差e[k]=x[k]-xd[k]，则对x[k]的轨迹追踪问题就变为了对e[k]的调节问题，现在的问题是怎么把系统变量由x[k]变为e[k]。</p><p>先看最简单的一种情况，即目标步为一常数，即xd[k]为一不变值，即AD=I<br>此时系统的状态方程如下：</p><p>定义增广形式的状态变量xa[k]和状态方程如上所示，同时误差e[k]可以写作以下形式：</p><p>上式建立了e[k]和xa[k]的关系，之前我们提到了一般的二次型代价函数，则其可以改写如下：</p><p>这个代价函数是关于增广状态变量xa[k]的，因此可以与xa[k]对应的状态方程联立进行LQR：</p><p>可以看到其格式完全符合LQR的调节形式，使用之前的理论构建输入u[k]即可<br>值得指出的是，使用LQR的代价函数也有可能导致系统无法达到目标的情况，这与之前提到过的代价函数设置别无二致，这种控制方式我们称之为目标误差控制。</p><p>能够解决这个问题的方法被称为稳态非零参考值控制：<br>我们假设系统到达目标时处于常值稳态xd，对应的输入也为常值稳态ud，即：</p><p>显然在xd/A/B已知的时候ud为一已知量，此时我们定义稳态输入误差δu[k]=u[k]-ud：</p><p>同样定义增广形式的状态变量xa[k]和状态方程如上所示，注意此时的u[k]为δu[k]，对应代价函数的u[k]项也为δu[k]，此时就可以结合xa[k]和δu[k]建立LQR关系。</p><p>其中xa[k]为已知量，δu[k]为要求的最优控制值δu*[k]。由于我们此时得到的是δu[k]，因而对u[k]的控制应该在ud的基础上加上δu[k]。</p><p>可以发现，在目标误差控制中代价函数以u的形式出现，体现了代价函数对能耗的看重，只有以一个比较适合的能耗完成过程才能满足代价函数，故目标误差控制中往往不能使系统转移到目标步；而在稳态非零参考值控制中代价函数以δu的形式出现，体现了代价函数对偏移的看重，只有偏移越小才能满足代价函数，故稳态非零参考值控制可以提供一个理想的ud使系统转移到目标点xd。<br>更加复杂的控制是输入增量控制，此时系统轨迹xd为非常数，即AD!=I</p><p>此时我们的目标是△u[k]，代价函数要尽可能削减△u[k]的值使输入变化平滑<br>此时的增广状态为xa[k]=[x[k],xd[k],u[k-1]]<br>则此时系统的状态方程和代价函数可以写做：</p><p>同样，此时的状态方程和代价函数是关于xa[k]和△u[k]的，可以对xa[k]和△u[k]进行LQR，解出△u[k]的最优控制策略，同样对u[k]的控制应该在u[k-1]的基础上加上△u[k]。</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用指令</title>
      <link href="/2024/03/09/command/"/>
      <url>/2024/03/09/command/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非线性控制理论</title>
      <link href="/2024/03/08/NonlinearControl/"/>
      <url>/2024/03/08/NonlinearControl/</url>
      
        <content type="html"><![CDATA[<p>函数的正定与负定：<br>V为李雅普诺夫函数，对于非线性系统[dotX]=f([X])而言，dotV的求解公式如下：</p><p>以一个单摆系统为例，其状态方程如下：</p><p>那么怎么确定V呢？技巧是从能量角度入手：</p><p>如果给系统加上摩擦，那么状态空间方程将变为：</p><p>可以看到从物理上看，无摩擦的系统是非渐进稳定的，而有摩擦的系统是渐进稳定的<br>但是从数学角度上看，我们只证明了两个系统均是稳定的，但对是否渐进稳定无法判定<br>于是我们引入不变性原理来判断系统的渐进稳定性：<br>一个系统是渐进稳定的，意味着其存在一个V，满足：<br>V为正定，范围内dotV为半负定，dotV仅在[X]=0时值为0</p><p>确切地说，第三个条件是指dotV沿任意不过零点的轨迹移动值都不为0</p><p>于是我们分析有摩擦的系统，可以发现其前两条条件满足，对于第三个条件：<br>当dotV=0时仅有x2=0，因而能使dotV=0仅在x2=0这条轨迹上可能成立，故对于所有的时间t来说，dotx2都等于0，故可以求得此时仅可能x1=x2=0，因而条件三也成立，系统渐进稳定</p><p>同理对于无摩擦系统而言，条件三并不满足，故系统不是渐进稳定的。</p><p>非线性系统稳定性设计：<br>目的是设计输入u=f(x)使新的闭环系统相比原开环系统而言具有更好的稳定性</p><p>常见的方法有两种，一种是设计输入直接消除状态方程的非线性部分并使其线性稳定<br>例如下面这个例子，可以看到u=f(x)提供了两方面的支持，前半部分消除了状态方程的非线性部分，后半部分为系统提供了稳定的特征值（极点），这种方法非常简单粗暴，但有时候并不那么容易实现，结果也并非最优</p><p>另一种方法是使用李雅普诺夫直接法，根据系统状态方程和李雅普诺夫函数，设计输入u=f(x)使dotV负定即可，如下面这个例子所示：</p><p>可以看到设计非线性系统稳定性有很多种方法，但设计出的函数效果却有差别。</p><p>反馈线性化控制：（反步设计法）<br>目的是利用u使x趋近x1d，以下面这个状态空间方程为例：</p><p>由于这个系统中x2直接控制x1，而u直接控制x2，故控制链应为u-&gt;x2-&gt;x1，这被称之为链式控制，为了控制u使x1趋近x1d，我们应该分两步：首先找到一个x2d控制x1使x1趋近x1d，再设计一个u控制x2使x2趋近x2d。<br>那么首先来看第一步，找到一个x2d控制x1使x1趋近x1d：<br>为了表现x1趋近x1d的过程，引入新状态e=x1d-x1-&gt;0，亦即李雅普诺夫函数V1(e)满足稳定性判据即可，故我们设计V(e)=0.5e^2，为了使dotV(e)=e<em>dote负定，可以设计dote=-k1</em>e来实现，由我们找到了设计x2d的函数。<br>接下来看第一步，设计一个u控制x2使x2趋近x2d：</p><p>为了表现x2趋近x2d的过程，引入新状态δ=x2d-x2-&gt;0，现在我们的目标就是使δ,e-&gt;0，所以我们要设计新的李雅普诺夫函数V2(e,δ)满足稳定性判据，故我们设计V2(e,δ)=0.5e^2+0.5δ^2，<br>为了使dotV(e,δ)=e<em>dote+δ</em>dotδ负定，可以设计e+dotδ=-k2*δ来实现，由此我们找到了设计u的函数：</p><p>式中e=x1d-x1,δ=x2d-x2，其中x1d为给定的，而x1和x2是可观的，x2d是由和x1d求得的，故u就是确定的。也就是说我们只需要得到x1d，x1和x2就可以得到一个输入u使x趋近x1d，这也就是反馈线性化控制的目标。</p><p>非线性自适应控制器：<br>之前的反步设计法中有一个前提，那就是系统的参数矩阵a我们是知道的，但很多情况下这个值可能多变或不可知，这时候就要找到一个自适应的控制器去实现。<br>以下面这个轨迹追踪系统使x-&gt;xd为例：</p><p>如果a已知，那么用之前的理论可以容易设计出输入u=dotxd-ax^2+ke<br>但如果现在a不可知怎么办呢？虽然a不可知，但我们可以认为a为一常数，即dot{a}=0<br>我们设计一个估计值hat{a}，估计值与真实值的估计误差为tilde{a}=a-hat{a}<br>则dot{tilde{a}}=dot{a}-dot{hat{a}}=-dot{hat{a}}<br>于是我们定义李雅普诺夫函数V(e,tilde{a})=0.5e^2+0.5tilde{a}^2<br>而此时的输入u应设计为与估计值hat{a}相关，即u=dot{xd}-hat{a}x^2+ke</p><p>为了使dotV(e)负定，应设计dot{tilde{a}}=-ex^2，故输入u即为：</p><p>非线性鲁棒控制器：<br>鲁棒控制器的目标相比自适应控制器来说更加苛刻，此时a不仅是不可知的，而且是在有界下变动的。这个时候的u应该怎么设计呢？我们介绍三种非线性鲁棒控制器，分别是滑膜控制，High Gain和High Frequency。<br>假设此时的系统为dot{x}=f(x)=u，目标是设置u使x-&gt;xd，有界判定是|f(x)|&lt;ρ(x)（ρ自设）</p><p>非线性鲁棒控制器指出可以把输入设成如下形式，其中Uaux的设置取决于不同的控制方法：</p><p>①滑膜控制：设置输入u如下：</p><p>证明将u设置成这种形式可以使偏差e稳定：</p><p>可以看到随着t-&gt;∞，不等式右边逐渐趋向于0，故e也一定在t-&gt;∞时趋向于0，这是一种指数的渐进稳定。这么设置的缺点在于sgn(e)会在1和-1间突变，导致输入u也会突变，这可能是对执行器的一种挑战。<br>②High Gain：设置输入u如下：</p><p>证明将u设置成这种形式可以使偏差e稳定：</p><p>可以看到当ρ|e|&gt;epsilon时dotV(e)负定，e会趋于0</p><p>可以看到当ρ|e|&lt;=epsilon时随着t-&gt;∞，e虽然不会趋于0，但也会趋于一个有限的小值。这个小值受epsilon影响，可以看到设置的输入u越大（即epsilon越小），系统最终的偏差也会越小，可以明白High Gain即是用足够大的输入去抵消系统的不确定性。<br>③High Frequency：设置输入u如下：</p><p>可以看到当epsilon=0时其即为滑膜控制，而当epsilon!=0时其值小于1，因而整体更加平和。<br>证明将u设置成这种形式可以使偏差e稳定：</p><p>可以看到与High Gain一样，High Frequency也会使系统最终趋向于一个同样的有限小值。同样的，设置的输入u越大（即epsilon越小），系统最终的偏差也会越小。<br>④对比讨论：<br>总结一下，三种非线性鲁棒控制器各有优劣，epsilon的选值也体现了系统是更重视输入还是收敛，定性的排名如下所示，其中5表示最强1表示最弱。</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非线性控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代控制理论</title>
      <link href="/2024/03/06/ModernControl/"/>
      <url>/2024/03/06/ModernControl/</url>
      
        <content type="html"><![CDATA[<p>数学基础：<br>1.特征值λ与特征向量v：（已知A为n<em>n，则v为n</em>1，λ为1*1）</p><p>2.矩阵与坐标变换：<br>原直角系下(-1,2)的向量，将i向量变换为(3,1)，j向量变换为(1,2)后的变换向量在原直角系下的值即为以下矩阵求解出来的值。</p><p>Z为状态，U为输入，Y为输出</p><p>对于n状态m输入k输出的系统而言：<br>[A]为n<em>n的矩阵，[B]为n</em>m的矩阵，[C]为k<em>n的矩阵，[D]为k</em>m的矩阵<br>[X]和[dotX]为n<em>1的向量，[U]为m</em>1的向量，[Y]为k*1的向量<br>所谓开环系统，即无输入[U]=0的系统<br>求解状态空间方程的解：</p><pre><code>                    状态转移矩阵                          卷积</code></pre><p>利用状态空间方程判断系统的稳定性：<br>平衡点的确定：怎么判断系统最终会趋向于一个怎样的平衡位置呢？只需令所有的[dotX]均为0，则此时系统处于平衡状态，利用状态空间方程即可求出对应的[X]值</p><p>λ其实就是经典控制理论中的极点</p><p>连续系统离散化：<br>由连续系统下状态空间方程的解可得：</p><p>系统的可控性判据：<br>离散型证明：</p><p>只有一个系统是可控的，它才可能在控制中做文章，比如改变其稳定性</p><p>李雅普诺夫意义下的稳定性：</p><p>其中蓝线为李雅普诺夫意义下的稳定性，棕线为渐进稳定性<br>对于线性时不变系统，λ的取值仍可以反映上述稳定性</p><p>线性控制器的设置：（前提是系统完全可控）<br>为了改变开环系统的稳定性，我们引入输入量使之成为闭环系统，故改变稳定性也就是改变特征根λ，故我们可以引入线性控制器[U]=-[k][X]，此时[X’]=([A]-[B][k])[X]</p><p>举个例子：</p><p>这个时候我们如果要让λ1=λ2=1收敛，即：</p><p>对λ值选取的考虑涉及很多因素，例如：</p><p>其中对输入的考虑涉及到最优控制和LQR，Q矩阵看重收敛速度，R矩阵看重输入值<br>以倒立摆模型为例：</p><p>该模型最终的微分方程即，转换成状态空间方程就是：</p><p>其在开环下不稳定：</p><p>检验其可控性，为了使其稳定，引入线性控制器：</p><p>如果仍要让λ1=λ2=1收敛：</p><p>基于线性控制器的LQR控制器：使用代价函数来求取好的特征值<br>对于n状态m输入k输出的系统而言：Q矩阵规模为n<em>n，R矩阵规模为m</em>m</p><p>根据控制要求给定QR矩阵（Q看中状态的收敛速度，R看中输入的力度）求取代价函数J的最小值（matlab的lqr函数），可以确定线性控制器的K矩阵<br>以前面的倒立摆为例：</p><p>建立系统的数学模型：</p><p>利用LQR得到最适合所设QR的K1和K2代入系统即可：</p><p>由于Q大R小，可以看到x1快速收敛，而输入U的初值则非常的大</p><p>状态观测器：<br>先前我们进行的线性控制器设计基于[U]=-[K][X]的关系，这个关系隐含着[X]的可观性，如果[X]不可观，我们往往就需要使用状态观测器来观察系统的状态</p><p>以下面这个状态观测器为例，其引入了L(y-hat{y})项，目标是找到L（n*m）使hat{y}趋近y</p><p>可以看到⑤式即为一个接收系统输入、输出来得到估计状态的观测器</p><p>显然，为了让状态观测器尽可能精确，ex的值应趋向于零<br>为了让ex的值趋于稳定（0），由前知识可知应该使A-LC的特征值均小于0<br>以一个弹簧阻尼系统（速度不可测）为例：</p><p>确定了系统模型后，接下来开始设计状态观测器：</p><p>由此确定的观测器为：</p><p>通过simulink建模：</p><p>可以看到z2和z2hat几乎完全一致：</p><p>因此即使我们无法观测z2的值，我们也可以通过创建一个状态观测器来得到z2的一个估计值z2hat，事实证明这个估计值已足够精确于真实值。</p><p>轨迹跟踪：<br>所谓轨迹跟踪，就是让状态量根据自己的需求稳定在一个非零值上，仍然以倒立摆为例：<br>此时只需要将原来的状态量x变为误差e，把e作为新的状态量，只要让e-&gt;0就能让x-&gt;xd</p><p>此时新的状态方程开环平衡点如下，可以看到ef不等于0，也就是平衡时x不等于xd，这显然不是我们想要的结果。故设计控制器除了为让系统稳定之外，还有调整平衡点的作用。</p><p>勘误：这里ef=g/l*x1d应为x1d<br>于是我们设计线性控制器时有意识的添加一个常量以修正平衡点偏移：</p><p>可以看到此时平衡点已经满足要求了，接下来就是使系统稳定</p><p>可见将输入设计为上式即可使系统稳定的同时实现目标轨迹规划</p><p>系统的可观性：</p><p>只有一个系统是可观的，它才能使用观测器；只有一个系统是可控的，它才能使用控制器<br>可观不意味着所有状态都容易测量，因此有时仍需要使用状态观测器<br>下例是一个控制器+观测器系统：（此时控制器的控制依据是观测器的观测结果u=-k*hat{x}）</p><p>以上就是这个控制器+观测器系统的状态方程，为使系统稳定应让特征值均小于0，而M的特征值就是A-LC和A-BK的特征值，由此实现了控制器与观测器的设计分离原则，即可以A分别设计L和K使A-LC和A-BK的特征值小于0，则M的特征值也必然小于0</p><p>为了保证观测的准确性，额外要求观测器的收敛速度快于控制器</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LQR线性二次型调节器</title>
      <link href="/2024/03/04/LQR/"/>
      <url>/2024/03/04/LQR/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LQR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS学习</title>
      <link href="/2023/12/05/ROS/"/>
      <url>/2023/12/05/ROS/</url>
      
        <content type="html"><![CDATA[<h1 id="使用vscode创建并应用一个ros项目："><a href="#使用vscode创建并应用一个ros项目：" class="headerlink" title="使用vscode创建并应用一个ros项目："></a>使用vscode创建并应用一个ros项目：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1.使用命令行创建工作空间：</span><br><span class="line">mkdir -p 工作空间名称/src(必须得有 src)</span><br><span class="line">cd 工作空间名称</span><br><span class="line">catkin_make（编译）</span><br><span class="line">2.进入工作空间，启动vscode：</span><br><span class="line">cd 工作空间名称</span><br><span class="line">code .</span><br><span class="line">3.vscode中编译ros：</span><br><span class="line">ctrl + shift + B 调用编译，选择:catkin_make:build，并点击右侧齿轮自动创建tasks.json文件，修改.vscode/tasks.json 文件如下：</span><br><span class="line">&#123;</span><br><span class="line">// 有关 tasks.json 格式的文档，请参见</span><br><span class="line">    // https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">    &quot;label&quot;: &quot;catkin_make:debug&quot;, //代表提示的描述性信息</span><br><span class="line">    &quot;type&quot;: &quot;shell&quot;,  //可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行</span><br><span class="line">    &quot;command&quot;: &quot;catkin_make&quot;,//这个是我们需要运行的命令</span><br><span class="line">    &quot;args&quot;: [],//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2”</span><br><span class="line">    &quot;group&quot;: &#123;&quot;kind&quot;:&quot;build&quot;,&quot;isDefault&quot;:true&#125;,</span><br><span class="line">    &quot;presentation&quot;: &#123;</span><br><span class="line">&quot;reveal&quot;: &quot;always&quot;//可选always或者silence，代表是否输出信息</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;problemMatcher&quot;: &quot;$msCompile&quot;</span><br><span class="line">&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">4.创建ros运行包名及其依赖的工具包：</span><br><span class="line">选择大src后右击create catkin package键入包名（Package name）和依赖包名（Dependencies:roscpp rospy std_msgs）</span><br><span class="line">// 平替在终端中输入catkin_create_pkg 自定义ROS包名 依赖名(roscpp rospy std_msgs）的过程，会体现在package.xml中&lt;build_depend&gt;和&lt;exec_depend&gt;以及CMakeLists.txt L10 find_package中，如果再创建好后要增删依赖包，也只需要在上述文件的对应位置进行修改即可·</span><br><span class="line">5.C++实现：</span><br><span class="line">在小src下新建cpp文件</span><br><span class="line">如果没有代码提示需要修改 .vscode/c_cpp_properties.json中的&quot;cppStandard&quot;为&quot;c++17&quot;</span><br><span class="line">当ROS__INFO 终端输出有中文时，会出现乱码，此时要在在函数开头加入下面代码的任意一句：setlocale(LC_CTYPE, &quot;zh_CN.utf8&quot;)/setlocale(LC_ALL, &quot;&quot;)</span><br><span class="line">6.Python实现：</span><br><span class="line">在小src同级下新建scripts文件夹添加py文件和可执行权限chmod +x xxx.py（之后命令行语句都可以在vscode下新建终端，一种是点击终端加号，一种是选中文件夹右键点击集成终端）</span><br><span class="line">7.编辑小src文件夹下的CMakeLists.txt文件：（取消注释）</span><br><span class="line">C++ 配置:</span><br><span class="line">L136:add_executable(节点名称 src/C++源文件名.cpp)</span><br><span class="line">L145:add_dependencies(节点名称 $&#123;PROJECT_NAME&#125;节点依赖)：节点依赖对于话题通信为_generate_messages_cpp，对于服务通信为_gencpp，如果没有自定义文件格式则无需配置</span><br><span class="line">L149:target_link_libraries(节点名称 $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">如果有多个cpp文件，就要对每个cpp文件都进行上述步骤</span><br><span class="line">Python 配置:</span><br><span class="line">L162:catkin_install_python(PROGRAMS scripts/自定义文件名.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)</span><br><span class="line">//其实可以把python的文化名.py就认为是它的节点名</span><br><span class="line">8.编写launch启动：</span><br><span class="line">在小src同级下创建文件夹launch，在其中创建launch文件xxx.launch</span><br><span class="line">一旦键入&lt;launch&gt;和&lt;/launch&gt;就意味着进行了roscore</span><br><span class="line">创建一个节点就相当于进行一个rosrun，格式为&lt;node创建节点 pkg=&quot;包名&quot; type=&quot;节点名(c++)/文件名.py(python)&quot; name=&quot;标识名&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">9.编译执行：（编译执行终端需架设在工作空间下）</span><br><span class="line">每次重新修改好ros文件，除了ctrl+s之外还需要进行重新编译ctrl+shift+B和重新执行</span><br><span class="line">重新执行的方法即在vscode终端下输入命令：source ./devel/setup.bash =&gt; roslaunch 包名 launch文件名</span><br><span class="line">//非launch启动时重新执行的命令为source ./devel/setup.bash</span><br><span class="line">//roslaunch平替多开终端并进行roscore，rosrun 包名 C++节点名/文件名.py的过程</span><br></pre></td></tr></table></figure><h1 id="ros文件的基本架构："><a href="#ros文件的基本架构：" class="headerlink" title="ros文件的基本架构："></a>ros文件的基本架构：</h1><p>其中工作空间catkin workspace和大src由mkdir创建，build/devel由catkin_make创建，包名package由create catkin package创建，其下会自动创建inc，src文件夹用于存放c++文件，CMakeLists.txt用于编译c++和python文件，package.xml定义有关软件包的属性（依赖的包和构建工具），文件夹scripts由自己创建用于存放python文件，文件夹launch由自己创建用于存放launch文件用于多启动，文件夹msg由自己创建用于存放msg文件用于规定服务通信下的自定义通讯格式，文件夹srv由自己创建用于存放srv文件用于规定话题通信下的自定义通讯格式。</p><h1 id="话题通讯："><a href="#话题通讯：" class="headerlink" title="话题通讯："></a>话题通讯：</h1><p>基于发布订阅模式，一个节点发布消息，另一个节点订阅该消息。常用于不断更新的、少逻辑处理的数据传输场景，如激光雷达的数据采集。<br>话题通讯的理论模型如下：</p><p>话题通讯涉及到三个角色:ROS Master (管理者)，Talker (服务端)，Listener (客户端)<br>ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配话题相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Talker 可以发布消息，且发布的消息会被 Listener 订阅。注意事项如下：<br>1.Talker 与 Listener 的启动无先后顺序要求</p><ol><li>Talker 与 Listener 都可以有多个</li><li>Talker 与 Listener 连接建立后，不再需要 ROS Master。即便关闭ROS Master，Talker 与 Listener 照常通信。</li></ol><p>ROS官方提供的话题通讯基本格式如下：</p><p>当使用自定义通讯格式进行话题通讯时，需要进行以下操作：<br>1.定义msg文件：在小src同级下创建msg文件夹并创建xxx.msg文件，在其中以类似结构体的格式输入需要定义的自定义通讯格式构成，例如：<br>string name<br>uint16 age<br>float64 height<br>2.编辑package.xml：<br>这里简单介绍一下package文件的构成，package的核心代码如下：<br>①依赖的构建工具</p><p><buildtool_depend>catkin</buildtool_depend><br>②指定构建此软件包所需的软件包 （编译依赖）</p><p><build_depend>roscpp</build_depend></p><p><build_depend>rospy</build_depend></p><p><build_depend>std_msgs</build_depend><br>③指定根据这个包构建库所需要的包（编译外部依赖）</p><p><build_export_depend>roscpp</build_export_depend></p><p><build_export_depend>rospy</build_export_depend></p><p><build_export_depend>std_msgs</build_export_depend><br>④运行该程序包中的代码所需的程序包（执行依赖）</p><p><exec_depend>roscpp</exec_depend></p><p><exec_depend>rospy</exec_depend></p><p><exec_depend>std_msgs</exec_depend><br>我们要在编译依赖中添加<build_depend>message_generation</build_depend><br>在执行依赖中添加<exec_depend>message_runtime</exec_depend><br>3.编辑CMakeLists.txt：<br>L10：取消注释并修改编译依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L51：取消注释并配置msg源文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  xxx.msg</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L71：取消注释使自定义消息格式依赖于 std_msgs：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L108：取消注释并修改执行依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>4.编译：此时C++调用的中间文件位于(…/工作空间/devel/include/包名/xxx.h)<br>Python调用的中间文件位于(…/工作空间/devel/lib/python3/dist-packages/包名/msg/xxx.py)，之后要想使用这一自定义通讯格式就需要包含这个头文件。</p><p>代码实现C++话题通讯：<br><em>1.如果使用自定义格式，需要添加c_cpp_properties.json 的 includepath属性如下：<br> “/xxx/yyy工作空间/devel/include/*</em>“ //配置 head 文件的路径<br>2.包含通讯所需格式的头文件：<br>对于ROS官方提供的基本格式需要包含#include “std_msgs/xxx.h”<br>对于自定义的格式需要包含#include “包名/xxx.h”（即自定义格式经编译得到的头文件）<br>3.发布方实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Publisher”);<br>ros::NodeHandle nh;<br>②创建发布者对象：（发布者和订阅者的话题topic需要一致）<br>官方格式：ros::Publisher pub = nh.advertise<std_msgs::xxx>(“topic”, 10);<br>自定义格式：ros::Publisher pub = nh.advertise&lt;包名::xxx&gt;(“topic”, 10);<br>③编辑要发送的数据：<br>创建对象：std_msgs::xxx/包名::xxx msg;<br>4.订阅方实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Publisher”);<br>ros::NodeHandle nh;<br>②创建订阅者对象：<br>官方：ros::Subscriber sub = nh.subscribe<std_msgs::xxx>(“topic”,10,doMsg);<br>自定义：ros::Subscriber sub = nh.subscribe&lt;包名::xxx&gt;(“topic”,10,doMsg);<br>③循环调用回调函数：ros::spin();<br>④搭建回调函数doMsg：void doMsg(const 包名::xxx::ConstPtr &amp;msg){}</p><h1 id="服务通信："><a href="#服务通信：" class="headerlink" title="服务通信："></a>服务通信：</h1><p>基于请求响应模式，是一种应答机制，一个节点A向另一个节点B发送请求，B接收处理请求并产生响应结果返回给A，常用于偶然的、对时时性有要求、有一定逻辑处理需求的数据传输场景，例如摄像头数据的采集与访问。</p><p>服务通信的理论模型如下:<br>服务通信涉及到三个角色:ROS Master (管理者)，Talker (发布者)，Listener (订阅者)<br>ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配服务相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Client 发送请求信息，而Server 则返回响应信息。注意事项如下:<br>1.客户端请求被处理时，需要保证服务器已经启动（这点与话题通信不同）<br>2.服务端和客户端都可以存在多个<br>同理于话题通信，服务通信也存在自定义通信格式srv，当使用自定义通讯格式进行服务通讯时，需要进行以下操作：<br>1.定义srv文件：在小src同级下创建srv文件夹并创建xxx.srv文件，在其中以类似结构体的格式输入需要定义的自定义通讯格式构成。在 srv 文件中，数据分成请求与响应两部分，之间使用—-分割，例如:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int32 num1# 客户端请求时发送的两个数字</span><br><span class="line">int32 num2</span><br><span class="line">---</span><br><span class="line">int32 sumCopy# 服务器响应返回两个数据之和</span><br></pre></td></tr></table></figure><br>2.编辑package.xml：此处需要修改的与话题通信一致，即：<br>在编译依赖中添加<build_depend>message_generation</build_depend><br>在执行依赖中添加<exec_depend>message_runtime</exec_depend><br>3.编辑CMakeLists.txt：<br>L10：取消注释并修改编译依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L58：取消注释并配置srv源文件：（对应于话题通信的L51配置msg源文件）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(</span><br><span class="line">FILES</span><br><span class="line">xxx.srv</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L71：取消注释使自定义消息格式依赖于 std_msgs：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L108：取消注释并修改执行依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>4.编译：此时C++调用的中间文件位于(…/工作空间/devel/include/包名/xxx.h)<br>除了xxx.h外，由于服务通信包含请求方与响应方两部分，故还有xxxRequest.h和xxxResponse.h两个文件。<br>Python调用的中间文件位于(…/工作空间/devel/lib/python3/dist-packages/包名/msg/xxx.py)，之后要想使用这一自定义通讯格式就需要包含这个头文件。</p><h1 id="代码实现C-服务通讯："><a href="#代码实现C-服务通讯：" class="headerlink" title="代码实现C++服务通讯："></a>代码实现C++服务通讯：</h1><p><em>1.如果使用自定义格式，需要添加c_cpp_properties.json 的 includepath属性如下：<br> “/xxx/yyy工作空间/devel/include/**” //配置 head 文件的路径<br>2.包含通讯所需格式的头文件：<br>自定义格式需要包含#include “包名/xxx.h”（即自定义格式经编译得到的头文件）<br>3.服务端实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Server”);<br>ros::NodeHandle nh;<br>②创建服务端对象：（服务端和客户端的服务需要一致，服务端不需要泛型）<br>ros::ServiceServer server = nh.advertiseService(“xxx”, doReq);<br>③循环调用回调函数：ros::spin();<br>④搭建回调函数doReq：bool doReq(包名::xxx::Request &amp;request,包名::xxx::Response &amp;response){}用于处理请求并组织响应（Req和Res都有对应对象）<br>4.客户端实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Client”);<br>ros::NodeHandle nh;<br>②创建客户端对象：<br>ros::ServiceClient client = nh.serviceClient&lt;包名::xxx&gt;(“xxx”);<br>③组织请求并处理响应：<br>ServiceCommunication::xxx ai;<br>ai.request/response….<br>bool flag = client.call(ai);</em>④挂起客户端等待服务端启动：<br>client.waitForExistence();或者ros::service::waitForService(“xxx”);</p><h1 id="参数服务器："><a href="#参数服务器：" class="headerlink" title="参数服务器："></a>参数服务器：</h1><p>用于设置、存储和获取静态的非二进制的简单数据，不是为高性能而设计的。<br>参数服务器的理论模型如下：</p><p>参数服务器涉及到三个角色:ROS Master (管理者)，Talker (设置者)，Listener (调用者)<br>ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数。<br>在 C++ 中实现参数服务器数据的增删改查，可以通过两套 API 实现:<br>①ros::NodeHandle<br>②ros::param<br>具体的实现方法可以参考代码相关部分<br>值得指出的是，参数服务器本身是随着roscore被一同创建出来的，因而它不需要任何显示的创建方式，且其本身会存储一部分系统创建的静态数据。<br>创建参数的另一种方法是在运行节点命令后加_参数键:=值，例如：<br>rosrun 包名 节点名 _length:=2即创建了一个值为2的参数length</p><h1 id="常用的ROS命令行命令："><a href="#常用的ROS命令行命令：" class="headerlink" title="常用的ROS命令行命令："></a>常用的ROS命令行命令：</h1><p>1.文件操作命令：<br>文件操作命令是静态的，操作的是磁盘上的文件<br>roscore：开启ros内核，运行ros程序前必须先开启ros内核<br>rosrun：运行ros节点，格式为：rosrun 包名 C++节点名/文件名.py [传入参数列表]<br>roslaunch：运行launch文件，格式为：roslaunch 包名 launch文件名<br>2.动态运行命令：<br>在ROS程序启动后，动态运行命令可以动态的获取运行中的节点或参数的相关信息，在测试和运行中对程序调试与纠错有重要作用。<br>rosnode：操作ros节点，是用于获取节点信息的命令。<br>rosnode ping 节点名               测试到节点的连接状态<br>rosnode list                        列出活动节点<br>rosnode info 节点名              打印节点信息<br>rosnode machine 设备名        列出指定设备上节点<br>rosnode kill 节点名               杀死某个节点<br>rosnode cleanup                清除不可连接的节点<br>rostopic：操作话题，用于显示调试信息，包括发布者，订阅者，发布频率和ROS消息。<br>rostopic echo 话题名              获取指定话题当前发布的消息（扮演订阅方角色）<br>rostopic hz 话题名                显示话题的发布频率<br>rostopic info 话题名              显示话题信息(消息类型,发布者信息,订阅者信息)<br>rostopic list                       显示所有活动状态下的话题</p><p>rostopic pub                     将数据发布到话题（扮演发布方角色）<br>单次发布：rostopic pub /话题名称 消息类型 消息内容<br>连续发布：rostopic pub -r 发布频率 /话题名称 消息类型 消息内容<br>rostopic type 话题名               列出话题的消息类型<br>rosservice：操作ros服务<br>rosservice call服务名              使用提供的参数调用服务（扮演客户端的角色）<br>rosservice call AddInts tabtab<br>rosservice info服务名            打印有关服务的信息<br>rosservice list                    列出所有活动的服务<br>rosservice type服务名            打印服务使用的数据类型<br>rosmsg：操作msg消息，用于话题通信<br>rosmsg info消息名                显示消息信息（包含哪些类型）<br>rosmsg list                        列出所有可用的msg消息类型<br>rossrv：操作srv消息，用于服务通信，方法与rosmsg完全一致<br>rosparam：操作ros 参数，用于参数服务器<br>rosparam set 参数键 值            设置参数<br>rosparam get 参数键                获取参数<br>rosparam delete 参数键           删除参数<br>rosparam list                    列出所有参数<br>rosparam load xxx.yaml           从外部文件加载参数<br>rosparam dump xxx.yaml        将参数写出到外部文件</p><h1 id="用小海龟进行复习模拟："><a href="#用小海龟进行复习模拟：" class="headerlink" title="用小海龟进行复习模拟："></a>用小海龟进行复习模拟：</h1><p>启动ros内核：roscore<br>启动海龟图形化界面节点：rosrun turtlesim turtlesim_node<br>启动海龟键盘控制节点：rosrun turtlesim turtle_teleop_key<br>1.话题发布模拟：<br>通过计算图查看话题，启动计算图：rqt_graph（也可以使用rostopic list）</p><p>可以看到键盘控制节点和图形化界面节点通过话题/turtle1/cmd_vel通信，并使Publisher键盘控制节点的消息以图形化的形式反馈在Subscriber图形化界面节点的乌龟移动上。<br>此外，我们通过对话题/turtle1/cmd_vel进行信息查询rostopic info /turtle1/cmd_vel<br>可以得到通信双方的节点名称和通信的信息类型为geometry_msgs/Twist</p><p>利用rosmsg info geometry_msgs/Twist我们便可以得到该信息的格式如下</p><p>其中linear为线速度，angular为角速度，易得对于只能向头朝向移动的2D小海龟，只有linear-x和angular-z的值非零，可以使用rostopic echo /turtle1/cmd_vel验证。<br>如果我们要使海龟做圆周运动，其方法就是向话题发布我们想要的命令，以此替代键盘达到的控制效果，使用rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist “linear: x: 1.0 y: 0.0 z: 0.0    angular: x: 0.0 y: 0.0 z: 1.0” 并修改其值是一个方法。<br>如果用代码实现，则可以创建CirclePublisher.cpp并如下写制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/Twist.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;CirclePublisher&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;</span><br><span class="line">(&quot;/turtle1/cmd_vel&quot;, 10);</span><br><span class="line">ros::Rate rate(10);</span><br><span class="line">geometry_msgs::Twist twist;</span><br><span class="line">twist.linear.x = 1.0f;</span><br><span class="line">twist.linear.y = 0.0f;</span><br><span class="line">twist.linear.z = 0.0f;</span><br><span class="line">twist.angular.x = 0.0f;</span><br><span class="line">twist.angular.y = 0.0f;</span><br><span class="line">twist.angular.z = 1.0f;</span><br><span class="line"></span><br><span class="line">while (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">pub.publish(twist);</span><br><span class="line">rate.sleep();</span><br><span class="line">ros::spinOnce();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.话题订阅模拟：<br>海龟图形化界面节点turtlesim会实时发布当前海龟的位姿和速度<br>对应发布到的话题为/turtle1/pose，使用rostopic info /turtle1/pose可得：</p><p>可见通信的信息类型为turtlesim/Pose且其只有发布方而没有订阅方<br>利用rosmsg info turtlesim/Pose得到该信息的格式如下：</p><p>值得指出的是坐标的原点是屏幕的左下角，角度变化只在[-π,π]之间变化<br>如果我们要获取当前海龟的位姿和速度信息并打印在屏幕上，其方法就是订阅话题的消息。<br>直接使用ros命令rostopic echo /turtle1/pose订阅是一个方法<br>如果用代码实现，则可以创建PoseSubscriber.cpp并如下写制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;turtlesim/Pose.h&quot;</span><br><span class="line"></span><br><span class="line">void doPose(const turtlesim::Pose::ConstPtr &amp;pose)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;The turtle&#x27;s x=%.2f,y=%.2f,theta=%.2f,linear=%.2f,</span><br><span class="line">angular=%.2f&quot;,pose-&gt;x,pose-&gt;y,pose-&gt;theta,pose-&gt;linear_velocity, pose-&gt;angular_velocity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;PoseSubscriber&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::Subscriber sub = nh.subscribe&lt;turtlesim::Pose&gt;(&quot;/turtle1/pose&quot;, 100, doPose);</span><br><span class="line">ros::spin();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.服务调用模拟：<br>向turtlesim发送请求，在图形化界面指定位置生成一只新的海龟，这是一个服务请求操作。<br>同样，首要的问题也是找到对应服务的名称，可以使用rosservice list找到/spawn服务<br>使用rosservice info /spawn可得：</p><p>可见得到服务的信息分别为提供服务的节点、节点的资源路径、当前服务使用的消息类型和请求服务需要提供的字段（位姿和名字）<br>利用rossrv info turtlesim/Spawn得到该信息的格式如下：</p><p>可以看到在请求上述四个参数后服务会响应新海龟的名称<br>同样的，我们可以使用ros命令rosservice call /spawn tabtab进行简单实现。<br>如果用代码实现，则可以创建SpawnService.cpp并如下写制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;turtlesim/Spawn.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;SpawnService&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">ros::ServiceClient client = nh.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;);</span><br><span class="line">turtlesim::Spawn spawn;</span><br><span class="line">spawn.request.x = 1.0f;</span><br><span class="line">spawn.request.y = 4.0f;</span><br><span class="line">spawn.request.theta = 1.57f;</span><br><span class="line">spawn.request.name = &quot;turtle2&quot;;</span><br><span class="line"></span><br><span class="line">ros::service::waitForService(&quot;/spawn&quot;);</span><br><span class="line">bool flag = client.call(spawn);</span><br><span class="line">if (flag)</span><br><span class="line">ROS_INFO(&quot;Success!The new turtle&#x27;s name is %s&quot;, </span><br><span class="line">spawn.response.name.c_str());</span><br><span class="line">else</span><br><span class="line">ROS_INFO(&quot;Failed!&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>4.参数服务器模拟：<br>可以通过修改修改turtlesim的参数服务器中的背景rgb参数来改变海龟图形化界面的背景色，这是一个参数服务器操作。<br>通过rosparam list可以找到控制背景色的三个参数：/turtlesim/background_r/g/b<br>通过rosparam get /turtlesim/background_r/g/b可以得到其值分别为69/86/255<br>可以使用ros命令rosparam set /turtlesim/background_r/g/b 0-255进行修改。<br>值得注意的是，需要将图形化界面重新启动才能产生效果。<br>如果用代码实现，则可以创建SpawnService.cpp并如下写制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;ColorParam&quot;);</span><br><span class="line"></span><br><span class="line">ros::param::set(&quot;/turtlesim/background_b&quot;, 0);</span><br><span class="line">ros::param::set(&quot;/turtlesim/background_g&quot;, 0);</span><br><span class="line">ros::param::set(&quot;/turtlesim/background_r&quot;, 0);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此外，我们还可以在启动节点时直接设置参数，或者通过launch文件传参的方法实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;set_bg&quot; output=&quot;screen&quot;&gt;&lt;rosparam command=&quot;load&quot; file=&quot;$(find demo03_test_parameter)/cfg/color.yaml&quot; /&gt;&lt;/node&gt;</span><br></pre></td></tr></table></figure><br>综合上述内容，我们讲解了ROS中最基本的也是最核心的通信机制实现: 话题通信、服务通信、参数服务器。三种通信机制中，参数服务器是一种数据共享机制，可以在不同的节点之间共享数据，而话题通信与服务通信则可以在不同的节点之间传递数据。<br>对比话题通信与服务通信两者可以看到明显的异同点：<br>二者的实现流程是比较相似的，都是涉及到四个要素:<br>要素1: 消息的发布方/客户端(Publisher/Client)<br>要素2: 消息的订阅方/服务端(Subscriber/Server)<br>要素3: 话题名称(Topic/Service)<br>要素4: 数据载体(msg/srv)<br>可以概括为: 两个节点通过话题关联到一起，并使用某种类型的数据载体实现数据传输。<br>同时，二者的实现也是有本质差异的，具体比较如下:</p><p>不同通信机制有一定的互补性，都有各自适应的应用场景。尤其是话题与服务通信，需要结合具体的应用场景与二者的差异，选择合适的通信机制。<br>接下来我们讲一讲ROS常用的API，其中部分已在之前的代码里有体现：<br>1.初始化API：<br>ROS节点的初始化使用ros::init实现：<br>void ros::init(int &amp;argc,char **argv,const std::string&amp; name,uint32 options=0)<br>使用示例：ros::init(argc, argv, “CirclePublisher”);<br>参数列表：argc 传入参数个数<br>           argv 传入参数列表<br>name 节点名称，需要保证其唯一性，不允许包含命名空间<br>options 节点启动选项，ROS中当有同名的节点同时处于运行状态时，先启动      的节点将会被关闭，为了使同名节点也能同时处于运行状态，可以设置options      为ros::init_options::AnonymousName实现，此时同名节点后会产生不同值      的随机数，以此避免重名问题。<br>返回值：void无返回值<br>2.话题与服务API：<br>ROS话题和服务的相关对象使用ros::NodeHandle创建：<br>故首先就要创建节点句柄ros::NodeHandle nh<br>①发布端对象：<br>1&gt;创建发布端对象：调用节点句柄的advertise函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class M&gt;</span><br><span class="line">Publisher advertise(const std::string&amp; topic, uint32_t queue_size, bool latch = false)</span><br><span class="line">使用示例：</span><br><span class="line">ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;, 10);</span><br></pre></td></tr></table></figure><br>泛型：M 话题中发布消息的类型格式<br>参数列表：topic 发布消息使用的话题<br>queue_size 等待发送给订阅者的最大消息数量<br>latch如果为 true,该话题发布的最后一条消息将被保存，并且后期当有订阅者      连接时会将该消息发送给订阅者，适用于发布的一些静态消息，例如导航地图<br>返回值：调用成功时，会返回一个发布端对象ros::Publisher<br>2&gt;发布消息：调用发布端对象的publish函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename M&gt;void publish(const M&amp; message) const</span><br></pre></td></tr></table></figure><br>使用示例：pub.publish(twist);<br>泛型：M 发布的消息message的类型格式<br>参数列表：message 向话题发布的信息，需要与话题中发布消息的类型格式一致<br>返回值：void无返回值<br>②订阅端对象：<br>1&gt;创建订阅端对象：调用节点句柄的subscribe函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class M&gt;</span><br><span class="line">Subscriber subscribe(const std::string&amp; topic, uint32_t queue_size, void(*fp)</span><br><span class="line">(const boost::shared_ptr&lt;M const&gt;&amp;))</span><br></pre></td></tr></table></figure><br>使用示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub = nh.subscribe&lt;turtlesim::Pose&gt;(&quot;/turtle1/pose&quot;, 100, doMsg);</span><br></pre></td></tr></table></figure><br>void doMsg(const 包名::xxx::ConstPtr &amp;msg){}<br>泛型：M 话题中订阅消息的类型格式<br>参数列表：topic 订阅的话题<br>queue_size 消息队列长度，超出长度时，头部的消息将被弃用<br>          fp 当订阅到一条消息时，需要执行的回调函数<br>返回值：调用成功时，会返回一个订阅端对象ros::Subscriber<br>③服务端对象：<br>1&gt;创建服务端对象：调用节点句柄的advertiseService函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class MReq, class MRes&gt;</span><br><span class="line">ServiceServer advertiseService(const std::string&amp; service, bool(*srv_func)</span><br><span class="line">(MReq&amp;, MRes&amp;))</span><br></pre></td></tr></table></figure><br>使用示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros::ServiceServer server = nh.advertiseService(&quot;AddInts&quot;, doReq);</span><br><span class="line">bool doReq(ServiceCommunication::AddInts::Request &amp;request,</span><br><span class="line">ServiceCommunication::AddInts::Response &amp;response)&#123;&#125;</span><br></pre></td></tr></table></figure><br>泛型：MReq 接收客户端消息并做处理的回调函数请求<br>  MRes 接收客户端消息并做处理的回调函数响应<br>参数列表：service 服务的名称<br>srv_func 接收到请求时，需要处理请求的回调函数<br>返回值：调用成功时，会返回一个服务端对象ros::ServiceServer<br>④客户端对象：<br>1&gt;创建客户端对象：调用节点句柄的serviceClient函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Service&gt;</span><br><span class="line">ServiceClient serviceClient(const std::string&amp; service_name, bool persistent = false, const M_string&amp; header_values = M_string())</span><br></pre></td></tr></table></figure><br>使用示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::ServiceClient client = nh.serviceClient&lt;ServiceCommunication::</span><br><span class="line">AddInts&gt;(&quot;AddInts&quot;);</span><br></pre></td></tr></table></figure><br>泛型：Service 服务中消息的类型格式<br>参数列表：service_name 服务的名称<br>返回值：调用成功时，会返回一个客户端对象ros::ServiceClient<br>2&gt;调用服务：调用客户端对象的call函数实现<br>template<class Service>bool call(Service&amp; service)<br>使用示例：turtlesim::Spawn spawn;<br>bool flag = client.call(spawn);<br>泛型：Service 调用服务的消息service的类型格式<br>参数列表：service调用服务的消息，需要与服务中消息的类型格式一致<br>返回值：调用成功时返回True，否则返回False<br>3&gt;等待服务函数：使用ros::service或ros::ServiceClient<br>使用示例：ros::service::waitForService(“/spawn”);<br>client.waitForExistence();<br>3.回旋函数API：<br>ROS中使用了 ros::spin() 和 ros::spinOnce() 两个回旋函数用于处理回调函数。<br>回调函数是一个在特定事件或条件发生时被调用的函数。它的主要目的是允许软件组件之间进行异步通信，即一个组件可以在某个特定事件发生时通知另一个组件，<br>回调函数通常作为参数传递给另一个函数，以便在需要时被调用。这个被传递的函数通常被称为回调函数，而调用回调函数的函数则被称为调用方。回调函数的一个关键特点是它们通常在编写代码时被定义，但在稍后的某个时间点被调用。这种延迟调用的特性使得回调函数在异步编程和事件驱动编程中非常有用。<br>ros::spin() 和 ros::spinOnce()二者都用于处理回调函数，但ros::spin()会循环执行回调函数，而 ros::spinOnce() 只会执行一次回调函数，在 ros::spin() 后的语句不会执行到，而 ros::spinOnce() 后的语句可以执行。<br>4.时间API：<br>ROS中时间相关的API极其常用，比如获取当前时刻、持续时间的设置、执行频率、休眠、定时器等都与时间相关。<br>①初始化节点ros::init并创建句柄ros::NodeHandle：<br>调用时间API前必须初始化节点并创建句柄，否则时间无法初始化导致后续API调用失败<br>ros::init(argc,argv,”RosTime”);<br>ros::NodeHandle nh;<br>②得到时刻对象：ros::Time是时刻对象，其中封装了很多内容而不单单是一个时刻值，使用ros::Time::now()获取当前时刻的对象：ros::Time right_now = ros::Time::now();<br>或是使用初始化函数设置一个时刻对象，传入参数为要设置的时刻值，例如：<br>ros::Time someTime(100.3);<br>值得注意的是，当前时刻的表示为时间戳，即离1970.1.1 00:00:00的秒数<br>③获取时间间隔对象：ros::Duration是时间间隔对象，其中也封装了很多内容。<br>可以使用初始化函数设置一个时间间隔对象，传入参数为要设置的时间间隔值，例如：<br>ros::Duration du(10);<br>④获取当前的时刻值：使用ros::Time对象的toSec()方法，例如：<br>someTime.toSec()    //double类型，可以打印得到其值为100.3<br>⑤休眠相当于时间间隔对象值的时间：使用ros::Duration对象的sleep()方法，例如：<br>du.sleep();    //相当于使程序休眠10s再继续执行接下来的内容<br>⑥时间间隔对象和时刻对象可以进行相加减，其中两个时刻对象只能相减，其返回值仍为一时刻对象；而两个时间间隔对象可以任意相加减，其返回值仍为一时间间隔对象；值得注意的是，时间间隔对象和时刻对象之间也可以任意相加减，而其返回值为一时刻对象。<br>⑦设置运行频率：使用ros::Rate对象的sleep方法实现<br>ros::Rate rate(10);    //初始化ros::Rate对象，指定频率为10Hz<br>while (true)<br>{<br>ROS_INFO(“——————-“);<br>rate.sleep();    //休眠，休眠时间为0.1s，变相即设置运行频率为10H<br>}<br>⑧定时器：ROS 中内置了专门的定时器ros::Timer，可以实现与 ros::Rate类似的效果<br>Timer createTimer(Duration period, const TimerCallback&amp; callback, bool oneshot = false,bool autostart = true) const;<br>使用示例：ros::Timer timer = nh.createTimer(ros::Duration(0.5),doSomeThing);<br>void doSomeThing(const ros::TimerEvent &amp;event){<br>      ROS_INFO(“event:%s”,std::to_string(event.current_real.toSec()).c_str());<br>}</p><p>参数列表：period 时间间隔对象，表示定时器的时间间隔<br>callback 回调，当定时器的时间间隔完成后调用，输入为时间事件TimerEvent<br>oneshot 如果设置为 true,只执行一次回调函数，设置为 false,就循环执行。<br>autostart 如果为true，返回已经启动的定时器,设置为 false，需要手动启动，<br>即在代码对应的启动位置调用ros::Timer的start()方法，例如timer.start()<br>由于回调函数的存在， ros::spin()显然也是要添加的<br>5.关闭节点API：使用ros::shutdown()实现<br>除了代码实现，当节点接收到了关闭信息(ctrl + c等)或同名节点启动也会导致节点关闭<br>6.日志输出API：除了ROS_INFO之外，还有以下几种日志输出API<br>ROS_DEBUG(“hello,DEBUG”); //调试信息，不会输出到控制台<br>ROS_INFO(“hello,INFO”);     //标准消息，说明系统内正在执行的操作，白色字体<br>ROS_WARN(“Hello,WARN”);  //警告信息，程序存在异常但仍然可以执行，黄色字体<br>ROS_ERROR(“hello,ERROR”); //错误信息，此类错误会影响程序运行，红色字体<br>ROS_FATAL(“hello,FATAL”);   //严重错误，此类错误将阻止节点继续运行，红色字体</p><h1 id="自定义头文件、源文件和可执行文件的调用："><a href="#自定义头文件、源文件和可执行文件的调用：" class="headerlink" title="自定义头文件、源文件和可执行文件的调用："></a>自定义头文件、源文件和可执行文件的调用：</h1><p>当功能包由头文件和源文件组成，其中源文件和可执行文件为同一文件时，为了使源文件定义头文件的声明，需要包含头文件，格式为#include “../include/包名/头文件.h”。为了包含头文件时不抛出异常，可以配置.vscode 下 c_cpp_properties.json 的 includepath属性加上”/home/用户/工作空间/src/功能包/include/**”，可以通过pwd得到。<br>此时.h和.cpp的编写不做赘述，主要看一下CMakeLists.txt的配置：<br>为了完成头文件的配置，需要把L119的注释去掉：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">include</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>源文件的配置仍然不变，即add_executable,add_dependencies,target_link_libraries<br>当功能包由头文件、源文件和可执行文件共同组成时（即源文件只进行对头文件声明的定义，可执行文件才是程序入口），在CMakeLists.txt的配置上又有所不同：<br>为了完成头文件的配置，需要把L119的注释去掉：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">include</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>为了完成头文件和源文件的联立配置，需要声明一套C++库：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_library(库名</span><br><span class="line">  include/包名/头文件.h</span><br><span class="line">  src/源文件.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>接着将这个新声明的自定义库添加依赖和链接库：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_dependencies(库名 $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; </span><br><span class="line">$&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line">target_link_libraries(库名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>最后是可执行文件，仍为add_executable,add_dependencies,target_link_libraries<br>不同点在于配置链接库时需要添加之前新声明的自定义库：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(use_head</span><br><span class="line">  库名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="ROS元功能包："><a href="#ROS元功能包：" class="headerlink" title="ROS元功能包："></a>ROS元功能包：</h1><p>完成ROS中一个系统性的功能可能涉及到多个功能包，比如机器人导航模块下有地图、定位、路径规划等不同的子级功能包。为此，ROS中提供了一种方式可以将不同的功能包打包成一个具有相同工作目标的功能包集合，这个集合就是元功能包(metapackage)。<br>元功能包是ROS中的一个虚包，里面没有实质性的内容，但是它依赖了其他的软件包，通过这种方法可以把其他包组合起来，我们可以认为它是一本书的目录索引，告诉我们这个包集合中有哪些子包。<br>创建ROS元功能包的方法如下：<br>首先新建一个包，作为虚包，只需要包名而不需要依赖(roscpp rospy std_msgs)<br>然后:修改package.xml ,内容如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;exec_depend&gt;被集成的功能包&lt;/exec_depend&gt;</span><br><span class="line">.....</span><br><span class="line">&lt;export&gt;</span><br><span class="line">  &lt;metapackage /&gt;</span><br><span class="line">&lt;/export&gt;</span><br></pre></td></tr></table></figure><br>最后:修改 CMakeLists.txt,内容如下:<br>cmake_minimum_required(VERSION 3.0.2)<br>project(xxx)<br>find_package(catkin REQUIRED)<br>catkin_metapackage()<br>注意，所有的其他东西包括注释全都不要，只留这四行</p><h1 id="Launch文件的使用："><a href="#Launch文件的使用：" class="headerlink" title="Launch文件的使用："></a>Launch文件的使用：</h1><p>一个程序中可能需要启动多个节点，比如ROS内置的小乌龟案例，如果要控制乌龟运动，要启动roscore、乌龟界面节点、键盘控制节点。如果每次都调用 rosrun 逐一启动，显然效率低下，采用的优化策略便是使用roslaunch 命令集合 launch 文件启动管理节点。并且在后续教程中，也多次使用到了 launch 文件。<br>launch 文件是一个 XML 格式的文件，可以启动本地和远程的多个节点，还可以在参数服务器中设置参数，它可以简化节点的配置与启动，从而提高ROS程序的启动效率。<br>0.XML文件的基本格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">一个XML文档由一个或多个元素构成，一个元素又可以包含属性和内容两部分。元素是XML文档的基本结构单元，由开始标签和结束标签组成。元素可以包含子元素，也可以包含内容。开始标签用&lt;xxx&gt;表示，结束标签为开始标签加/组成&lt;/xxx&gt;。例如&lt;element&gt;数据&lt;/element&gt;，其中数据就是element元素的内容或子元素。</span><br><span class="line">元素也可以包含属性，属性用于提供关于元素的附加信息。属性出现在元素的开始标签中，位于元素名称之后，以等号（=）分隔属性名称和属性值。例如：&lt;element 属性名=&quot;属性值&quot;&gt;数据&lt;/element&gt;。如果一个元素在定义时不包含任何文本内容或其他子元素，则称其为自闭合元素，此时可以将语句简化为&lt;element 数据 /&gt; 。</span><br><span class="line">1.以 turtlesim 为例演示Launch文件的使用方法：</span><br><span class="line">1&gt;新建launch文件</span><br><span class="line">在功能包下添加 launch目录, 目录下新建 xxxx.launch 文件，编辑 launch 文件</span><br><span class="line">&lt;launch&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;myTurtle&quot; </span><br><span class="line">output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot;</span><br><span class="line">name=&quot;myTurtleContro&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br><span class="line">2&gt;调用 launch 文件</span><br><span class="line">roslaunch 包名 xxx.launch</span><br><span class="line">注意:roslaunch 命令执行launch文件时会自动启动roscore</span><br><span class="line">2.launch标签：</span><br><span class="line">&lt;launch&gt;标签是所有launch文件的根标签，充当其他标签的容器</span><br><span class="line">属性：deprecated = &quot;弃用声明&quot;，告知用户当前 launch 文件已经弃用</span><br><span class="line">子标签：所有其它标签都是launch的子标签</span><br><span class="line">示例：&lt;launch deprecated=”此文件已被弃用”&gt;</span><br><span class="line">&lt;node...&gt;</span><br><span class="line">&lt;/launch&gt;</span><br><span class="line">3.node标签：</span><br><span class="line">&lt;node&gt;标签用于指定ROS节点，但roslaunch命令不能保证按照node的声明顺序来启动节点，因为节点的启动是多进程的。</span><br><span class="line">属性：pkg=&quot;包名&quot;，确定节点所属的包名</span><br><span class="line">type=&quot;节点名&quot;，确定节点名(CMakeLists中定义的名称)</span><br><span class="line">name=&quot;节点称号”，确定节点称号(ros::init中定义的网络拓扑称号)</span><br><span class="line">output=&quot;log | screen&quot; (可选)，日志发送目标，可以设置为日志文件或屏幕</span><br><span class="line">args=&quot;xxx xxx xxx&quot; (可选)，将参数传递给节点，中间用空格分隔</span><br><span class="line">machine=&quot;机器名&quot;，在指定机器上启动节点</span><br><span class="line">respawn=&quot;true | false&quot; (可选)，如果节点意外退出，是否自动重启</span><br><span class="line">respawn_delay=&quot; N&quot; (可选)，如果respawn=true, 那么延迟 N 秒后启动节点</span><br><span class="line">required=&quot;true | false&quot; (可选)，该节点是否必须，如果为true,那么如果该节点  退出，将杀死整个roslaunch</span><br><span class="line">ns=&quot;xxx&quot; (可选)，在指定命名空间xxx中启动节点，此时如果使用rosnode list  查看的话，该节点的路径将会变为/xxx/节点名</span><br><span class="line">子标签：remap 重映射节点名称</span><br><span class="line">rosparam 参数设置</span><br><span class="line">param 参数设置</span><br><span class="line">示例：&lt;launch&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;myTurtle&quot; </span><br><span class="line">output=&quot;screen&quot; /&gt;</span><br><span class="line">  &lt;/launch&gt;</span><br><span class="line">4.include标签：</span><br><span class="line">如果不同的launch文件之间需要启动相同的节点，可以使用&lt;include&gt;标签将另一个xml格式的 launch 文件导入到当前文件，以此优化代码文件，实现代码复用，同时在当前文件下还可以在导入文件的基础上增加节点。</span><br><span class="line">属性：file=&quot;$(find 包名)/xxx(通常为launch)/xxx.launch&quot;，要包含的文件路径</span><br><span class="line">ns=&quot;xxx&quot; (可选)，在指定命名空间导入文件</span><br><span class="line">子标签：arg将参数传递给被包含的文件</span><br><span class="line">示例：&lt;launch&gt;</span><br><span class="line">&lt;include file=&quot;$(find launch01_basic)launch/StartTurtle.launch&quot; /&gt;</span><br><span class="line">  &lt;/launch&gt;</span><br><span class="line">5.remap标签：</span><br><span class="line">用于话题重命名，以此改变节点订阅的话题</span><br><span class="line">属性：from=&quot;xxx&quot;，原始话题名称</span><br><span class="line">to=&quot;yyy&quot;，目标话题名称</span><br><span class="line">子标签：无</span><br><span class="line">示例：&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">&lt;remap from=&quot;/turtle1/cmd_vel&quot; to=&quot;/cmd_vel&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line">6.param标签：</span><br><span class="line">&lt;param&gt;标签主要用于在参数服务器上设置参数，参数源可以在标签中通过 value 指定，也可以通过外部文件加载。&lt;param&gt;标签可以放在&lt;launch&gt;下在可以放在&lt;node&gt;下，&lt;launch&gt;下相当于公有参数，&lt;node&gt;下相当于节点的私有参数。</span><br><span class="line">可以使用rosparam list查看设置的变量及其所在的位置。</span><br><span class="line">属性：name=&quot;命名空间/参数名&quot;，参数名称，可以包含命名空间</span><br><span class="line">value=&quot;xxx&quot; ，定义参数值</span><br><span class="line">type=&quot;str | int | double | bool&quot;，指定参数类型</span><br><span class="line">子标签：无</span><br><span class="line">示例：&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot;   output=&quot;screen&quot;&gt;</span><br><span class="line">&lt;param name=&quot;ParamB&quot; type=&quot;double&quot; value=&quot;3.14&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line">7.rosparam标签：</span><br><span class="line">&lt;rosparam&gt;标签可以从YAML文件导入参数，或将参数导出到 YAML文件，也可以用来删除参数，同样，&lt;rosparam&gt;也可以放在&lt;launch&gt;或者&lt;node&gt;下。</span><br><span class="line">YAML是一种数据序列化格式，用来确定数据组、名称及其对应的值。它使用缩进表示层级，</span><br><span class="line">由键值对组成数据，键和值之间以冒号分隔，且冒号后面必须有一个空格。</span><br><span class="line">属性：command=&quot;load | dump | delete&quot;，加载、导出或删除参数</span><br><span class="line">file=&quot;$(find 包名)/xxx/yyy....&quot;，加载或导出到的 yaml 文件，加载导出用</span><br><span class="line">需要注意的是，导出文件需要和调用文件分开，否则无法保证参数均被存储</span><br><span class="line">param=&quot;参数名称&quot;，删除参数用</span><br><span class="line">ns=&quot;命名空间&quot; (可选)</span><br><span class="line">子标签：无</span><br><span class="line">示例：</span><br><span class="line">&lt;rosparam command=&quot;load&quot; file=&quot;$(find RosLaunch)/launch/params.yaml&quot; /&gt;</span><br><span class="line">&lt;rosparam command=&quot;dump&quot; file=&quot;$(find RosLaunch)/launch/param.yaml&quot;/&gt;</span><br><span class="line">&lt;rosparam command=&quot;delete&quot; param=”bg_B”/&gt;</span><br><span class="line">8.group标签：</span><br><span class="line">&lt;group&gt;标签可以对节点分组，具有 ns 属性，可以让节点归属某个命名空间，从而实现节点的聚类。此外，将同名节点归于不同的命名空间可以避免重名问题。</span><br><span class="line">通过rosnode list可以发现同名节点之前附加上了命名空间路径从而实现区分。</span><br><span class="line">属性：ns=&quot;名称空间&quot; (可选)</span><br><span class="line">子标签：除了launch 标签外的其他标签</span><br><span class="line">示例：&lt;group ns=&quot;first&quot;&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot;    output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;/group&gt;</span><br><span class="line">9.arg标签：</span><br><span class="line">&lt;arg&gt;标签是用于动态传参，类似于函数的参数，可以增强launch文件的灵活性</span><br><span class="line">属性：name=&quot;参数名称&quot;，在launch文件中可以使用$(arg name)表示对应的参数值</span><br><span class="line">default=&quot;默认值&quot;，不传参时的参数默认值</span><br><span class="line">子标签：无</span><br><span class="line">传参方法：在roslaunch语句后添加键值对roslaunch 包名 xxx.launch yyy:=值</span><br><span class="line">示例：&lt;arg name=&quot;test&quot; default=”0.5” /&gt;</span><br><span class="line">      &lt;param name=&quot;param&quot; value=&quot;$(arg test)&quot; /&gt;</span><br><span class="line">  roslaunch RosLaunch arg.launch car_length:=0.6</span><br></pre></td></tr></table></figure></p><h1 id="重名问题："><a href="#重名问题：" class="headerlink" title="重名问题："></a>重名问题：</h1><p>1.功能包重名：<br> 虽然特定工作空间内的功能包不能重名，但是自定义工作空间的功能包与内置的功能包可以重名或者不同的自定义的工作空间中也可以出现重名的功能包，那么调用该名称功能包时，会调用哪一个呢？比如：自定义工作空间A存在功能包 turtlesim，自定义工作空间B也存在功能包 turtlesim，当然系统内置空间也存在turtlesim，如果调用turtlesim包，会调用哪个工作空间中的呢？<br>ROS会将当前启用的所有工作空间存放在环境变量ROS_PACKAGE_PATH中，通过查看echo $ROS_PACKAGE_PATH可以得到一个工作空间顺序，当不同工作空间的功能包重名时，会按照 ROS_PACKAGE_PATH 查找，并优先执行顺序在前的工作空间下的功能包，这被称为ROS的工作空间覆盖。<br>工作空间覆盖问题显然存在安全隐患，比如当前工作空间B优先级更高，意味着当程序调用 turtlesim 时，不会调用工作空间A也不会调用系统内置的 turtlesim，如果工作空间A在实现时有其他功能包依赖于自身的 turtlesim，而按照ROS工作空间覆盖的涉及原则，那么实际执行时将会调用工作空间B的turtlesim，从而导致执行异常。<br>ROS对于功能包重名暂无解决方法，故应选择主动避免。<br>2.节点重名：<br>在ROS中如果启动重名节点的话，之前已经存在的节点会被直接关闭，但是如果确实有这种需求，ROS提供了使用命名空间或名称重映射（起别名）的解决方法。要实现这两种解决办法还各有三种实现途径，分别是使用rosrun命令，修改launch文件或编码实现。<br>①使用rosrun命令：<br>1&gt;使用命名空间：rosrun 包名 同名节点 <strong>ns:=工作空间<br>2&gt;名称重映射:rosrun 包名 同名节点 </strong>name:=别名<br>3&gt;上述两种方法可以叠加：rosrun 包名 同名节点 <strong>ns:=工作空间 </strong>name:=别名<br>4&gt;观察修正结果：使用rosnode list，使用命名空间会在节点前加前缀，使用名称重映射则会直接将节点改名。<br>②修改launch文件：<br>介绍launch文件的使用语法时曾经讲过，在node标签中有name和ns两个属性，二者分别用于实现节点名称重映射与设置命名空间。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&gt;使用命名空间：&lt;node pkg=&quot;包名&quot; type=&quot;同名节点&quot; ns=&quot;工作空间&quot;/&gt;</span><br><span class="line">2&gt;名称重映射：&lt;node pkg=&quot;包名&quot; type=&quot;同名节点&quot; name=&quot;别名&quot; /&gt;</span><br><span class="line">3&gt;叠加：&lt;node pkg=&quot;包名&quot; type=&quot;同名节点&quot; name=&quot;别名&quot; ns=&quot;工作空间&quot;/&gt;</span><br></pre></td></tr></table></figure><br>③编码实现：<br>1&gt;使用命名空间：在代码初始化ROS节点时补充设置为节点添加时间戳后缀<br>ros::init(argc,argv,”xxx”,ros::init_options::AnonymousName);<br>3.话题重名：<br>ROS不同的节点之间通信都依赖于话题，话题名称也可能出现重复的情况。这种情况下，系统虽然不会抛出异常，但是可能导致订阅的消息非预期的，从而导致节点运行异常。这种情况下需要将两个节点的话题名称由相同修改为不同。<br>又或者，两个节点的话题名称虽然相同，但位于不同的工作空间下导致通信失败。这种情况下需要将两个节点的话题名称由不同修改为相同。<br>其解决方法仍然是话题名称重映射或为名称添加前缀。特殊的，对于话题而言，为名称添加前缀有全局、相对和私有三种方法。使用rostopic list查看话题，其中全局话题表示为/话题名，相对话题表示为/命名空间/话题名，私有话题表示为/命名空间/节点名/话题名<br>①使用rosrun命令：rosrun 包名 节点名 原话题名:=新话题名</p><p>②修改launch文件：使用node节点的remap属性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=”包名” type=”节点名” name=&quot;xxx&quot;&gt;</span><br><span class="line">    &lt;remap from=&quot;原话题名&quot; to=&quot;新话题名&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br></pre></td></tr></table></figure><br>③编码实现：<br>1&gt;全局话题：话题名以/开头，此时话题全名和节点名称无关<br>例如ros::Publisher pub = nh.advertise<std_msgs::String>(“/chatter”,1000);<br>此时话题全名为/chatter<br>2&gt;相对话题：话题名以非/开头，此时话题全名位于节点所在工作空间下与节点平齐<br>例如ros::Publisher pub = nh.advertise<std_msgs::String>(“chatter”,1000);<br>此时话题全名为/节点所处的工作空间名/chatter<br>2&gt;私有话题：节点句柄添加”~”元素时以非/开头的话题名<br>例如：ros::NodeHandle nh(“~”);<br>ros::Publisher pub = nh.advertise<std_msgs::String>(“chatter”,1000);<br>  此时话题全名为/节点所处的工作空间名/节点名/chatter<br>4.参数名称重名：<br>同理在ROS中参数名称也可能重名。关于参数重名的处理没有重映射实现，为了尽量的避免参数重名，都是使用为参数名添加前缀的方式，实现类似于话题名称，有全局、相对和私有三种类型之分。<br>①使用rosrun命令： rosrun 包名 节点名 _参数名:=参数值<br>值得注意的是，rosrun执行设置参数参数名使用的是私有类型。<br>②修改launch文件：在node标签外或内通过param标签来设置参数。在node标签外设置的参数是全局性质的，参数全名是/参数名，在node标签中设置的参数是私有性质的，参数全名是/命名空间/节点名称/参数名。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;param name=&quot;p1&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;&gt;</span><br><span class="line">  &lt;param name=&quot;p2&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br></pre></td></tr></table></figure><br>此时参数全名分别是 /p1和 /xxx/p2<br>③编码实现：<br>1&gt;全局变量：变量名以/开头，此时变量全名和节点名称无关<br>例如：ros::param::set(“/set_A”,100);<br>此时话题全名为/set_A<br>2&gt;相对变量：变量名以非/开头，此时变量全名位于节点所在工作空间下与节点平齐<br>例如：ros::param::set(“set_B”,100);<br>此时话题全名为/节点所处的工作空间名/set_B<br>3&gt;私有变量：变量名以~开头，此时变量全名位于节点下<br>例如：ros::param::set(“~set_C”,100);<br>  此时话题全名为/节点所处的工作空间名/节点名/set_C</p><h1 id="分布式通信："><a href="#分布式通信：" class="headerlink" title="分布式通信："></a>分布式通信：</h1><p>一个运行中的ROS系统可以包含分布在多台计算机上多个节点。如果要实现不同计算机间不同节点的通信，我们需要进行以下几步：<br>1.保证不同计算机处于同一网络中，最好分别设置固定IP。<br>2.配置文件修改：<br>分别修改不同计算机的 /etc/hosts 文件，在该文件中加入对方的IP地址和计算机名:<br>主机端:从机的IP    从机计算机名；从机端:主机的IP    主机计算机名<br>设置完毕，可以通过 ping 命令测试网络通信是否正常。<br>注：IP地址查看: ifconfig / 计算机名称查看: hostname<br>3.配置主机IP：向~/.bashrc中追加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ROS_MASTER_URI=http://主机IP:11311</span><br><span class="line">export ROS_HOSTNAME=主机IPCopy</span><br></pre></td></tr></table></figure><br>4.配置从机IP：向~/.bashrc中追加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ROS_MASTER_URI=http://主机IP:11311</span><br><span class="line">export ROS_HOSTNAME=从机IPCopy</span><br></pre></td></tr></table></figure><br>5.测试方法：主机启动roscore，而后双方分别启动节点测试通信是否正常即可</p><h1 id="ROS坐标变换TF："><a href="#ROS坐标变换TF：" class="headerlink" title="ROS坐标变换TF："></a>ROS坐标变换TF：</h1><p>机器人系统上，有多个传感器，如激光雷达、摄像头等，有的传感器是可以感知机器人周边的物体方位的，以协助机器人定位障碍物。可以直接将物体相对该传感器的方位信息，等价于物体相对于机器人系统或机器人其它组件的方位信息吗？显示是不行的，这中间需要一个转换过程，为此ROS提供了坐标变换模块TF来实现这个功能。<br>1.先介绍一下四元数的概念，四元数是由实部和虚部组成的扩展复数，一个四元数可以表示为 q = w + xi + yj + zk，其中 w 是实部，(x, y, z) 是虚部对应的旋转轴上的分量。通过四元数可以方便地表示旋转操作，一个四元数 q 可以表示为 q = cos(θ/2) + u <em> sin(θ/2)，其中 θ 是旋转角度，u 是单位旋转轴向量。例如，对于绕以 (1, 0, 0) 为轴，角度为 π/2 的旋转操作，可以构建四元数 q = cos(π/4) + i </em> sin(π/4)。四元数本身可以克服欧拉角带来的万向死锁问题。<br>2.ROS的坐标变化基于订阅发布模型，其对应的msg有：<br>geometry_msgs/TransformStamped和geometry_msgs/PointStamped<br>其中前者用于传输坐标系间的相对位置信息，后者用于传输某个坐标系内坐标点相对于原点的信息。在坐标变换中，频繁的需要使用到坐标系的相对关系以及坐标点信息。<br>1&gt;geometry_msgs/TransformStamped（坐标系间的相对位置信息）：<br>利用rosmsg info geometry_msgs/TransformStamped可以查看其包含以下内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header                  //头信息</span><br><span class="line">  uint32 seq                                //序列号</span><br><span class="line">  time stamp                                //时间戳</span><br><span class="line">  string frame_id                           //父坐标ID（创建）</span><br><span class="line">string child_frame_id                    //子坐标ID（创建）</span><br><span class="line">geometry_msgs/Transform transform       //父子坐标的相对位置信息</span><br><span class="line">  geometry_msgs/Vector3 translation        //子坐标相对于父坐标间的偏移</span><br><span class="line">    float64 x                                //X方向</span><br><span class="line">    float64 y                                //Y方向</span><br><span class="line">    float64 z                                //Z方向</span><br><span class="line">  geometry_msgs/Quaternion rotation        //子坐标相对于父坐标间的旋转</span><br><span class="line">    float64 x                                //用四元数表示</span><br><span class="line">    float64 y                                </span><br><span class="line">    float64 z                                </span><br><span class="line">    float64 w</span><br></pre></td></tr></table></figure><br>2&gt;geometry_msgs/PointStamped（坐标点相对于原点的信息）：<br>利用rosmsg info geometry_msgs/PointStamped可以查看其包含以下内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header               //头信息</span><br><span class="line">  uint32 seq                               //序列号</span><br><span class="line">  time stamp                                //时间戳</span><br><span class="line">  string frame_id                            //所属坐标系的ID（查询）</span><br><span class="line">geometry_msgs/Point point                //坐标点相对于原点的偏移</span><br><span class="line">  float64 x                                //X方向</span><br><span class="line">  float64 y//Y方向</span><br><span class="line">  float64 z//Z方向</span><br></pre></td></tr></table></figure><br>3.静态坐标变换（两个坐标系之间的相对位置固定）：<br>发布与订阅关系：坐标系的相对关系通过发布方发布，订阅方订阅发布的坐标系相对关系，再传入坐标点信息，然后借助于tf实现坐标变换，并将结果输出。<br>代码实现：<br>①创建项目功能包：<br>包括tf2 tf2_ros tf2_geometry_msgs roscpp rospy std_msgs geometry_msgs<br>②发布方实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;tf2_ros/static_transform_broadcaster.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/TransformStamped.h&quot;</span><br><span class="line">#include &quot;tf2/LinearMath/Quaternion.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;StaticTfPublisher&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建发布者对象</span><br><span class="line">tf2_ros::StaticTransformBroadcaster pub;</span><br><span class="line">// 组织被发布的消息：父子坐标系及其相对关系</span><br><span class="line">geometry_msgs::TransformStamped tfs;</span><br><span class="line">tfs.header.stamp = ros::Time::now();</span><br><span class="line">tfs.header.frame_id = &quot;base_link&quot;;</span><br><span class="line">tfs.child_frame_id = &quot;laser&quot;;</span><br><span class="line">tfs.transform.translation.x = 0.2;</span><br><span class="line">tfs.transform.translation.y = 0.0;</span><br><span class="line">tfs.transform.translation.z = 0.5;</span><br><span class="line">// 将欧拉角变为四元数</span><br><span class="line">tf2::Quaternion qtn;</span><br><span class="line">qtn.setRPY(0, 0, 0);</span><br><span class="line">tfs.transform.rotation.x = qtn.getX();</span><br><span class="line">tfs.transform.rotation.y = qtn.getY();</span><br><span class="line">tfs.transform.rotation.z = qtn.getZ();</span><br><span class="line">tfs.transform.rotation.w = qtn.getW();</span><br><span class="line">// 发布数据</span><br><span class="line">pub.sendTransform(tfs);</span><br><span class="line">// spin()回调</span><br><span class="line">ros::spin();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">③订阅方实现：</span><br><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;tf2_ros/transform_listener.h&quot;</span><br><span class="line">#include &quot;tf2_ros/buffer.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/PointStamped.h&quot;</span><br><span class="line">#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;StaticTfSubscriber&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建buffer和坐标变换监听对象，用于存储订阅得到的数据</span><br><span class="line">tf2_ros::Buffer buffer;</span><br><span class="line">tf2_ros::TransformListener listener(buffer);</span><br><span class="line">// 组织一个PointStamped对象表示在laser坐标系下的坐标</span><br><span class="line">geometry_msgs::PointStamped ps;</span><br><span class="line">ps.header.frame_id = &quot;laser&quot;;</span><br><span class="line">ps.header.stamp = ros::Time::now();</span><br><span class="line">ps.point.x = 2.0;</span><br><span class="line">ps.point.y = 3.0;</span><br><span class="line">ps.point.z = 5.0;</span><br><span class="line">ros::Rate rate(10);</span><br><span class="line">while (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">//try-catch避免缓存接收延迟而导致坐标转换失败</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">// 组织一个PointStamped对象表示在base_link坐标系下的坐标</span><br><span class="line">geometry_msgs::PointStamped ps_out;</span><br><span class="line">ps_out = buffer.transform(ps, &quot;base_link&quot;);</span><br><span class="line">// 得到结果并输出</span><br><span class="line">ROS_INFO(&quot;TF according to %s is:(%2f,%2f,%2f)&quot;,</span><br><span class="line">ps_out.header.frame_id.c_str(),</span><br><span class="line">ps_out.point.x,</span><br><span class="line">ps_out.point.y,</span><br><span class="line">ps_out.point.z);</span><br><span class="line">&#125;</span><br><span class="line">catch (const std::exception &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;Error:%s&quot;, e.what());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rate.sleep();</span><br><span class="line">ros::spinOnce();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>④总结：<br>可以看到此时发布方发布坐标间的相对位置关系，订阅方借助自身得到的以某一坐标系为基准的坐标值去订阅话题以实现TF坐标转换到另一坐标系为基准的坐标值。<br>⑤补充：<br>1&gt;ROS本身封装了专门的节点用于实现静态坐标系相对关系信息的发布，借助命令：<br>rosrun tf2_ros static_transform_publisher x偏移量 y偏移量 z偏移量 偏航角度 俯仰角度 翻滚角度 父级坐标系 子级坐标系<br>可以实现发布方代码的全流程，即发布父子坐标系的名字以及之间的相对关系<br>2&gt;可以借助于rviz来实现以图形化的形式显示坐标系关系，具体操作如下：<br>输入命令rviz后设置Fixed Frame为base_link;<br>点击左下的 add 按钮，在弹出的窗口中选择 TF 组件，即可显示坐标关系。<br>3&gt;使用rosrun tf2_tools view_frames.py可以生成坐标系树状关系结构的pdf<br>4.动态坐标变换（两个坐标系之间的相对位置不再固定）：<br>以turtlesim为例，该节点中窗体有一个世界坐标系(左下角为坐标系原点)，而乌龟本身为另一个坐标系，由于乌龟是可以运动的，所以世界坐标系与乌龟坐标系之间的相对位置不固定。假设有一个点相对于乌龟坐标系的值已知，那么把该点转换为世界坐标系的过程就是动态坐标变换。订阅 turtle1/pose,可以获取乌龟在世界坐标系的 x坐标、y坐标、偏移量以及线速度和角速度。<br>代码实现：<br>①创建项目功能包：<br>包括tf2 tf2_ros tf2_geometry_msgs roscpp rospy std_msgs geometry_msgs<br>②发布方实现：<br>void doPose(const turtlesim::Pose::ConstPtr &amp;pose)<br>{<br>static tf2_ros::TransformBroadcaster pub;<br>geometry_msgs::TransformStamped ts;<br>ts.header.frame_id = “world”;<br>ts.header.stamp = ros::Time::now();<br>ts.child_frame_id = “turtle1”;<br>ts.transform.translation.x = pose-&gt;x;<br>ts.transform.translation.y = pose-&gt;y;<br>ts.transform.translation.z = 0;<br>tf2::Quaternion qtn;<br>qtn.setRPY(0, 0, pose-&gt;theta);<br>ts.transform.rotation.x = qtn.getX();<br>ts.transform.rotation.y = qtn.getY();<br>ts.transform.rotation.z = qtn.getZ();<br>ts.transform.rotation.w = qtn.getW();<br>pub.sendTransform(ts);<br>}</p><p>int main(int argc, char *argv[])<br>{<br>// 初始化节点和节点句柄<br>ros::init(argc, argv, “DynamicTfPublisher”);<br>ros::NodeHandle nh;<br>// 订阅发布乌龟位姿的节点，以此得到动态坐标系（乌龟坐标系）的实时位置<br>// 然后在回调函数里利用TransformStamped发布两坐标系间的相对关系<br>ros::Subscriber sub = nh.subscribe(“/turtle1/pose”, 100, doPose);<br>ros::spin();<br>return 0;<br>}<br>③订阅方实现：<br>无论是静态坐标系还是动态坐标系，某一坐标系下的坐标点相对坐标原点的关系总是一样的，因而动态坐标系的订阅方实现与静态坐标系几乎没有不同，只需要把父子坐标系的名字改成需要考虑的即可。唯一值得注意的是此时组织的PointStamped对象的时间戳stamp不应该是ros::Time::now()而应该是ros::Time(0.0)，原因在于ROS会检验动态坐标系发布的时间戳和某一点相对于某一坐标的时间戳的差值，如果两者有较大的差别则ROS会认为此时前者的值在后者看来已经过时了，也就是此时的坐标变化不准确而失去意义，因而ROS会抛出异常并不再处理。可以看到如果我们把发布方和订阅方的时间戳都设置为ros::Time::now()，发布和订阅之间所产生的时间差将导致ROS抛出异常。而将其设置为ros::Time(0.0)后ROS会认为该信息对时间不敏感，也就能输出正常的结果了。<br>④总结：<br>可以看到此时发布方先订阅了乌龟位姿节点以获取动态的乌龟坐标系值，而后再发布动态坐标间的相对位置关系，订阅方借助自身得到的以某一坐标系为基准的坐标值去订阅话题以实现TF坐标转换到另一坐标系为基准的坐标值。同样我们可以使用rviz可视化的看到坐标系间的关系，可以看到此时乌龟坐标系是会随着键盘节点命令而运动的。<br>5.多坐标变换：<br>现有坐标系统，父级坐标系统 world,下有两子级系统 son1，son2，son1 相对于 world，以及 son2 相对于 world 的关系是已知的，求 son1原点在 son2中的坐标，又已知在 son1中一点的坐标，要求求出该点在 son2 中的坐标。<br>代码实现：<br>①创建项目功能包：<br>包括tf2 tf2_ros tf2_geometry_msgs roscpp rospy std_msgs geometry_msgs<br>②发布方实现：直接使用launch文件调用静态坐标系中提到的专用节点来发布坐标关系<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;son1&quot; args=&quot;0.2 0.8 0.3 0 0 0 /world /son1&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;son2&quot; args=&quot;0.5 0 0 0 0 0 /world /son2&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><br>③订阅方实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;tf2_ros/transform_listener.h&quot;</span><br><span class="line">#include &quot;tf2_ros/buffer.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/PointStamped.h&quot;</span><br><span class="line">#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/TransformStamped.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;MultiTfSubscriber&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建buffer和坐标变换监听对象，用于存储订阅得到的数据</span><br><span class="line">tf2_ros::Buffer buffer;</span><br><span class="line">tf2_ros::TransformListener listener(buffer);</span><br><span class="line">// 组织一个PointStamped对象表示在son1坐标系下的坐标</span><br><span class="line">geometry_msgs::PointStamped ps_son1;</span><br><span class="line">ps_son1.header.frame_id = &quot;son1&quot;;</span><br><span class="line">ps_son1.header.stamp = ros::Time::now();</span><br><span class="line">ps_son1.point.x = 1.0;</span><br><span class="line">ps_son1.point.y = 2.0;</span><br><span class="line">ps_son1.point.z = 3.0;</span><br><span class="line">ros::Rate rate(10);</span><br><span class="line">while (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">// 坐标系的相对关系：son1相对于son2（son2为父坐标系，son1为子坐标系），ros::Time(0)表示取时间戳相差最近的两个值</span><br><span class="line">geometry_msgs::TransformStamped son1Toson2 = buffer.lookupTransform(&quot;son2&quot;, &quot;son1&quot;, ros::Time(0));</span><br><span class="line">ROS_INFO(&quot;Father:%s,Son:%s,Offset:(%2f,%2f,%2f)&quot;,</span><br><span class="line">son1Toson2.header.frame_id.c_str(),</span><br><span class="line">son1Toson2.child_frame_id.c_str(),</span><br><span class="line">son1Toson2.transform.translation.x,</span><br><span class="line">son1Toson2.transform.translation.y,</span><br><span class="line">son1Toson2.transform.translation.z);</span><br><span class="line">// 坐标点的关系：组织PointStamped对象表示在son2坐标系下的坐标</span><br><span class="line">geometry_msgs::PointStamped ps_son2 </span><br><span class="line">= buffer.transform(ps_son1, &quot;son2&quot;);</span><br><span class="line">ROS_INFO(&quot;The location transformed according to %s is:</span><br><span class="line">(%2f,%2f,%2f)&quot;,</span><br><span class="line">ps_son2.header.frame_id.c_str(),</span><br><span class="line">ps_son2.point.x,</span><br><span class="line">ps_son2.point.y,</span><br><span class="line">ps_son2.point.z);</span><br><span class="line">&#125;</span><br><span class="line">catch (const std::exception &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;Error:%s&quot;, e.what());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rate.sleep();</span><br><span class="line">ros::spinOnce();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>④总结：<br>首先发布方需要发布son1和son2相对于world的坐标消息，然后需要订阅坐标发布消息，借助于tf2实现son1和son2的转换，最后还要实现坐标点的转换。</p><h1 id="rosbag："><a href="#rosbag：" class="headerlink" title="rosbag："></a>rosbag：</h1><p>机器人传感器获取到的信息，有时我们可能需要时时处理，有时可能只是采集数据，事后分析，在ROS中关于数据的留存以及读取实现，提供了专门的工具rosbag，它实现了数据的复用，方便调试和测试。rosbag的本质也是一个ros节点，当录制时，rosbag是一个订阅节点，可以订阅话题消息并将订阅到的数据写入磁盘文件；当重放时，rosbag是一个发布节点，可以读取磁盘文件，发布文件中的话题消息。<br>①命令行实现：<br>1&gt;创建rosbag记录：rosbag record -a -O 目标文件路径及名称（建议以.bag作为后缀）<br>   其中-a表示all，即记录所有节点的数据变化；-O指output，即此时rosbag为输出<br>此时ROS便会开始记录所有节点的变化，当按下ctrl+C时终止并保存数据至.bag<br>2&gt;查看存在的rosbag信息：rosbag info 目标文件路径及名称<br>3&gt;读取并回放rosbag的数据：rosbag play 目标文件路径及名称<br>②代码实现：<br>1&gt;写入实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;rosbag/bag.h&quot;</span><br><span class="line">#include &quot;std_msgs/String.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;WriteBag&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建rosbag对象，可以打开，写入和关闭</span><br><span class="line">rosbag::Bag bag;</span><br><span class="line">bag.open(&quot;hello.bag&quot;, rosbag::BagMode::Write);</span><br><span class="line">std_msgs::String msg;</span><br><span class="line">msg.data = &quot;hello,rosbag!&quot;;</span><br><span class="line">// 写入操作用到的话题，时间戳和具体内容</span><br><span class="line">bag.write(&quot;/chatter&quot;, ros::Time::now(), msg);</span><br><span class="line">bag.write(&quot;/chatter&quot;, ros::Time::now(), msg);</span><br><span class="line">bag.write(&quot;/chatter&quot;, ros::Time::now(), msg);</span><br><span class="line">bag.write(&quot;/chatter&quot;, ros::Time::now(), msg);</span><br><span class="line">bag.close();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">2&gt;读出实现：</span><br><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;rosbag/bag.h&quot;</span><br><span class="line">#include &quot;rosbag/view.h&quot;</span><br><span class="line">#include &quot;std_msgs/String.h&quot;</span><br><span class="line">#include &quot;std_msgs/Int32.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;ReadBag&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建rosbag对象</span><br><span class="line">rosbag::Bag bag;</span><br><span class="line">bag.open(&quot;hello.bag&quot;, rosbag::BagMode::Read);</span><br><span class="line">// 读数据，rosbag::View以集合的方式返回一条消息，可以被迭代器迭代</span><br><span class="line">for (auto &amp;&amp;m : rosbag::View(bag))</span><br><span class="line">&#123;</span><br><span class="line">std::string topic = m.getTopic();</span><br><span class="line">ros::Time time = m.getTime();</span><br><span class="line">std_msgs::StringPtr p = m.instantiate&lt;std_msgs::String&gt;();</span><br><span class="line">if (p != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;Topic:%s,Stamp:%.2f,Message:%s&quot;,</span><br><span class="line">topic.c_str(),</span><br><span class="line">time.toSec(),</span><br><span class="line">p-&gt;data.c_str());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bag.close();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3&gt;结果：读出文件会输出写入文件的内容</p><h1 id="RQT工具箱："><a href="#RQT工具箱：" class="headerlink" title="RQT工具箱："></a>RQT工具箱：</h1><p>之前，在 ROS 中使用了一些实用的工具,比如: ros_bag 用于录制与回放、tf2_tools 可以生成 TF 树 ….. 这些工具大大提高了开发的便利性，但是也存在一些问题: 这些工具的启动和使用过程中涉及到一些命令操作，应用起来不够方便，在ROS中，提供了rqt工具箱，在调用工具时以图形化操作代替了命令操作，应用更便利，提高了操作效率。<br>呼出RQT工具箱：键入命令rqt<br>使用rqt提供的相关功能：既可以直接键入子命令（例如rqt_graph等），也可以在rqt的plugins中选择对应的功能。</p><h1 id="机器人系统仿真："><a href="#机器人系统仿真：" class="headerlink" title="机器人系统仿真："></a>机器人系统仿真：</h1><p>ROS中提供了系统的机器人仿真实现，通过仿真，可以实现大部分需求。利用ROS仿真，我们可以学会创建并显示机器人模型，搭建仿真环境，实现机器人模型与仿真环境的交互。<br>机器人的仿真涉及三个模块，URDF、Rviz和Gazebo。<br>1.模块简介：<br>①URDF：URDF是Unified Robot Description Format的缩写，直译为统一机器人描述格式，是一种可以以XML的方式描述机器人的结构和关节的文件。该文件可以被C++内置的解释器转换成可视化的机器人模型。<br>②Rviz：Rviz是ROS Visualization Tool的缩写，直译为ROS的三维可视化工具，它的主要目的是以三维方式显示ROS消息，可以将数据进行可视化表达。<br>③Gazebo：Gazebo是一款3D动态模拟器，用于显示机器人模型并创建仿真环境,能够在复杂的室内和室外环境中准确有效地模拟机器人。<br>④总结：机器人的系统仿真是一种集成实现，其中URDF用于创建机器人模型，Rviz用于以图形化的方式显示机器人各种传感器感知到的环境信息，Gazebo用于搭建仿真环境。<br>三者应用中，只是创建URDF意义不大，一般需要结合Gazebo或Rviz使用，在Gazebo或Rviz中可以将URDF 文件解析为图形化的机器人模型，一般的使用组合为:如果非仿真环境，那么使用URDF结合Rviz直接显示感知的真实环境信息；如果是仿真环境，那么需要使用URDF结合Gazebo搭建仿真环境，并结合Rviz显示感知的虚拟环境信息。<br>2.代码实现URDF集成Rviz：<br>①导入依赖和搭建架构：创建新的功能包并导入依赖包urdf与xacro，新建目录:<br>1&gt;urdf：再下分目录urdf和xacro，其中urdf存储urdf文件，xacro存储xacro文件<br>2&gt;meshes：存储机器人模型渲染文件stl<br>3&gt;config：存储配置文件rviz<br>4&gt;launch：存储launch启动文件<br>②编写URDF文件：URDF 文件是一个标准的 XML 文件，在 ROS 中预定义了一系列的标签用于描述机器人模型，具体可以分为以下四类：<br>1&gt;robot标签：根标签，类似于launch文件中的launch标签<br>a)name属性: 指定机器人模型的名称<br>b)子标签：其他标签都是robot子级标签<br>2&gt;link标签：连杆标签，用于描述机器人某个部件(也即刚体部分)的外观和物理属性，比如:机器人底座、轮子、激光雷达、摄像头等都对应了一个link。<br>一个连杆由以下几部分组成：连杆参考的基坐标，连杆的视觉形象（连杆的形状，连杆基于基坐标产生的偏移和旋转，连杆的颜色和透明度），连杆的碰撞属性和惯性矩阵。</p><p>a)name属性: 指定连杆的名称<br>b)visual子标签：指定连杆的外观(对应的数据是可视的)<br>geometry子标签：设置连杆的形状（注意其下只能同时存在以下一个标签）<br>box子标签：设置连杆的形状为立方体<br>size属性：设置立方体的长(x) 宽(y) 高(z)<br>cylinder子标签：设置连杆的形状为圆柱<br>radius属性：设置圆柱的半径<br>length属性：设置圆柱的高度<br>sphere子标签：设置连杆的形状为球<br>radius属性：设置球的半径<br>mesh子标签：自定义设置连杆的形状<br>filename属性：设置自定义文件所在的路径(格式:package://…)<br>origin子标签：设置连杆相对于坐标原点的偏移量与倾斜弧度<br>xyz属性:设置坐标偏移x y z<br>rpy属性:设置坐标旋转r p y (弧度)<br>material子标签：设置连杆的颜色和透明度<br>name属性：指定material的名称<br>color子标签：设置连杆的颜色和透明度<br>rgba属性：红绿蓝权重值与透明度[0,1]<br>c)collision子标签：指定连杆的碰撞属性，即碰撞体积的大小<br>d)Inertial子标签：指定连杆的惯性矩阵<br>3&gt;joint子标签：关节标签，用于连接机器人的两个连杆部件(分别称之为parent link与child link)，不同的关节有不同的运动形式: 他可以是任意旋转的云台、用螺丝螺母固定的结构、或是旋转受限的俯仰机构，这些都可以在joint标签下设置。需要注意的是，joint标签对应的数据在模型中是不可见的。<br>一个关节由以下几部分组成：父连杆与子连杆，关节相对于父连杆基坐标的偏移，关节的类型与旋转轴。需要注意的是此时关节的位置就是子连杆基坐标的位置。</p><p>a)name属性: 指定关节的名称<br>b)type 属性：指定关节的类型，分别可以设置为：<br>continuous: 旋转关节，可以绕单轴无限旋转<br>revolute: 旋转关节，类似于 continuous,但是有旋转角度限制<br>prismatic: 滑动关节，沿某一轴线移动的关节，有位置极限<br>planer: 平面关节，允许在平面正交方向上平移或旋转<br>floating: 浮动关节，允许进行平移、旋转运动<br>fixed: 固定关节，不允许运动的特殊关节<br>c)parent子标签：<br>link属性：父级连杆的名字<br>d)child子标签：<br>link属性：子级连杆的名字<br>e)origin子标签：<br>xyz属性: 关节相对于父连杆基坐标各轴线上的偏移量<br>rpy属性：关节相对于父连杆基坐标各轴线上的偏移弧度<br>f)axis子标签：<br>xyz属性: 设置关节围绕哪个关节轴（用向量表示）运动<br>4&gt;gazebo标签：集成gazebo需要使用的标签，会在之后详细解释<br>③URDF工具：<br>1&gt;命令check_urdf urdf文件可以检查复杂的urdf文件是否存在语法问题。如果不抛出异常，说明文件合法,否则非法。<br>2&gt;命令urdf_to_graphiz urdf文件可以查看urdf关节和连杆的树形模型结构<br>④编写launch文件解析URDF文件：<br>之前提到过URDF需要被Rviz解析才能出现图形化的机器人模型，这一过程可以通过编写launch文件实现，具体的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">//1.寻找urdf文件</span><br><span class="line">&lt;param name=&quot;xxx&quot; textfile=&quot;$(find 包名)/urdf/urdf/urdf文件&quot; /&gt;</span><br><span class="line">//2.启动rviz节点，调用上次存储的rviz状态配置文件.rviz</span><br><span class="line">//第一次载入时不加args，进入rviz后点击Add-&gt;RobotModel后Save Config</span><br><span class="line">&lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; </span><br><span class="line">args=&quot;-d $(find 包名)/config/xxx.rviz&quot;/&gt;</span><br><span class="line">//3.启动机器人状态和关节状态发布节点</span><br><span class="line">&lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; </span><br><span class="line">name=&quot;robot_state_publisher&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; </span><br><span class="line">name=&quot;joint_state_publisher&quot; /&gt;</span><br><span class="line">//4.启动图形化的控制关节运动节点 </span><br><span class="line">&lt;node pkg=&quot;joint_state_publisher_gui&quot; type=&quot;joint_state_publisher_gui&quot; name=&quot;joint_state_publisher_gui&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">⑤编写Xacro文件优化URDF文件的实现过程：</span><br><span class="line">前面URDF文件构建机器人模型的过程中，存在一些问题：</span><br><span class="line">在设计关节的位置时，需要按照一定的公式计算，公式是固定的，但是在URDF中依赖于人工计算，存在不便，容易计算失误，且当某些参数发生改变时，还需要重新计算。</span><br><span class="line">URDF 中的部分内容是高度重复的，驱动轮与支撑轮的设计实现，不同轮子只是部分参数不同，形状、颜色、翻转量都是一致的，在实际应用中，构建复杂的机器人模型时，更是易于出现高度重复的设计，按照一般的编程涉及到重复代码应该考虑封装。</span><br><span class="line">在编程语言中，可以通过变量结合函数直接解决上述问题，ROS则选择引入了Xacro。Xacro 是一种 XML 宏语言，是可编程的 XML。Xacro 可以声明变量，可以通过数学运算求解，使用流程控制控制执行顺序，还可以通过类似函数的实现，封装固定的逻辑，将逻辑中需要的可变的数据以参数的方式暴露出去，从而提高代码复用率以及程序的安全性。</span><br><span class="line">由于Xacro也是一种XML格式文件，因而其基本编写逻辑与URDF无异，但是Xacro文件额外提供了属性、宏和文件包含的XML语句，具体的：</span><br><span class="line">1&gt;属性：类似于变量定义，用于封装URDF中的一些字段，比如PI值，小车的尺寸等</span><br><span class="line">属性定义：&lt;xacro:property name=&quot;xxxx&quot; value=&quot;yyyy&quot; /&gt;</span><br><span class="line">属性调用：$&#123;属性名称&#125;</span><br><span class="line">算数运算：$&#123;数学表达式&#125;</span><br><span class="line">2&gt;宏：类似于函数实现，提高代码复用率</span><br><span class="line">宏定义：&lt;xacro:macro name=&quot;宏名称&quot; params=&quot;参数列表(空格分隔)&quot;&gt;</span><br><span class="line">    .....</span><br><span class="line">    参数调用格式: $&#123;参数名&#125;</span><br><span class="line">&lt;/xacro:macro&gt;</span><br><span class="line">宏调用：&lt;xacro:宏名称 参数1=xxx 参数2=xxx/&gt;</span><br><span class="line">3&gt;文件包含：类似于include，将不同部件封装为单独的xacro文件再将它们集成。</span><br><span class="line">文件包含语句：&lt;xacro:include filename=”xxx.xacro&quot; /&gt;</span><br><span class="line">需要注意的是文件的包含是有顺序的，当某一文件需要调用另一文件的东西时，该文件在文件包含中必须位于另一文件之后。一般来说会有一个总文件专门整合各部分Xacro。</span><br><span class="line">需要注意的是Xacro文件本身是不能被Rviz直接解析的，需要先将Xacro文件编译为URDF文件，为此Xacro文件的根标签robot中必须包含命名空间声明属性的语句:</span><br><span class="line">xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;</span><br><span class="line">此外，还需要修改launch文件的param属性为：</span><br><span class="line">&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro </span><br><span class="line">$(find 包名)/urdf/xacro/xxx.xacro&quot; /&gt;</span><br><span class="line">⑥使用Arbotix在Rviz中实现控制机器人模型运动：</span><br><span class="line">通过 URDF 结合 rviz 可以创建并显示机器人模型，不过当前实现的只是静态模型，而使用 Arbotix 可以实现对机器人模型的运动控制。Arbotix 是一款控制电机、舵机的控制板，并提供相应的 ros 功能包，这个功能包的功能不仅可以驱动真实的 Arbotix 控制板，它还提供一个差速控制器，通过接受速度控制指令更新机器人的 joint 状态，从而帮助我们实现机器人在 rviz 中的运动。这个差速控制器在 arbotix_python 程序包中，完整的 arbotix 程序包还包括多种控制器，分别对应 dynamixel 电机、多关节机械臂以及不同形状的夹持器。</span><br><span class="line">使用Arbotix的方法是在原有静态机器人模型的基础上添加 Arbotix 相关的配置文件和节点。在config文件夹下添加配置文件WheelController.yaml如下：</span><br><span class="line">controllers: &#123;</span><br><span class="line">   # 单控制器设置</span><br><span class="line">   base_controller: &#123;</span><br><span class="line">       type: diff_controller,#类型: 差速控制器</span><br><span class="line">       base_frame_id: base_footprint, #参考坐标</span><br><span class="line">       base_width: 0.2,#两个轮子之间的间距</span><br><span class="line">       ticks_meter: 2000, #控制频率</span><br><span class="line">       #PID控制参数，使机器人车轮快速达到预期速度</span><br><span class="line">       Kp: 12, </span><br><span class="line">       Kd: 12, </span><br><span class="line">       Ki: 0, </span><br><span class="line">       Ko: 50, </span><br><span class="line">       accel_limit: 1.0 #加速限制</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这段配置文件是一个差速控制器，规定了控制器的相关参数设置，例如配置差速轮的间距和PID控制参数。</span><br><span class="line">而后在原静态模型launch文件中添加配置 arbotix 节点如下：</span><br><span class="line">&lt;node name=&quot;arbotix&quot; pkg=&quot;arbotix_python&quot; type=&quot;arbotix_driver&quot; </span><br><span class="line">output=&quot;screen&quot;&gt;</span><br><span class="line">&lt;rosparam command=&quot;load&quot; </span><br><span class="line">file=&quot;$(find 包名)/config/WheelController.yaml&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;sim&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line">可以看到Arbotix是一个节点，在节点中载入之前配置的文件WheelController.yaml，同时设置环境为仿真环境。</span><br><span class="line">启动该launch文件，在rviz里选择坐标系Fixed Frame为odom（里程计），Add添加odometry，选择odometry的话题Topic为/odom，/odom会自动呼出速度控制话题/cmd_vel，也就是说我们可以发布 cmd_vel 话题消息控制小车运动了，该实现策略有多种，可以另行编写节点，或者更简单些可以直接通过如下命令发布消息:</span><br><span class="line">rostopic pub -r 10 /cmd_vel geometry_msgs/Twist &#x27;&#123;linear: &#123;x: 0.2, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 0.5&#125;&#125;&#x27;</span><br><span class="line">现在，小车就可以运动起来了。</span><br><span class="line">3.代码实现URDF集成Gazebo：</span><br><span class="line">①导入依赖和搭建架构：创建新的功能包并导入依赖包 urdf、xacro、gazebo_ros、gazebo_ros_control、gazebo_plugins，新建目录:</span><br><span class="line">1&gt;urdf：再下分目录urdf、xacro和Gazebo，其中urdf存储urdf文件，xacro存储xacro文件，Gazebo存储连杆配置文件（虽然也是Xacro文件，但前两者是建立模型时使用的文件，后者则是配置连杆功能时使用的文件）</span><br><span class="line">2&gt;launch：存储launch启动文件</span><br><span class="line">3&gt;worlds：存储在Gazebo中构建的世界模型</span><br><span class="line">②编写建立模型的URDF和Xacro文件：整体过程与URDF集成Rviz时大体一致，但由于Gazebo基于仿真环境，因此连杆link必须启用碰撞检测collision和惯性力学计算标签inertial ，此外，Gazebo下的颜色设置也需要使用专门的标签gazebo：</span><br><span class="line">&lt;gazebo reference=&quot;base_link&quot;&gt;</span><br><span class="line">&lt;material&gt;Gazebo/Black&lt;/material&gt;#设置颜色为黑色</span><br><span class="line">&lt;/gazebo&gt;</span><br><span class="line">1&gt;collision标签：如果机器人link是标准的几何体形状，那么collision的设置只需要和 visual的设置一致即可（除了不需要设置颜色）。</span><br><span class="line">2&gt;inertial标签：惯性矩阵是一个非常专业的概念，在Gazebo中如果胡乱设置会导致仿真出现各种问题，基本形状的惯性矩阵可以直接使用下述Xacro文件的宏计算获得：</span><br><span class="line">&lt;!-- 球体惯性矩阵：m为质量，r为半径--&gt;</span><br><span class="line">    &lt;xacro:macro name=&quot;sphere_inertial_matrix&quot; params=&quot;m r&quot;&gt;</span><br><span class="line">        &lt;inertial&gt;</span><br><span class="line">            &lt;mass value=&quot;$&#123;m&#125;&quot; /&gt;</span><br><span class="line">            &lt;inertia ixx=&quot;$&#123;2*m*r*r/5&#125;&quot; ixy=&quot;0&quot; ixz=&quot;0&quot;</span><br><span class="line">                iyy=&quot;$&#123;2*m*r*r/5&#125;&quot; iyz=&quot;0&quot; </span><br><span class="line">                izz=&quot;$&#123;2*m*r*r/5&#125;&quot; /&gt;</span><br><span class="line">        &lt;/inertial&gt;</span><br><span class="line">&lt;/xacro:macro&gt;</span><br><span class="line">&lt;!-- 圆柱惯性矩阵：m为质量，r为半径，h为高度--&gt;</span><br><span class="line">&lt;xacro:macro name=&quot;cylinder_inertial_matrix&quot; params=&quot;m r h&quot;&gt;</span><br><span class="line">        &lt;inertial&gt;</span><br><span class="line">            &lt;mass value=&quot;$&#123;m&#125;&quot; /&gt;</span><br><span class="line">            &lt;inertia ixx=&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot; ixy = &quot;0&quot; ixz = &quot;0&quot;</span><br><span class="line">                iyy=&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot; iyz = &quot;0&quot;</span><br><span class="line">                izz=&quot;$&#123;m*r*r/2&#125;&quot; /&gt; </span><br><span class="line">        &lt;/inertial&gt;</span><br><span class="line">&lt;/xacro:macro&gt;</span><br><span class="line">&lt;!-- 立方体惯性矩阵：m为质量，l为长度，w为宽度，h为高度--&gt;</span><br><span class="line"> &lt;xacro:macro name=&quot;Box_inertial_matrix&quot; params=&quot;m l w h&quot;&gt;</span><br><span class="line">       &lt;inertial&gt;</span><br><span class="line">               &lt;mass value=&quot;$&#123;m&#125;&quot; /&gt;</span><br><span class="line">               &lt;inertia ixx=&quot;$&#123;m*(h*h + l*l)/12&#125;&quot; ixy = &quot;0&quot; ixz = &quot;0&quot;</span><br><span class="line">                   iyy=&quot;$&#123;m*(w*w + l*l)/12&#125;&quot; iyz= &quot;0&quot;</span><br><span class="line">                   izz=&quot;$&#123;m*(w*w + h*h)/12&#125;&quot; /&gt;</span><br><span class="line">       &lt;/inertial&gt;</span><br><span class="line">   &lt;/xacro:macro&gt;</span><br><span class="line">再次强调：原则上除了base_footprint外，机器人的每个刚体部分都需要设置惯性矩阵，且惯性矩阵必须经上述计算严谨得出。具体在调用时，只需要使用对应的宏即可，例如：</span><br><span class="line">&lt;xacro:cylinder_inertial_matrix m=xxx r=xxx h=xxx /&gt;</span><br><span class="line">即可返回一个正确的惯性标签。</span><br><span class="line">3&gt;Gazebo标签：Gazebo是一种修饰标签，它依赖于其他已有的标签存在，其属性reference的值就是依赖标签的名字，它只起修饰reference所指向的标签的作用。例如上例就是修饰名字为base_link的连杆颜色为黑色，之后还会提到修饰某个连杆为雷达、摄像头、里程计等。</span><br><span class="line">③编写控制机器人运动的URDF和Xacro文件：至此gazebo 中已经可以显示静态机器人模型了，那么如何像在rviz中一样控制机器人运动呢？在此，需要涉及到ros中的组件: ros_control。ros_control是一组软件包，它包含了控制器接口，控制器管理器，传输和硬件接口。它是一套机器人控制的中间件，是一套规范，不同的机器人平台只要按照这套规范实现，那么就可以保证与ROS 程序兼容，通过这套规范，实现了一种可插拔的架构设计，大大提高了程序设计的效率与灵活性。gazebo 已经实现了 ros_control 的相关接口，如果需要在 gazebo 中控制机器人运动，直接调用相关接口即可。编写Xacro文件如下：</span><br><span class="line">&lt;robot name=&quot;my_car_move&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;</span><br><span class="line">    &lt;!-- 传动实现:用于连接控制器与关节 --&gt;</span><br><span class="line">    &lt;xacro:macro name=&quot;joint_trans&quot; params=&quot;joint_name&quot;&gt;</span><br><span class="line">        &lt;!-- Transmission is important to link the joints and the controller --&gt;</span><br><span class="line">        &lt;transmission name=&quot;$&#123;joint_name&#125;_trans&quot;&gt;</span><br><span class="line">            &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;</span><br><span class="line">            &lt;joint name=&quot;$&#123;joint_name&#125;&quot;&gt;      &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface</span><br><span class="line">&lt;/hardwareInterface&gt;</span><br><span class="line">            &lt;/joint&gt;</span><br><span class="line">            &lt;actuator name=&quot;$&#123;joint_name&#125;_motor&quot;&gt;</span><br><span class="line">                &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface</span><br><span class="line">&lt;/hardwareInterface&gt;</span><br><span class="line">                &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;</span><br><span class="line">            &lt;/actuator&gt;</span><br><span class="line">        &lt;/transmission&gt;</span><br><span class="line">    &lt;/xacro:macro&gt;</span><br><span class="line">    &lt;!-- 每一个驱动轮都需要配置传动装置 --&gt;</span><br><span class="line">    &lt;xacro:joint_trans joint_name=&quot;left_wheel2base_link&quot; /&gt;</span><br><span class="line">    &lt;xacro:joint_trans joint_name=&quot;right_wheel2base_link&quot; /&gt;</span><br><span class="line">    &lt;!-- 控制器 --&gt;</span><br><span class="line">    &lt;gazebo&gt;</span><br><span class="line">        &lt;plugin name=&quot;differential_drive_controller&quot; </span><br><span class="line">filename=&quot;libgazebo_ros_diff_drive.so&quot;&gt;</span><br><span class="line">            &lt;rosDebugLevel&gt;Debug&lt;/rosDebugLevel&gt;</span><br><span class="line">            &lt;publishWheelTF&gt;true&lt;/publishWheelTF&gt;</span><br><span class="line">            &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;</span><br><span class="line">            &lt;publishTf&gt;1&lt;/publishTf&gt;</span><br><span class="line">            &lt;publishWheelJointState&gt;true&lt;/publishWheelJointState&gt;</span><br><span class="line">            &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;</span><br><span class="line">            &lt;updateRate&gt;100.0&lt;/updateRate&gt;</span><br><span class="line">            &lt;legacyMode&gt;true&lt;/legacyMode&gt;</span><br><span class="line">            &lt;leftJoint&gt;left_wheel2base_link&lt;/leftJoint&gt;</span><br><span class="line">            &lt;rightJoint&gt;right_wheel2base_link&lt;/rightJoint&gt; </span><br><span class="line">            &lt;wheelSeparation&gt;$&#123;base_link_radius*2&#125;&lt;/wheelSeparation&gt; </span><br><span class="line">            &lt;wheelDiameter&gt;$&#123;wheel_radius * 2&#125;&lt;/wheelDiameter&gt;            </span><br><span class="line">&lt;broadcastTF&gt;1&lt;/broadcastTF&gt;</span><br><span class="line">            &lt;wheelTorque&gt;30&lt;/wheelTorque&gt;</span><br><span class="line">            &lt;wheelAcceleration&gt;1.8&lt;/wheelAcceleration&gt;</span><br><span class="line">            &lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;</span><br><span class="line">            &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt; </span><br><span class="line">            &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;</span><br><span class="line">            &lt;robotBaseFrame&gt;base_footprint&lt;/robotBaseFrame&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/gazebo&gt;</span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure><br>一些重要标签：xacro:joint_trans宏用于绑定左右轮的关节，leftJoint和rightJoint用于绑定左右轮的连杆名称，wheelSeparation用于设置车轮间距，wheelDiameter用于设置车轮直径，commandTopic用于设置运动控制话题名，odometryTopic用于设置里程计话题名，robotBaseFrame用于设置根坐标系名。</p><p>④编写修饰模型的URDF和Xacro文件：<br>1&gt;里程计：里程计用于获取机器人相对出发点坐标系的位姿状态(XYZ坐标以及朝向)<br>可以通过 Rviz 显示机器人的里程计信息以及运动朝向<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;!-- 启动 rviz --&gt;</span><br><span class="line">    &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 关节以及机器人状态发布节点 --&gt;</span><br><span class="line">    &lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; /&gt;</span><br><span class="line">    &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><br>2&gt;雷达：和里程计直接与机器人控制节点集成不同，ROS中设置雷达的方式是把一个连杆组件修饰为仿真雷达，也就是使用gazebo reference的方法，具体Xacro文件如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;robot name=&quot;my_sensors&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;</span><br><span class="line">  &lt;gazebo reference=&quot;laser（想要修饰为雷达的连杆名）&quot;&gt;</span><br><span class="line">    &lt;sensor type=&quot;ray&quot; name=&quot;rplidar&quot;&gt;</span><br><span class="line">      &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;</span><br><span class="line">      &lt;visualize&gt;true&lt;/visualize&gt;</span><br><span class="line">      &lt;update_rate&gt;5.5&lt;/update_rate&gt;</span><br><span class="line">      &lt;ray&gt;</span><br><span class="line">        &lt;scan&gt;</span><br><span class="line">          &lt;horizontal&gt;</span><br><span class="line">            &lt;samples&gt;360&lt;/samples&gt;</span><br><span class="line">            &lt;resolution&gt;1&lt;/resolution&gt;</span><br><span class="line">            &lt;min_angle&gt;-3&lt;/min_angle&gt;</span><br><span class="line">            &lt;max_angle&gt;3&lt;/max_angle&gt;</span><br><span class="line">          &lt;/horizontal&gt;</span><br><span class="line">        &lt;/scan&gt;</span><br><span class="line">        &lt;range&gt;</span><br><span class="line">          &lt;min&gt;0.10&lt;/min&gt;</span><br><span class="line">          &lt;max&gt;30.0&lt;/max&gt;</span><br><span class="line">          &lt;resolution&gt;0.01&lt;/resolution&gt;</span><br><span class="line">        &lt;/range&gt;</span><br><span class="line">        &lt;noise&gt;</span><br><span class="line">          &lt;type&gt;gaussian&lt;/type&gt;</span><br><span class="line">          &lt;mean&gt;0.0&lt;/mean&gt;</span><br><span class="line">          &lt;stddev&gt;0.01&lt;/stddev&gt;</span><br><span class="line">        &lt;/noise&gt;</span><br><span class="line">      &lt;/ray&gt;</span><br><span class="line">      &lt;plugin name=&quot;gazebo_rplidar&quot; filename=&quot;libgazebo_ros_laser.so&quot;&gt;</span><br><span class="line">        &lt;topicName&gt;/scan&lt;/topicName&gt;</span><br><span class="line">        &lt;frameName&gt;laser&lt;/frameName&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/sensor&gt;</span><br><span class="line">  &lt;/gazebo&gt;</span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure><br>一些重要标签：sensor type为传感器类型，pose为偏移，update_rate为数据更新频率，<br>samples为光线数，resolution为分辨率，min/max_angle为雷达非死区范围，noise为噪声（高斯噪声，均值和标准差），topicName为话题名称。<br>3&gt;摄像头：ROS中设置摄像头的方式与雷达一致，即把一个连杆组件修饰为仿真摄像头：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;robot name=&quot;my_sensors&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;</span><br><span class="line">  &lt;gazebo reference=&quot;camera（想要修饰为摄像头的连杆名）&quot;&gt;</span><br><span class="line">    &lt;sensor type=&quot;camera&quot; name=&quot;camera_node&quot;&gt;</span><br><span class="line">      &lt;update_rate&gt;30.0&lt;/update_rate&gt; &lt;!-- 更新频率 --&gt;</span><br><span class="line">      &lt;!-- 摄像头基本信息设置 --&gt;</span><br><span class="line">      &lt;camera name=&quot;head&quot;&gt;</span><br><span class="line">        &lt;horizontal_fov&gt;1.3962634&lt;/horizontal_fov&gt;</span><br><span class="line">        &lt;image&gt;</span><br><span class="line">          &lt;width&gt;1280&lt;/width&gt;</span><br><span class="line">          &lt;height&gt;720&lt;/height&gt;</span><br><span class="line">          &lt;format&gt;R8G8B8&lt;/format&gt;</span><br><span class="line">        &lt;/image&gt;</span><br><span class="line">        &lt;clip&gt;</span><br><span class="line">          &lt;near&gt;0.02&lt;/near&gt;</span><br><span class="line">          &lt;far&gt;300&lt;/far&gt;</span><br><span class="line">        &lt;/clip&gt;</span><br><span class="line">        &lt;noise&gt;</span><br><span class="line">          &lt;type&gt;gaussian&lt;/type&gt;</span><br><span class="line">          &lt;mean&gt;0.0&lt;/mean&gt;</span><br><span class="line">          &lt;stddev&gt;0.007&lt;/stddev&gt;</span><br><span class="line">        &lt;/noise&gt;</span><br><span class="line">      &lt;/camera&gt;</span><br><span class="line">      &lt;plugin name=&quot;gazebo_camera&quot; filename=&quot;libgazebo_ros_camera.so&quot;&gt;</span><br><span class="line">        &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;</span><br><span class="line">        &lt;updateRate&gt;0.0&lt;/updateRate&gt;</span><br><span class="line">        &lt;cameraName&gt;/camera&lt;/cameraName&gt;</span><br><span class="line">        &lt;imageTopicName&gt;image_raw&lt;/imageTopicName&gt;</span><br><span class="line">        &lt;cameraInfoTopicName&gt;camera_info&lt;/cameraInfoTopicName&gt;</span><br><span class="line">        &lt;frameName&gt;camera&lt;/frameName&gt;</span><br><span class="line">        &lt;hackBaseline&gt;0.07&lt;/hackBaseline&gt;</span><br><span class="line">        &lt;distortionK1&gt;0.0&lt;/distortionK1&gt;</span><br><span class="line">        &lt;distortionK2&gt;0.0&lt;/distortionK2&gt;</span><br><span class="line">        &lt;distortionK3&gt;0.0&lt;/distortionK3&gt;</span><br><span class="line">        &lt;distortionT1&gt;0.0&lt;/distortionT1&gt;</span><br><span class="line">        &lt;distortionT2&gt;0.0&lt;/distortionT2&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/sensor&gt;</span><br><span class="line">  &lt;/gazebo&gt;</span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure><br>⑤整合各部分Xacro文件：<br>分析我们需要包含的文件，首先是惯性矩阵计算的Xacro文件InertialAlgorithm.xacro，然后是形成机器人静态模型的各Xacro文件，例如底盘、摄像头与雷达等，最后是修饰机器人模型所需的Xacro文件。然后创建一个Xacro文件将它们全部包含进来，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;robot name=&quot;my_car_camera&quot;</span><br><span class="line">xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;</span><br><span class="line">&lt;!-- 引入建立机器人模型所需的Xacro文件 --&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;InertialAlgorithm.xacro&quot;/&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;XacroExerciseCarBase1.xacro&quot; /&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;XacroExerciseCamera1.xacro&quot; /&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;XacroExerciseLaser1.xacro&quot; /&gt;</span><br><span class="line">&lt;!-- 引入控制机器人运动所需的Xacro文件 --&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;gazebo/WheelMove.xacro&quot;/&gt;</span><br><span class="line">&lt;!-- 引入修饰机器人模型所需的Xacro文件 --&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;gazebo/Laser.xacro&quot;/&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;gazebo/Camera.xacro&quot;/&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;gazebo/Kinect.xacro&quot;/&gt;</span><br><span class="line">&lt;/robot&gt;</span><br><span class="line">⑥编写launch文件解析URDF和Xacro文件，并启动Gazebo：</span><br><span class="line">&lt;launch&gt;</span><br><span class="line">&lt;!-- 将 Urdf 文件的内容加载到参数服务器 --&gt;</span><br><span class="line">&lt;param name=&quot;robot_description&quot; </span><br><span class="line">command=&quot;$(find xacro)/xacro $(find 包名)/urdf/Xacro整合文件.xacro&quot; /&gt;</span><br><span class="line">&lt;!-- 启动 gazebo，方法是启动对应launch文件并载入world文件--&gt;</span><br><span class="line">&lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;</span><br><span class="line">&lt;arg name=&quot;world_name&quot; value=&quot;$(find 包名)/worlds/xxx.world&quot; /&gt;</span><br><span class="line">&lt;/include&gt;</span><br><span class="line">&lt;!-- 在 gazebo 中显示机器人模型，需要结合第一步Urdf的param名字 --&gt;</span><br><span class="line">&lt;node pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; name=&quot;model&quot; </span><br><span class="line">args=&quot;-urdf -model mycar -param robot_description&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br><span class="line">⑦编写launch文件启动Rviz监测机器人在Gazebo仿真环境下的状态：</span><br><span class="line">之前的文件都是为了启动Gazebo仿真小车的，而状态的监测需要使用Rviz，为此编写专门启动Rviz用来检测机器人状态的launch文件：</span><br><span class="line">&lt;launch&gt;</span><br><span class="line">&lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; </span><br><span class="line">args=&quot;-d $(find UrdfTest)/config/ShowMyCar.rviz&quot;/&gt;</span><br><span class="line">&lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; </span><br><span class="line">type=&quot;joint_state_publisher&quot; /&gt;</span><br><span class="line">&lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; </span><br><span class="line">type=&quot;robot_state_publisher&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><br>⑧Gazebo仿真文件.world搭建：<br>之前提到过world文件可以在Gazebo中载入已经搭建好的一个仿真环境。<br>那么怎么创建一个新的仿真环境呢？实现方式有三种:分别是直接添加内置组件创建仿真环境，手动绘制仿真环境和直接下载使用官方或第三方提供的仿真环境插件，我们分别来看看<br>1&gt;直接添加内置组件：在Gazebo上方有基本形状和光照，直接导入即可。<br>2&gt;手动绘制仿真环境：点击Edit/Building Editor即可自定义设计仿真环境。<br>3&gt;使用插件：下载官方库git clone <a href="https://github.com/osrf/gazebo_models并将得到的gazebo_models文件夹内容复制到">https://github.com/osrf/gazebo_models并将得到的gazebo_models文件夹内容复制到</a> /usr/share/gazebo-*/models中，此时重启 Gazebo，选择左侧菜单栏的insert就可以选择并插入相关道具了。<br>绘制好新的仿真环境后，选择File/Save World As即可得到一个world文件了。<br>4.总结：主要介绍了ROS中仿真实现涉及的三大知识点:URDF(Xacro)，Rviz和Gazebo<br>其中URDF 是用于描述机器人模型的 xml 文件，可以使用不同的标签具代表不同含义，xacro 则是对 URDF 的优化实现。容易混淆的是Rviz与Gazebo，在此我们着重比较以下二者的区别:rviz是三维可视化工具，强调通过插件把已有的数据可视化显示，也就是说它需要已有数据的支持，这些数据可以通过话题、参数的形式发布后被Rviz订阅，而后Rviz对其完成可视化的渲染，以此让开发者更容易理解数据的意义；gazebo是三维物理仿真平台，强调的是创建一个虚拟的仿真环境，不需要数据，而是创造数据。我们可以在gazebo中创建一个仿真机器人的运动功能和传感器数据的虚拟世界，而这些数据就可以放到rviz中显示，所以gazebo和rviz经常配合使用。综上，如果你手上已经有机器人硬件平台，并且在上边可以完成需要的功能，用rviz应该就可以满足开发需求。如果你手上没有机器人硬件，或者想在仿真环境中做一些算法、应用的测试，gazebo+rviz应该是你需要的。</p><h1 id="机器人导航："><a href="#机器人导航：" class="headerlink" title="机器人导航："></a>机器人导航：</h1><p>amcl通过传感器获取的信息，将这些特征点与全局地图相匹配，从而大致获取机器人的位姿信息。</p><p>rosrun nodelet nodelet load nodelet_tutorial_math/Plus mymanager <strong>name:=n1 _value:=100<br> rosrun nodelet nodelet load nodelet_tutorial_math/Plus mymanager </strong>name:=n2 _value:=-50 /n2/in:=/n1/out</p><h1 id="Action通信："><a href="#Action通信：" class="headerlink" title="Action通信："></a>Action通信：</h1><p>假设要求机器人导航到某个目标点,此过程需要一个节点A发布目标信息，然后一个节点B接收到请求并控制移动，最终响应目标达成状态信息。乍一看，这好像是服务通信，因为需求中要A发送目标，B执行并返回结果，是一个典型的基于请求响应的应答模式，不过如果只是使用基本的服务通信实现，存在一个问题：导航是一个过程，是耗时操作，如果使用服务通信，那么只有在导航结束时，才会产生响应结果，而在导航过程中，节点A是不会获取到任何反馈的，从而可能出现程序”假死”的现象，过程的不可控意味着不良的用户体验，以及逻辑处理的缺陷(比如:导航中止的需求无法实现)。更合理的方案应该是:导航过程中，可以连续反馈当前机器人状态信息，当导航终止时再返回最终的执行结果。这个过程在ROS中被action通信优化。action通信一般适用于耗时的请求响应场景,用以获取连续的状态反馈，是一种特殊的服务通信。在ROS中提供了actionlib功能包集，用于实现 action 通信。action通信是一种类似于服务通信的实现，其实现模型也包含请求和响应，但是不同的是，在请求和响应的过程中，服务端还可以连续的反馈当前任务进度，客户端可以接收连续反馈，并且还可以取消任务。</p><p>goal:目标任务;<br>cacel:取消任务;<br>status:服务端状态;<br>result:最终执行结果(只会发布一次);<br>feedback:连续反馈(可以发布多次)。<br>尝试用代码实现下述Action通信过程：创建两个ROS节点作为服务器和客户端，客户端可以向服务器发送目标数据N，服务器会计算 1 到 N 之间所有整数的和并返回给客户端，假设服务器每累加一次耗时0.1s，为了良好的用户体验，需要服务器在计算过程中，每累加一次就给客户端响应一次百分比格式的执行进度。<br>类似于话题和服务通信，当使用自定义通讯格式进行action通讯时，需要进行以下操作：<br>1.定义action文件：在小src同级下创建action文件夹并创建xxx.action文件，在其中以类似结构体的格式输入需要定义的自定义通讯格式构成。在action文件中，数据组成分为三部分:请求目标值、最终响应结果、连续反馈值，三者之间使用—-分割，例如:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int32 num</span><br><span class="line">---</span><br><span class="line">int32 result</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>float64 progress_bar<br>2.编辑package.xml：<br>这里简单介绍一下package文件的构成，package的核心代码如下：<br>①依赖的构建工具</p><p><buildtool_depend>catkin</buildtool_depend><br>②指定构建此软件包所需的软件包 （编译依赖）</p><p><build_depend>roscpp</build_depend></p><p><build_depend>rospy</build_depend></p><p><build_depend>std_msgs</build_depend><br>③指定根据这个包构建库所需要的包（编译外部依赖）</p><p><build_export_depend>roscpp</build_export_depend></p><p><build_export_depend>rospy</build_export_depend></p><p><build_export_depend>std_msgs</build_export_depend><br>④运行该程序包中的代码所需的程序包（执行依赖）</p><p><exec_depend>roscpp</exec_depend></p><p><exec_depend>rospy</exec_depend></p><p><exec_depend>std_msgs</exec_depend><br>我们要在编译依赖中添加<build_depend>message_generation</build_depend><br>在执行依赖中添加<exec_depend>message_runtime</exec_depend><br>3.编辑CMakeLists.txt：<br>L10：取消注释并修改编译依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L51：取消注释并配置msg源文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  xxx.msg</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L71：取消注释使自定义消息格式依赖于 std_msgs：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L108：取消注释并修改执行依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>4.编译：此时C++调用的中间文件位于(…/工作空间/devel/include/包名/xxx.h)<br>Python调用的中间文件位于(…/工作空间/devel/lib/python3/dist-packages/包名/msg/xxx.py)，之后要想使用这一自定义通讯格式就需要包含这个头文件。</p><h1 id="代码实现C-话题通讯："><a href="#代码实现C-话题通讯：" class="headerlink" title="代码实现C++话题通讯："></a>代码实现C++话题通讯：</h1><p><em>1.如果使用自定义格式，需要添加c_cpp_properties.json 的 includepath属性如下：<br> “/xxx/yyy工作空间/devel/include/*</em>“ //配置 head 文件的路径<br>2.包含通讯所需格式的头文件：<br>对于ROS官方提供的基本格式需要包含#include “std_msgs/xxx.h”<br>对于自定义的格式需要包含#include “包名/xxx.h”（即自定义格式经编译得到的头文件）<br>3.发布方实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Publisher”);<br>ros::NodeHandle nh;<br>②创建发布者对象：（发布者和订阅者的话题topic需要一致）<br>官方格式：ros::Publisher pub = nh.advertise<std_msgs::xxx>(“topic”, 10);<br>自定义格式：ros::Publisher pub = nh.advertise&lt;包名::xxx&gt;(“topic”, 10);<br>③编辑要发送的数据：<br>创建对象：std_msgs::xxx/包名::xxx msg;<br>4.订阅方实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Publisher”);<br>ros::NodeHandle nh;<br>②创建订阅者对象：<br>官方：ros::Subscriber sub = nh.subscribe<std_msgs::xxx>(“topic”,10,doMsg);<br>自定义：ros::Subscriber sub = nh.subscribe&lt;包名::xxx&gt;(“topic”,10,doMsg);<br>③循环调用回调函数：ros::spin();<br>④搭建回调函数doMsg：void doMsg(const 包名::xxx::ConstPtr &amp;msg){}</p><h1 id="动态参数："><a href="#动态参数：" class="headerlink" title="动态参数："></a>动态参数：</h1><h1 id="pluginlib的使用："><a href="#pluginlib的使用：" class="headerlink" title="pluginlib的使用："></a>pluginlib的使用：</h1><h1 id="nodelet的使用："><a href="#nodelet的使用：" class="headerlink" title="nodelet的使用："></a>nodelet的使用：</h1>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫学习</title>
      <link href="/2023/11/13/spider/"/>
      <url>/2023/11/13/spider/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据收集与处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlphaZero算法</title>
      <link href="/2023/11/01/AlphaZero/"/>
      <url>/2023/11/01/AlphaZero/</url>
      
        <content type="html"><![CDATA[<p>蒙特卡洛树搜索：</p><p>UCB(Upper Confidence Bound/上限置信区间)：探索-利用(Exploration-Exploitation)，基于过去产生的平均回报和对未来期望回报的累加，UCB1值最高的被认为是最有潜力的节点，即那些过去产生过很大价值，或是那些过去没有探索过但可能会产生更大价值的节点。</p><p>n代表number of visits，指访问次数</p><p>左半式为了找到最大的价值，右半式为了广泛探索可能</p><p>Value和迭代次数n均累加</p><p>根节点是当前状态<br>选取根节点的直接子节点中最大的一个行为<br>蒙特卡洛算法</p><p>Minimax算法：</p><p>Alpha-Beta剪枝算法：</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch学习</title>
      <link href="/2023/10/20/PyTorch/"/>
      <url>/2023/10/20/PyTorch/</url>
      
        <content type="html"><![CDATA[<p>Pip list<br>Conda create -n name python=3.x<br>Anaconda pytorch nvidia驱动<br>Conda activate创建虚拟环境</p><p>[]表示某一行，,进行分隔，比如说：<br>tensor([[1, 2],<br>      [3, 4],<br>      [5, 6],<br>      [7, 8]])<br>为[1,2;3,4;5,6;7,8]<br>是一个四行二列的矩阵<br>每存在一个[]，就有一个维度。例如[1,2]是一个一维向量，而[[1,2]]是一个二维矩阵</p><p>维度相同形状不同时的两个张量执行代数运算时，python存在广播机制，python会将两者中各维度最大值作为最终的输出张量的形状，同时将各运算张量的空白部分由原部分复制得到。这个操作很有可能会引起误操作，在执行两个形状不同向量的代数运算时一定要明确广播机制。</p><p>处理NaN：<br>对于数值型数据来说，可以使用fillna(mean())的方法将同一类中NaN的数据变为类中那些不是NaN数据的均值。</p><p>get_dummies能实现类别的独热编码，以此实现不同输出的分类，n类独热编码就有n维。</p><p>向量：</p><p>矩阵范数通常使用下面这个公式：</p><p>(m,l,k,n)</p><p>此时u不再是关于x的函数</p><p>线性回归：</p><p>解析解：</p><p>用有限的样本近似全部样本</p><p>线性回归基本流程：<br>1.确定神经网络架构，学习率参数，迭代次数，代价函数和优化算法<br>1&gt;net=nn.Sequential()<br>2&gt;lr<br>3&gt;NumEpochs<br>4&gt;Loss = nn.MSELoss()<br>5&gt;Trainer = torch.optim.SGD<br>2.确定训练集<br>data.TensorDataset<br>    data.DataLoader<br>3.确定学习参数初值<br>net[0].weight.data.normal<em>(0, 0.01)<br>    net[0].bias.data.fill</em>(0)<br>4.开始学习：<br>前向传播，计算y=wX+b，进一步计算代价函数<br>l = Loss(net(X), y)<br>反向传播，计算导数，进一步利用梯度下降更新学习参数<br>Trainer.zero_grad()<br>    l.backward()<br>    Trainer.step() </p><p>Softmax</p><p>关于：if <strong>name</strong> == ‘<strong>main</strong>‘:<br><a href="https://baijiahao.baidu.com/s?id=1744774969325487102&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1744774969325487102&amp;wfr=spider&amp;for=pc</a></p><p>感知机：</p><p>多层感知机是神经网络的雏形，而多层感知机使用线性激活就相当于一个单层感知机<br>单层感知机是一个线性模型</p><p>11.</p><p>验证数据集不参加训练，用于反应超参数的好坏。（一般代码里的测试数据集test_set实际上是验证数据集Cross-Validation Set）<br>测试数据集只能被使用一次。</p><p>模型复杂度（VC维）、数据复杂度（目前没有定量指标）</p><p>权重衰退解决过拟合：</p><p>Dropout:</p><p>验证=推理</p><p>梯度消失与爆炸：</p><p>i.i.d独立同分布，输入为h，输入均值为0，E[h]=0</p><p>权重通常是一个在0附近很小的数，这使得tanh和ReLU能够满足f(x)-&gt;x，而调整sigmoid</p><p>Pytorch的层和块：<br>层思想：</p><p>Sequential是python的一个list，可以使用任何list的方法<br>块思想：</p><p>从编程的角度来看，块由类（class）表示。 它的任何子类都必须定义一个将其输入转换为输出的前向传播函数， 并且必须存储任何必需的参数。 注意，有些块不需要任何参数。 最后，为了计算梯度，块必须具有反向传播函数。 在定义我们自己的块时，由于自动微分提供了一些后端实现，我们只需要考虑前向传播函数和必需的参数。<br>到目前为止，我们一直在通过net(X)调用我们的模型来获得模型的输出。这实际上是net.<strong>call</strong>(X)的简写。 这个前向传播函数非常简单： 它将列表中的每个块连接在一起，将每个块的输出作为下一个块的输入。<br>要想直观地了解块是如何工作的，最简单的方法就是自己实现一个。 在实现我们自定义块之前，我们简要总结一下每个块必须提供的基本功能。<br>1.将输入数据作为其前向传播函数的参数。<br>2.通过前向传播函数来生成输出。请注意，输出的形状可能与输入的形状不同。例如，我们上面模型中的第一个全连接的层接收一个20维的输入，但是返回一个维度为256的输出。<br>3.计算其输出关于输入的梯度，可通过其反向传播函数进行访问。通常这是自动发生的。<br>4.存储和访问前向传播计算所需的参数。<br>5.根据需要初始化模型参数。</p><p>实现复杂的架构：（比nn.Sequential更灵活）</p><p>得到参数：</p><p>Parameter定义了一个可以优化的参数。可见所有的模型参数（例如weight和bias）都是Parameter的一个子类</p><p>键值对的方式访问元素：</p><p>方法名后缀_表示该方法是一个替换方法，python会直接将值刷新而不用你去把结果赋值。<br>Net.apply(function)将function要求的初始化赋入神经网络<br>Xavier初始化就是在这里被调用</p><p>当然，我们也可以对网络的某一层使用apply</p><p>torch.save和torch.load不仅可以存取神经网络，还可以存取各种张量，网络层等基本单元</p><p>加载时不仅要得到参数，还要得到模型，所以在新文件引入时必须要把模型架构给带走</p><p>GPU训练：</p><p>卷积层除了各元素是权重之外还可以加偏移（也是学习参数）</p><p>更多的特殊卷积层例：</p><p>卷积层的定义Conv2d<br>通道输入，通道输出，过滤器规模，是否要偏差<br>Conv2d的输入是一个四维张量，分别是批量数，通道数，高度和宽度<br>因此对于输入通常要进行reshape</p><p>可以在行和列上分别取不同的步长</p><p>为了简洁起见，当输入高度和宽度两侧的填充数量分别为ph和pw时，我们称之为填充(ph,pw)。当ph=pw=p时，填充是p。同理，当高度和宽度上的步幅分别为sh和sw时，我们称之为步幅(sh,sw)。特别地，当sh=sw=s时，我们称步幅为s。默认情况下，填充为0，步幅为1。在实践中，我们很少使用不一致的步幅或填充，也就是说，我们通常有ph=pw和sh=sw。<br>多通道时：</p><p>池化层：</p><p>使用深度学习框架中内置的二维最大汇聚层，来演示汇聚层中填充和步幅的使用：<br>默认情况下，深度学习框架中的步幅与汇聚窗口的大小相同。 因此，如果我们使用形状为(3, 3)的汇聚窗口，那么默认情况下，我们得到的步幅形状为(3, 3)。<br>X = torch.arange(16, dtype=torch.float32).reshape((1, 1, 4, 4))<br>pool2d = nn.MaxPool2d(3)<br>Result:tensor([[[[10.]]]])<br>填充和步幅可以手动设定<br>pool2d = nn.MaxPool2d(3, padding=1, stride=2)<br>pool2d = nn.MaxPool2d((2, 3), stride=(2, 3), padding=(0, 1))<br>在处理多通道输入数据时，池化层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着池化层的输出通道数与输入通道数相同。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习</title>
      <link href="/2023/10/19/ReinforcementLearning/"/>
      <url>/2023/10/19/ReinforcementLearning/</url>
      
        <content type="html"><![CDATA[<p>强化学习是一类算法，使计算机实现从一开始什么都不懂，通过不断的尝试，从错误中总结经验，更新自己的行为准则，最后找到规律，学习实现目标的方法。例如Alpha Go。<br>那么计算机是通过什么样的方法来学习的呢？<br>计算机需要一位虚拟的好老师，这位老师比较吝啬，他不会告诉计算机如何行动，如何做决定。他为计算机做的事情只有给计算机的行为打分，而计算机要做的就是从老师打出的分数中学习怎么做决定，即记住那些会被打高分和低分的行为，并在下一个时间步中尝试用一个好的行为得到高分而避免低分。<br>比如老师会根据表情的高兴程度打分，当计算机给出一个高兴表情时会得到高分，而计算机给出一个难过表情时会得到低分。在开始时，计算机给出的表情近乎随机，而随着迭代的深入，计算机获得了这些被打分的经验，有了这些经验，计算机就能学会如果要得到一个好的分数，应该给出一个高兴的表情。</p><p>可见，在强化学习中，一种行为被定义的分数是强化学习的核心思想，即强化学习具有分数导向性。相比于监督学习在训练集中就给出了数据和标签，在强化学习中，所有的数据在开始时不会给予计算机任何标签，只有在计算机确定了某个数据输入后老师才会给出该输入对应的标签（或分数）让计算机学习。</p><p>单步更新效率更高，故通常使用单步更新</p><p>Pip/pip3 install gym</p><p>Q-Learning<br>Sarsa算法（实践派）：</p><p>R-Learning比较激进，而Sarsa比较保守</p><p>传统强化学习（Q-Learning和Sarsa）的问题是，随着时代的发展，一个模型的状态和行为会大量扩展，用表格的形式记录所有可能的状态和行为几乎已经成为了不可能的事情，例如Alpha Go学习下围棋。这就是为什么强化学习要和深度学习搭档，形成深度强化学习的Deep Q-Learning算法。将状态和行为输入神经网络输出行为的Q值，或者输入状态值得到该状态下所有行为的Q值并选择其中的最大值作为要做的行为。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/2023/10/19/MachineLearning/"/>
      <url>/2023/10/19/MachineLearning/</url>
      
        <content type="html"><![CDATA[<p>机器学习的两种主要类型是监督学习和无监督学习<br>监督学习给出了一组训练集，给定了样本输入和其对应的输出，机器在学习后得出一个函数，使之在之后给定任意输入时，都能自主预测一个合理的输出值。<br>监督学习的目的有两种：回归与分类。回归是预测给定输入对应的输出值，它是连续的、无限的，例如给定房屋面积预测房屋价格；分类是预测给定输入对应的种类，它是离散的、有限的，例如给定肿瘤大小预测肿瘤是否为良性。当然，监督学习也可能是多输入多输出系统。</p><p>线性回归：<br>一个最佳的拟合函数fw,b(x)，其对应的代价函数J(w,b)应当是(预测的结果-真实的结果)^2的均值的最小值，这说明拟合的效果足够好，足够接近真实值了。其中预测的结果-真实的结果代表了误差，平方是为了得到绝对正的误差累计，系数1/2是为了使得func不会随着训练样本的增大而急剧增大，同时方便后面梯度下降求导时把2约去使式子看起来更简洁。<br>这个形式的代价函数也被称为平方误差成本函数(square error cost function)。平方误差成本函数的特点是：它只存在一个局部最小值，且该局部最小值就是全局最小值。</p><p>以一个满足y=x的样本集为例，同时固定b=0。我们发现w的值对J(w)的影响如下图。</p><p>我们的目标就是得到一个w，使J(w)的值最小，在本例中即w=1。</p><p>综上，线性回归的基本内容就是：确定模型，根据代价函数得到最小值。</p><p>如果把b考虑进来，那么代价函数J(w,b)的图像应该就是一个二元函数在三维视图的图像：</p><p>同理，这个二元函数也会有一个最小值，我们的目标仍然是求解这个最小值时对应的w和b。<br>更进一步的，如果x是一个多变量的矩阵，那么此时的w也就是一个矩阵[w1,w2…wn]。<br>则此时的J(w,b)就可以写成J(w1,w2…wn,b)，对应的图像也会向更高的维度拓展。<br>接下来我们的目标就是，如何借助算法找到这个最小值，这个算法就是著名的梯度下降法。<br>梯度下降法的适用目标不仅仅在线性回归中，它可以用来尝试最小化任何函数。<br>梯度下降法的步骤如下：</p><p>梯度下降法的目的在于尝试找到任意函数的最小值。它的基本思路是，站在某点环视四方，找到该点下降率最大的方向（即梯度方向）前进一小步，再多次重复上一步骤，如此便有可能找到一个极小值。因此，我们需要开始时为梯度下降法确定一个起点w0,b0（可以任意确定，但可能影响结果），然后让w,b沿各自的梯度方向下降从而降低J(w,b)的值，如此循环直到我们找到或接近一个极小值。为什么要说是极小值而非最小值呢？因为这是梯度下降法的一个特性，当一个函数J(w,b)存在多个极小值时，梯度下降法往往会陷入其中一个极小值，而这个极小值不能被确保是最小值，具体陷入哪个极小值由往往起点和学习率决定。</p><p>梯度下降法的梯度更新过程如下所示：<br>分别对当前的J(w,b)求关于w和关于b的偏导，然后用偏导值乘以一个系数α后作为减数减小当前的w和b，这个系数α也被称为学习率，它的取值是[0,1]。它反映了梯度下降的速率，即梯度对w和b更新的影响程度。而后借助下述公式更新w和b，注意：w和b需要同步更新，即先求出更新后的w，b值再统一赋值给原来的w，b，这意味着在计算更新的w，b值时用的永远都是原来的w，b。下面给出了关于同步更新的正确与错误两种形式。</p><p>为什么这个公式能帮助我们找到局部最小值呢？我们来看下面只有w的例子：</p><p>可以看到，不论是位于局部最小值的哪端，梯度下降法总能帮助我们逼近局部最小值。</p><p>学习率α对梯度下降有很大影响，当α取值过小时，会导致梯度下降过程缓慢；当α取值过大时，梯度下降可能过冲，永远无法到达最小值，甚至可能无法收敛导致发散。</p><p>对于线性回归和平方误差成本函数而言，其偏导可以写作如下形式：</p><p>其推导过程如下所示：</p><p>事实上，对于任意凸函数J(w1,w2…wn,b)而言，其局部最优解是全局最优解，因而梯度下降法很适合求解凸函数的全局最小值问题。<br>补充一下关于如何判断一个函数是凸函数(convex function)：<br>　对于一元函数f(x)，可以通过其二阶导数f′′(x)的符号来判断。如果函数的二阶导数总是非负，即f′′(x)≥0，则f(x)是凸函数。我们可以从几何上直观地理解一元凸函数的特点，如下图所示：即凸函数的割线在函数曲线的上方。</p><p>　对于多元函数f(X)，可以通过其Hessian矩阵（Hessian矩阵是由多元函数的二阶导数组成的方阵）的正定性来判断。如果Hessian矩阵是半正定矩阵，则是f(X)凸函数。<br>对于非凸函数而言，梯度下降法可能会陷入其中某个极小值而非全局最小值，以下图为例：当函数进入局部最小值时，此时梯度为0，w和b将不再更新。</p><p>此外，梯度下降还分为批量梯度下降(batch gradient descent)和部分/小批量梯度下降(Mini-Batch)，批量梯度下降的每一步使用所有的训练集数据，而部分梯度下降的每一步只使用部分的训练集数据（通常是顺序选取一组完全不同的部分）。批量梯度下降寻找w,b的过程会比较准确，但当样本集m过大时求和过程会非常慢，导致批量梯度下降的时间成本很高；而部分梯度下降由于只采用部分数据，因此它的每一步在接近全局最小值时可能不够可靠甚至有些嘈杂，有时甚至会背离最小值移动，但它整体仍沿着趋向全局最小值的方向运动，部分梯度下降的优势在于当训练集m很大时，它仍然能以较快的速度完成每一步迭代（例如m=1亿而我每次只取m’=1000）</p><p>我们之前谈论的x只有一个，这也被称为单元线性回归；现在我们把它拓展为多元线性回归，直观上来看，就是一个结果取决于多个变量输入，而w则是各变量对于结果的权重。<br>仍以房屋价格为例，此时的模型可以写作：</p><p>我们可以发现，此时的w和x均为一个由各变量组成的向量：</p><p>于是我们就可以得到用向量表示的线性回归普遍公式：</p><p>对于多变量的表达式而言，我们通常对其进行矢量化(vectorization)：在python中我们利用numpy下的函数np.array和np.dot对其进行矢量化及运算，这不仅使得整个代码看起来更简洁，且由于numpy对于硬件的并行调用，整个代码的运行速度也会得到提升。</p><p>以一个不含b的多元线性回归J(w)为例，其中d表示w的偏导，学习率α取0.1：</p><p>我们可以发现，有没有进行矢量化的代码风格与效率之间相去甚远。<br>利用矢量化，则多元线性回归的表达式就可以改写为：</p><p>同理，我们把偏导公式在线性回归的转化加进来，记住对于wi的求解就是求出J对于各个wi的偏导，故各偏导的差别即为末尾对应的xi的差别：</p><p>事实上，解决线性回归还有一个方法被称为正规方程法(Normal Equation)，他可以不通过迭代就可以直接算出w和b的值，但它对于除线性回归以外的问题而言没有推广性，且当w的规模很大时计算会非常慢，因而正规方程法往往只会出现在机器学习库中用于实现线性回归，梯度下降法仍是寻找代价函数J最小值和对应的w和b的推荐算法。</p><p>接下来介绍一些小技巧，这可以帮助你更快更好的完成梯度下降过程：<br>1.特征缩放Feature Scaling：<br>重组规模RESCALE：当你有不同的变量x时，如果这些变量的取值范围相去甚远时，可能会导致梯度下降运行缓慢。首先我们要了解一个常识，当某个变量xi的取值都很大时，其对应的权重wi一般都会偏小，这会导致梯度下降过程中较难逼近这个wi，可能会反复横跳。<br>例如下面这个例子：假设房屋的面积x1通常取值在300-2000，而房屋卧室的数量x2通常取值在0-5，这就会导致w1非常小，难以完成梯度逼近。</p><p>解决方法也有很多，首先介绍的就是标准化方法，它将各变量的值除以它们的最大值从而得到一组取值范围均在[0,1]之间的变量向量，对应的RESCALE图如下所示，可以看到此时的梯度下降效果较好</p><p>其次要介绍的是mean normalization均值归一化，它先得到各变量xi的均值μi，而后对每个xi减去均值μi后除以他们最大值与最小值之差，得到的结果就是均值归一化的结果，这个值位于[-1,1]之间</p><p>最后要介绍的是Z-score标准化，它先得到各变量xi的均值μi和标准差σi，而后对每个xi减去均值μi后除以σi，得到的结果就是一个均值为0，方差为1的标准分布，也会比较小且均匀。</p><p>下面给出了一些适合与无需特征缩放的变量取值：</p><p>2.观察梯度下降过程是否收敛（梯度下降是否在帮你找到J的最小值）：<br>也介绍两种方法，一种被称为学习曲线J-k，它的纵轴是成本函数J的值，横轴是迭代次数k，如果我们发现随着k的增大，J不断减小且趋于平稳，则认为梯度下降过程收敛。</p><p>另一种方法是自动收敛测试，设定一个小量ε（比如0.001，实际上可以任意设置），当单次迭代J的变化小于这个小量时，认为梯度下降趋于收敛，但它的缺点在于如何选取ε以及结果不够直观，因而更加推荐使用学习曲线法。<br>当我们发现学习曲线随着迭代次数呈现往复摆动甚至快速上升的情况，这很有可能是学习率α过大导致的，此时我们应该减小学习率。</p><p>至于如何选择一个合适的学习率，可以采取以下方法：先取一个比较小的学习率，此时J的下降会非常缓慢；再取一个比较大的学习率，此时J会随着迭代往复摆动。则一个合适的学习率便介于[small,big]之间，且通常从big侧往小取可以得到一个不错的效果。</p><p>之前讲的都是线性回归，现实生活中的很多情况变量之间可能并不满足线性特征，这会导致使用线性回归无法得到一个好的效果，例如下面这组训练集：</p><p>这时候就要引入多项式回归(Polynomial regression)了，但在此之前，我们先来介绍一下特征工程(Feature Engineering)的概念，特征工程是将原特征变量进行数学变化或组合得到新特征变量的过程，特征工程的目的在于使特征方程更加符合数据集的拟合要求，而所谓的多项式回归，实际上是特征工程的一个特例，当线性回归fw,b(x)=wx+b效果不好时，我们通过对原变量x进行平方，立方，开放等特征工程操作，尽量使新方程更加符合数据集的拟合要求，而这种线性回归的特征工程结果就是多项式回归，典型结果如下：</p><p>值得注意的是，当使用多项式回归或特征工程产生次方项时，特征缩放就显得尤为重要了，因为假设原变量的取值为1-103，那么它的立方取值就要1-109了，这是不能被接受的。</p><p>逻辑回归：虽然它有回归regression二字，但它实际上用于解决分类classification问题，且专用于解决二元分类，所谓二元分类，即分类的结果只有两种，通常定义为0和1。对于二元分类，线性回归不是一个好的方法，我们介绍逻辑回归：<br>仍以肿瘤是否为阳性举例，我们期望的回归函数应当类似于下图：</p><p>如何利用这个连续的回归函数判断离散的结果呢？思路也很直白，就是当对应x的回归函数结果<0.5时返回0，>0.5时则返回1。这种类型的回归函数有一个名字被称为Sigmoid函数，它的函数表达式为：g(z)=1/(1+e^-z)，它的函数图像如下图所示：</p><p>可以看到，Sigmoid函数的一个重要特点在于不论z的取值如何，其结果总约束在[0,1]之间，<br>利用这个特点，我们可以把原先线性规划中的函数f(x)=[w][x]+b作为z代入到g(z)中，从而将一个无限变化的值限制在[0,1]之间，再利用四舍五入得到二元结果。需要指出的是，逻辑回归在四舍五入前的输出代表的意义就是二元结果取1的概率，而正是因此我们选择0.5作为结果变化的区分点。我们也把这个输出写作概率的形式：</p><p>由于这个预测结果仍是一个猜测值，故仍表示为hat{y}。<br>以Sigmoid函数作逻辑回归为例，当z=0时g(z)=0.5，而z=[w][x]+b，因而区分结果取0还是取1的关键就是[w][x]+b是小于零还是大于零。</p><p>由此我们引入决策边界(Decision boundary)的概念，所谓决策边界，就是g(z)=0.5，也就是Sigmoid函数下z=0时的各变量可能取值形成的边界线，整体的样本集被决策边界大致的一分为二，且可以认为在决策边界附近时，结果的取值是最不可信的而摇摆的。以线性回归的函数z为例，此时z=w1x1+w2x2+b=x1+x2-3，则决策边界为如下的一条直线，它将y=0和y=1明显的区分成了两部分。</p><p>当然，线性回归的直线边界有时候无法取得很好的效果，我们仍可以借助特征工程的理论来得到其他边界形式。对于多项式回归和非线性回归而言，决策边界也会变为曲线的形式。如下例中z=w1x1^2+w2x2^2+b=x1^2+x2^2-1，则决策边界为一个以原点为圆心，1为半径的圆。</p><p>同理，对于更复杂的多项式和非线性式，决策边界也会变得复杂，从而适配更加复杂的逻辑回归问题。</p><p>接下来梳理一下逻辑回归要实现的目标，作为监督学习中分类的一种，同样在给定一系列变量x和其对应的离散二元结果y作为训练集后，我们要确定w和b取何值时代价函数J最小。<br>借助Sigmoid函数定义的逻辑回归方程是：</p><p>这个方程的意义就像线性回归中的fw,b(x)=wx+b，是逻辑回归得到的用于拟合数据的曲线，只不过其结果还要与0.5做比较来得到最终结果究竟是取0还是取1。<br>同理，逻辑回归也会有它相应的成本函数，可以发现平方误差函数不适合在逻辑回归中承担成本函数的责任，因为它在逻辑回归中非凸，会出现很多局部最小值，不利于梯度下降算法。<br>逻辑回归的代价函数如下，它是由最大似然估计法(Maximum Likelihood)证明的，其中L(f,y)是单个样本的损失函数(Loss Function)：<br>注意：这里的log是数学意义上的ln。</p><p>我们来分析一下这个函数，首先看看单个样本损失L的定义。它在坐标图L-f下的形状如下图所示，由于f的取值范围在[0,1]之间，所以只取[0,1]部分绘制：</p><pre><code>          if y=1                              if y=0</code></pre><p>可以看到，当样本结果为1时，函数fw,b(x)越接近于1损失L就越小；同理当样本结果为0时，函数fw,b(x)越接近于0损失L就越小。由于fw,b(x)即预测结果的函数，如果预测的结果越接近于实际的样本结果，那么其损失自然就越小，将所有的损失L取均值得到代价J，那么J的最小值就是样本集的各样本损失L总和的最小值，损失总和越小代表着总体的预测结果越接近于总体的真实结果，通过这种方法调整w和b使J趋向于最小值，从而得到一条最佳的预测曲线fw,b(x)。<br>由于y只能取0或1两个值，我们可以利用变换将L从条件式变为复合式如下：</p><p>则代价函数便可以写作：</p><p>数学上可以证明，这个代价函数J仍然是一个凸函数。要得到这个代价函数的最小值，方法仍然是梯度下降法：</p><p>偏导值的详细推导如下：</p><p>我们有一个发现，逻辑回归的梯度下降公式竟然与线性回归一模一样！这意味着在计算梯度下降时，可以使用同一套公式和代码进行迭代求解。<br>在进行逻辑回归的时候，观察学习曲线判断梯度下降收敛、向量化、特征缩放等方法仍然是通用的，可以借鉴线性回归的相关理论。</p><p>以上便是线性回归和逻辑回归的大致内容了。回顾一下，线性回归用于解决回归问题，而逻辑回归用于解决分类问题，二者同属于监督学习的范畴，那么两者也会出现很多类似的问题。<br>一个问题就是预测曲线的欠拟合(underfit，也被称为高偏差high bias)和过拟合(overfit，也被成为高方差high variance)问题：所谓欠拟合，一般是特征变量的个数或维数过低，导致特征方程（拟合曲线或是决策边界）为一条直线，难以拟合一些复杂的非线性变化；所谓过拟合，一般是特征变量的个数或维数过高，导致特征方程极力的想去完美适配样本集的所有样本，此时虽然对于样本集内的数据特征方程适配的很好，但当它预测新的例子时就变得很难推广。因此，一个合理的拟合应该既不错的适配样本集的数据，当新的例子引入时，又要能够很好的预测该例子对应的输出结果。</p><p>解决过拟合通常有以下几种方法：获取更多的样本数据，减少特征变量的个数或阶数（这也被称为特征选择Feature Selection），还有一种比较好的方法称为正则化(Regularization)，对于一个高阶的特征方程产生的过拟合而言，通常是由于高次项占比过大导致的，减少特征变量的个数或阶数事实上就是将原特征方程的高次项系数置0了，事实上，我们可以将这个过程变得更温和一点，即通过减小高次项的系数，在保留高次项作用的同时又让高次项不会过分影响特征方程的形状产生过拟合，这项技术就被称为正则化。正则化实际上就是改变系数权重w1-wn的过程，而b是否要发生改变则无关紧要，故多数情况下不选择改变。<br>下图是采用正则化后线性回归拟合效果的改变，可以看到过拟合现象得到了很好的缓解：</p><p>正则化作为一个通用方法，也可以作用于解决欠拟合问题，增加特征变量的个数和阶数的过程可以看做是正则化增加高次项系数的结果。在之前的讨论中我们知道了，如果要防止出现欠拟合和过拟合的现象，对于高次项的系数设置应该不能过小(0)也不能过大(1000)，而对于给定特征变量个数与阶数的特征方程而言，系数的设置不会过小而只会过大，且对于复杂的特征方程，难以找到影响拟合结果的重要特征，因此，实现正则化时，我们通常考虑整体缩减（也叫惩罚）所有的权重wj，这通常会使曲线变得更加平滑而不易过度拟合。<br>那么如何用数学语言描述正则化方法的这个惩罚过程呢？其实也很简单，那就是在代价函数J中加一项惩罚项即可，惩罚项由各权重wj的平方和乘以系数组成，有了惩罚</p><p>项，J在梯度下降过程中如果尝试增大w来降低J，那么就会受到惩罚项惩罚使J增大，从而限制算法在使J下降时不要过度增加w。其中λ是惩罚系数，它和学习率α一样由人为设置，决定了代价函数对正则化的重视程度，λ越大，代价函数就越重视正则化。<br>于是，正则化线性回归问题的代价函数就是下式：其中m是样本数量，n是特征变量数量</p><p>而要找到这个代价函数的最小值，其方法仍然是梯度下降，且公式基本不变，只是在求解w的偏导时，需要额外对惩罚项求偏导，因而其迭代公式如下：</p><p>同理，我们也可以得到逻辑回归问题的代价函数：</p><p>而由于线性回归和逻辑回归的代价函数梯度下降算法一样，因而正则化后的线性回归和逻辑回归的代价函数梯度下降算法也是一样的，请参考正则化线性回归的梯度下降公式。</p><p>接下来要讲的就是机器学习中最重要的知识——神经网络（也叫多层感知器）了：<br>神经网络最初是一个生物学的概念，一般是指大脑神经元、触点、细胞等组成的网络，用于产生意识，帮助生物思考和行动，后来人工智能受神经网络的启发，发展出了人工神经网络。<br>人工神经网络（Artificial Neural Networks，简写为ANNs）是一种模仿动物神经网络行为特征进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。神经网络的分支和演进算法很多种，从著名的卷积神经网络CNN，循环神经网络RNN，再到对抗神经网络GAN等等。<br>无论是在学习机器学习还是深度学习时，我们都会频繁接触神经网络这个词，人工智能、机器学习、深度学习、神经网络这几个概念之间的关系图如下图所示。</p><p>随着要处理数据和变量的增大，传统的人工智能学习算法（线性回归和逻辑回归）的表现将远远弱于神经网络，而在当前这个大数据时代且随着GPU的发展，神经网络正大展宏图。</p><p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元，activation unit）采纳多个特征作为输入，并且根据本身的模型提供一个输出。事实上，神经元相比于大脑的神经元而言是一个极其简化的模型，但它确实能让神经网络发挥的足够出色。神经元的数学模型如下，可以把它理解为一个多输入单输出的函数单元。</p><p>这个函数具体的选择有很多，例如我们之前学过的sigmoid就可以作为单个神经元的函数，之后也会再介绍几种，但函数的自变量通常都是由输入变量与权重的矢量相乘[z]=[w][x]+[b]。通常，我们也把神经元的输出成为激活(activation)。<br>而神经网络就是由一系列不同功能/函数的神经元以一定的结构层次排列组合而成的网络。<br>我们把一组在功能上相同或是输入相似特征的神经元聚合在一起称为神经网络的层(layer)，将接受输入的层称为输入层，输出结果的层称为输出层，中间各类转换和处理的层称为隐藏层。我们一般把输入层作为layer0，而之后的层则依序递增。上层神经元的输出（或是激活）会成为下层神经元的输入。神经网络的层数计算不包括输入值和输出值。</p><p>我们以一个判断一件T恤是否会成为爆款的神经网络为例来看看其基本组成，图中的各神经元函数均为sigmoid函数，至于为什么这样选之后会介绍：<br>可以看到，作为一件T恤，决定它是否会成为爆款的直观输入可能包含价格、运输成本、市场营销和材质四个方面，而输出则是它成为爆款的概率。我们发现，输入与输出之间并没有直接联系，因而我们可以引入中间变量可负担能力，知名度和质量来作为一层隐藏层。可负担能力接收价格和运输成本经过sigmoid函数输出可负担能力造就爆款的概率，知名度接收市场营销经过sigmoid函数输出知名度造就爆款的概率，质量接收价格和材质经过sigmoid函数输出质量造就爆款的概率，而后这三个激活再作为输出层的输入经过sigmoid函数得到综合造就爆款的概率。<br>如果我们把左边的输入遮住，只看可负担能力，知名度和质量就可以发现，其实这个神经网络的右边部分就是这三个变量的逻辑回归。其实这个神经网络就像是逻辑回归，只不过我们把逻辑回归中的输入向量x变成了中间层的a，我们可以把a看成由x进化而来的更为高级的特征值。由于梯度下降会将a是变得越来越厉害而精确，这些更高级的特征值远比仅仅将x次方（做特征工程）厉害，也能更好的预测新数据。这就是神经网络相比于逻辑回归和线性回归的优势。神经网络的本质仍然是根据输入预测输出，而中间层产生的各变量（也就是可负担能力，知名度和质量），事实上完全由神经网络自身进行分析与处理，不劳我们费心。</p><p>在实际的神经网络中，由于我们一般难以判断隐藏层的各神经元需要的输入具体与哪个原始输入变量有关，故事实上我们会让神经元与每个原始输入量挂钩，而将具体的取舍判断交由神经网络自身决定，这也是为什么每层的如下图所示：</p><p>进一步地，写作向量形式如下：</p><p>将神经网络各层的输入输出矢量化后，我们引入更多的表示概念：</p><p>把layer l的输入记为矢量a[l-1]，输出记为矢量a[l]，输入的权重矢量记为w[l]，偏差矢量记为b[l]，每层神经元的函数记为g。如果要表示矢量里的某个值，即一层中某个神经元的输入输出结果，则用下标表示该神经元位置，上标表示该神经元所在的层，即aj[l]等。则任意某个神经元的函数表达即为下式：</p><p>接下来我们来介绍一下神经网络前向传播(Forward Propagation)的概念： 所谓神经网络的前向传播，即从神经网络的第一层开始正向一层一层进行计算，直到最后一层。利用输入x依次得到a[1],a[2]一直到输出a[k]，这通常是为了利用输入计算神经网络的预测结果和手动构建神经网络。对于一般的神经网络而言，每层神经元的数量通常是逐层递减的。</p><p>如何在代码中构建神经网络呢？我们将按照普通-&gt;矢量-&gt;函数的方法循序渐进的介绍：<br>普通：如下图所示，假设神经元函数均为sigmoid函数，为了搞清楚前向传播的流程，我们这里直接给定每层每个神经元的[w]和[b]而不通过学习得到，同时我们给定输入层变量[x]，从而得到该神经元的[z]和激活[a]，最后将该层所有神经元的[a]组合得到该层的[a]，将这个[a]作为下层的输入重复这个过程。</p><p>矢量化：在之前的学习中我们知道了，利用矢量运算能大大加快代码的运行速度，在普通的代码中，我们处理的内容都是一维向量，而事实上，我们可以把每一层的参数都组合成一个矩阵形式，如下图的[W],<a href="也就是[X]">A</a>和[B]，其中[W]的每列都表示该层一个神经元的权重[w]，[B]的每列都表示该层一个神经元的偏差[b]，则该层所有的激活输入[Z]=[AT][W]+[B]，其中矩阵乘法在Python中使用matmul实现，该层所有的激活就是[A]=g([Z])。利用矢量化，原来复杂的代码就变得既简洁又高效了。</p><p>函数：以上两个构建方法只是为了熟悉神经网络的构成，同时了解矢量化的优点。实际构建神经网络时，我们不可能一开始就知道[W]和[B]的具体取值，而是需要通过学习得到。事实上，PyTorch和TensorFlow已经为我们提供了一系列成熟的机器学习所需函数，真正使用时只需要调用它们提供的函数就可以了。得到一个神经网络的基本过程有以下三步：<br>1.构建架构：Dense规定了一层神经元的数量和该层神经元使用的激活函数（一般同一层的神经元都使用同一种激活函数），Sequential规定了哪些层会被顺序连接成一张神经网络。<br>2.定义代价函数和损失函数： 将得到的神经网络model利用方法compile(…)定义损失函数，格式是loss=损失函数，例如loss=BinaryCrossentropy()表示使用逻辑回归的损失函数（二元交叉熵），或是loss=MeanSquaredError()表示使用线性回归的损失函数（平方误差函数）。损失函数针对的目标即神经网络前向传播得到的输出y与输入x之间的关系式。<br>3.确定样本集：将输入x和输出y以np.array的形式赋值<br>4.训练神经网络：利用函数fit(x,y,epochs)来训练，其中x是输入，y是输出，通过训练可以确定神经网络各层的[W],[B]参数，而神经网络就是通过其各层各神经元的w和b来构建起一个庞大的预测模型的，可选参数epochs=K限制最大迭代次数为K次。初始化[W],[B]参数的方法一般是令[B]=0，[W]为一个很小的随机值（如0.01），而一般的训练或学习方法依然是对代价函数使用梯度下降法（事实上，是采用梯度下降法的变体Adam算法），而计算梯度下降法中的偏导项使用了神经网络反向传播算法(Back Propagation)，如何在神经网络中使用梯度下降法（Adam算法）将会马上说明。<br>5.进行模型预测：训练完毕后，当传入新的输入x_new时，就可以使用方法predict得到该输入的预测输出。</p><p>我们对比逻辑回归和神经网络，事实上两者都有经历根据输入计算输出的建模过程，确定损失函数和代价函数的过程，以及确定参数w和b使损失最小的过程。</p><p>到目前为止，我们一直在隐藏层和输出层的所有节点中使用sigmoid激活函数。事实上，我们还有很多其他激活函数可用，这些激活函数适合不同的使用场合。<br>三大主流的激活函数如下，分别是线性激活函数，sigmoid激活函数和ReLU激活函数：</p><p>1.线性激活函数：a=g(z)=z，线性激活函数也可以看作是不使用任何激活函数<br>2.sigmoid激活函数：g(z)=1/(1+e^-z)，值介于(0,1)之间<br>3.ReLU激活函数：g(z)=max(0,z)，值介于(0,+∞)之间<br>在后面我们还会学到一个叫softmax的激活函数，它通常用于多元分类问题。<br>那么如何进行激活函数的选择呢？我们分别对输出层和隐藏层探讨：<br>输出层选择：</p><p>输出层的激活函数选择其实非常有规则性，由于输出结果与其输入之间必然蕴含着一个规划问题。于是当输出y是一个二元分类问题时，输出层的激活函数显然要选择sigmoid激活函数；当输出y可以取正或取负时（股票的涨跌），输出层的激活函数显然要选择线性激活函数；当输出y只能取正数时，输出层的激活函数显然要选择ReLU激活函数。<br>隐藏层选择：<br>事实证明，隐藏层的激活函数几乎都会选择ReLU激活函数，为什么呢？<br>对比ReLU和sigmoid激活函数，首先ReLU的函数形式比sigmoid更简单，这意味着计算会更快；此外，由于sigmoid在首尾斜率几乎为0，这会导致代价函数J在多处比较平，这意味着有很多偏导很小的段，这会导致在使用梯度下降法寻找最小值时，会迭代很多次而下降的非常慢。因此，ReLU比sigmoid激活函数更适合做隐藏层的激活函数。</p><p>而由于线性激活函数表示不使用任何激活函数，故如果我们对所有的神经元都使用线性激活函数，整个大型的神经网络就会变成一个普通的线性回归问题。以下面这个例子说明，可以看到，输出a[2]和输入x之间就是一个线性关系a[2]=[w][x]+[b]。这就破坏了构建神经网络的全部目的，这也是为什么激活函数对神经网络这么重要的原因。</p><p>故综上，在隐藏层我们通常选择ReLU激活函数，少部分选择sigmoid激活函数，而几乎不在隐藏层中使用线性激活函数。<br>于是我们如果要构建一个二元分类问题的三层神经网络，一个典型的构架如下程序所示：</p><p>多元分类问题：即现在的输出y可以取多个离散的值，例如识别手写数字0-9。<br>多元分类是二元分类逻辑回归的推广，输出层使用Softmax函数作为激活函数。<br>Softmax激活函数的公式为如下：</p><p>也就是：</p><p>可以看到它是把要计算概率对应的e的z次方除以所有e的z次方得到结果。<br>易得有结果：a1+a2+…+an=1，符合概率分布。<br>以四元分类为例，此时的输出[a]=[a1,a2,a3,a4]分别是y=1,2,3,4的概率：</p><p>Softmax对应的损失函数是（log对应数学里的ln）：</p><p>由于aj表示了预测y=j的概率，故当y的真实值就是j时，就可以使用-log(aj)表示预测的损失，当aj越大时预测认为y=j的概率就越大，而当y真的为j时，损失就会越小；当aj越小时预测认为y=j的概率就较小，而结果说明y真的为j，那么损失就会较大。这就是Softmax如此规定损失函数的原因。<br>这个损失函数在TensorFlow里称为SparseCategoricalCrossentropy，于是构架代码如下：</p><p>为了提高精度，实际构建代码时我们可以使能可选参数from_logits，这个参数的功能在于它将输出层的激活函数与损失函数合二为一了，假设输出层的输入为z，输出为a，则原来的流程是利用激活函数得到a=g(z)，再对a求损失函数。利用from_logits=true，此时TensorFlow会直接把z作为损失函数的输入，没有了中间变量a运算会变得更精确，如下图所示：</p><p>于是此时的代码框架如下所示，注意由于激活函数与损失函数合二为一了，因此输出层的激活函数直接用线性激活函数起传递作用即可，代码会自行根据使用的损失函数判断输出层会使用什么函数激活z从而代入损失函数中。此外，由于此时的输出值本质上是z而非a，因此之后在预测得到输出后还应该对其做一次输出层激活（例如下图中的softmax函数）</p><p>之前介绍了多元分类问题(Multi-Class Classification)，这里再介绍多输出分类问题(Multi-Label Classification)。多输出分类问题解决针对同一输入而有多个输出的情况，例如给出一张图片，我们要判断里面是否有小轿车，是否有公交车，是否有行人。注意：这三个是非判断相互独立，也就是说这张图片里可能同时有小轿车、公交车和行人。针对这个问题，我们当然可以分为三个独立的二元分类神经网络分别判断，但多输出神经网络给了我们一个集成的机会，此时我们只需将输出层变为三个神经元即可，输出层输出的是一个含有三个特征的矢量。而后对输出层的每个神经元都使用sigmoid函数激活，其效果就等同于三个独立的二元分类神经网络了，而效率显然比三个独立的二元分类神经网络高。</p><p>对应于多输出分类问题的代价函数为（L为损失函数，m为样本数，以四输出分类问题为例）：</p><p>多输出分类问题适用于不同输出之间可以共用低层级特征的神经网络，例如共用图像识别。</p><p>在神经网络的早期实现中，人们仍然使用梯度下降法来最小化成本函数，但随着时代的发展，人们发现了一种被称为Adam(自适应矩估计Adaptive Moment Estimation)的优化算法来最小化成本函数，而其效果会比梯度下降法快很多，而因此成为训练神经网络的优异算法。<br>Adam算法通过随着优化进行自动改变学习率α入手来优化梯度下降法：</p><p>Adam算法发现，当wj和b在优化过程中始终沿着近似同一方向改变时，这意味着我们走的每一小步都朝着相似的方向迈出，这可能是α比较小的结果，既然如此，我们把学习率α变大就可以更快的达成目的了；反过来，当wj和b可能在优化过程中在谷底附近左右振荡无法收敛时，可能是α比较大，既然如此，我们把学习率α变小就可以完成收敛了。这就是Adam算法自适应改变学习率α的基本思路，实际算法比较复杂，在这不作说明。由于Adam算法的自适应性，我们可以预见，对于不同的wj和b，Adam算法给出的学习率α也就不是同一个值了，也就是α并不是一个全局的单一值而是随j变化的αj。<br>接下来给出Adam算法的代码实现，在compile方法里，除了指出损失函数loss外，还要给出优化算法optimizer并规定为Adam(learning_rate=…)，其中learning_rate是学习率的初值。</p><p>我们之前应用的神经网络层都是一种被称为密集层(Dense Layer)的网络层，密集层中的每个神经元都能得到它上一层所有的激活作为本层的输入，但事实上，网络层还有很多其他类型。卷积层是另一种比较常用的网络层，相比于密集层可以得到上一层的所有激活作为输入，卷积层的每个神经元只能上一层的部分激活作为输入，换句话说，卷积层的每个神经元只能看到上一个网络层的一部分，这会导致神经网络具有更快的运行速度且只需更少的训练数据。<br>下图可视化了一个卷积层，其中每个神经元只能看到上个网络层中对应色块的数据。</p><p>由卷积层组成的神经网络被称为卷积神经网络，以下图为例，我们给出一百个输入数据传入第一个有9个神经元的卷积层，其中每个神经元只看得到20个数据，而后第一层输出一个9列的列向量到第二个有3个神经元的卷积层，其中每个神经元只看得到5个数据，而后第二层输出一个3列的列向量到输出层做sigmoid函数得到输出。</p><p>卷积层相比密集层而言多了一个架构选择，即每个神经元窗口开的大小。<br>接下来我们看看如何评估你建立的模型的好坏。对于二维和三维模型，可以直接通过绘图来直观的判断模型效果，但对于更高维度的系统而言，我们就必须提出一个更加数学化的公式来定量的判断模型的好坏。为了在应用模型预测新输入前判断模型的好坏，我们可以把原训练集拆分为训练集(Training Set)和测试集(Test Set)两部分，比例一般为70%-30%。其中训练集专门用来训练神经网络得到[w],[b]，测试集专门用来测试得到的神经网络在预测新输入时的效果。</p><p>于是此时计算代价函数J(w,b)时，其求和项便是训练集总数mtrain。<br>对于线性回归而言，其代价函数如下：<br>同时我们定义测试集误差Jtest(w,b)和训练集误差Jtrain(w,b)分别代表训练的神经网络对新输入的适应程度和对训练样本的适应程度，在线性回归下的公式分别如下，均为对应集合的预测值减去实际值的平方均值：</p><p>同理，我们也可以得到逻辑回归的代价函数，以及其测试集误差和训练集误差如下：</p><p>一般而言，由训练集得到的模型，其训练集误差Jtrain(w,b)会比未来输入的预测结果误差小。而未来输入的预测结果误差通常可以由测试集误差Jtest(w,b)来表示，因为Jtest(w,b)不参与模型训练，因而其值可以用来当作未来输入进行预测。<br>更进一步地，如果我们想要系统自动选择一个好的模型来进行机器学习，例如我们在拟合点的时候，到底应该选择几阶多项式呢？一个选择是根据不同阶的多项式利用训练集拟合，并查看测试集误差Jtest(w,b)，选择最小的测试集误差对应阶数的多项式认为是最好的模型。但这样子我们就失去了测试集误差测试模型的作用，事实上，我们不应该让测试集参与任何形式的模型建立以确保测试集的完全中立。而要实现这个效果，我们可以将样本总集额外再多分一个部分，变为训练集、测试集和交叉验证测试集(cross-validation set)三部分，比例一般为(60%-20%-20%)。其中训练集专门用来训练神经网络得到[w],[b]，交叉验证集专门用来决定用什么模型来进行机器学习，测试集专门用来测试得到的神经网络在预测新输入时的效果。<br>此时除了定义测试集误差Jtest(w,b)和训练集误差Jtrain(w,b)外，还要定义交叉验证误差Jcv(w,b)</p><p>把待选模型按照训练集均训练一遍，取之中交叉验证误差最小的认为是最好的模型，采用此模型下训练集的训练结果作为最后的应用模型，并使用测试集来观测其对新输入的适应程度。<br>这里的模型是一个宽泛概念，既可以用于选择拟合多项式，又可以在待选的神经网络中选择最佳的一个等。</p><p>利用测试集误差Jtest(w,b)，训练集误差Jtrain(w,b)和交叉验证误差Jcv(w,b)，我们可以判断一个系统是否存在过拟合和欠拟合的问题，对于欠拟合的系统，训练集误差Jtrain(w,b)和交叉验证误差Jcv(w,b)都会非常高；对于过拟合的系统，训练集误差Jtrain(w,b)会非常低，但交叉验证误差Jcv(w,b)会非常高；对于良好的系统，训练集误差Jtrain(w,b)和交叉验证误差Jcv(w,b)都会非常低。</p><p>随着拟合多项式阶数的提高，训练集误差Jtrain(w,b)和交叉验证误差Jcv(w,b)会呈现以下趋势，在Jcv(w,b)取最小值认为系统有最佳效果：</p><p>同理，交叉验证误差Jcv(w,b)也可以被用于判断正则化项系数λ的选择，其基本流程仍然是把参数λ的待选集合按照训练集均训练一遍，取之中交叉验证误差最小的认为是最好的模型，采用此模型下训练集的训练结果作为最后的应用模型，并使用测试集来观测其对新输入的适应程度。随着λ的提高，训练集误差Jtrain(w,b)和交叉验证误差Jcv(w,b)会呈现以下趋势，因为λ的增大会导致w的减小，从而从过拟合问题过渡到欠拟合问题，这会导致Jtrain(w,b)的增大，以及Jcv(w,b)会先减小后增大，这代表着拟合效果会先变好再变差（过拟合-&gt;良好-&gt;欠拟合），在Jcv(w,b)取最小值认为系统有最佳效果：</p><p>那么如何判断测试集误差Jtest(w,b)，训练集误差Jtrain(w,b)和交叉验证误差Jcv(w,b)是高还是低，我们通常会制定一个用于性能评估的基准，例如人类完成该任务的能力，或是同类算法的表现，或是根据经验猜测。则此时的高低是基于基准的相对值，如下图所示：</p><p>判断一个系统性能是否良好也可以使用学习曲线，学习曲线是训练集误差Jtrain(w,b)和交叉验证误差Jcv(w,b)关于训练集规模mtrain的函数。<br>一个良好的模型，其学习曲线呈现如下趋势：随着m的增大训练集误差Jtrain(w,b)会上升，交叉验证误差Jcv(w,b)会下降，且两者会随着m的增大趋近于比较基准。</p><p>欠拟合：如果学习曲线随着m的增大训练集误差Jtrain(w,b)上升不大，交叉验证误差Jcv(w,b)下降不大，且两者都远高于比较基准，则此时算法可能存在欠拟合问题。因为欠拟合时可以调整的变量有限，故训练集的增大并不能让结果更好的拟合数据。</p><p>过拟合：如果学习曲线随着m的增大训练集误差Jtrain(w,b)会上升，交叉验证误差Jcv(w,b)会下降，且训练集误差Jtrain(w,b)远低于比较基准，交叉验证误差Jcv(w,b)远高于比较基准，则此时算法可能存在过拟合问题。因为过拟合会导致训练集误差很低，但对于其余数据适配度不高。同时可以发现，随着m的增大，过拟合有所缓解，这是因为训练集样本比较大时可以纠正算法过于执着于拟合经过几个点的情况。</p><p>学习曲线需要不断的选取训练集子集进行绘制，因而存在运行速率慢的特点。</p><p>修正过拟合可以采取以下方法：                修正欠拟合可以采取以下方法：<br>1.给予算法更多的训练集数据                    1.增加特征的维度和数量<br>2.降低特征的维度和数量                        2.尝试降低正则化系数λ<br>3.尝试提高正则化系数λ</p><p>故训练一个算法或神经网络的一般步骤如下，当训练集误差Jtrain(w,b)较大时，系统可能存在欠拟合问题，于是可以扩大神经网络解决欠拟合问题；当交叉验证误差Jcv(w,b)较大时，系统可能存在过拟合问题，于是可以给予算法更多的训练集数据解决过拟合问题。</p><p>事实证明，一个良好正则化的大型神经网络，其效果一般都会比小型神经网络效果好，故不必过于担心扩大神经网络可能导致的过拟合问题。<br>用代码为神经网络层添加正则化项的方法是在Dense中增加一项kernel_regularizer=λ即可。</p><p>机器学习的开发迭代满足以下逻辑闭环：Loop(选择模型和数据，训练模型，利用性能指标的判断方法诊断模型性能)</p><p>当训练出的模型效果不佳时，此时可以启用误差分析。所谓误差分析，即人类在系统判断错误的样本中抽取一部分来观察出错的原因，并取其中占比较大的优先解决。我们可以为样本集添加大量由最大原因导致的同类错误样本来集中训练神经网络在这方面的缺陷。误差分析适合该任务人类擅长时，可以作为指导方向的参考，避免花了大量精力解决了一个可能不是那么重要或者占比不是那么大的出错原因。</p><p>接下来我们来看看如何在有限的样本集中添加数据的方法：<br>对于视觉识别或语音识别等神经网络，我们可以对图片进行旋转，放缩，扭曲，添加噪声等来对一个示例提出更多具有类似标签的新示例。同理我们也可以对语音识别的原始语音添加背景噪声来提出新示例。</p><p>但是有一个要注意的事项，如果你只是为神经网络添加一些完全随机而无意义的样本，这并不会让神经网络表现得更好，即利用这种方法添加样本时必须基于原有样本。<br>事实上，现代的神经网络反而更看重训练数据而非算法和模型了。<br>迁移学习：对于数据很难获得、变换或添加而没有那么多数据的神经网络，迁移学习可以帮助你使用来自不同任务的数据来完善你的神经网络。例如我想识别手写数字0-9，但我没那么多样本，但我有一组很大的关于猫、狗、汽车、人等的样本集，比如说100万张具有1000个不同类别图像的样本集，此时我可以直接使用这个样本集先训练一个分辨这1000个种类的神经网络得到一组[w],[b]数据，而后将这个神经网络整体迁移到我的训练集中，而只需改变神经网络的输出层（从1000个输出变为10个输出），则非输出层的[w]和[b]的初值就是已训练好的神经网络非输出层的参数，而输出层的[w]和[b]需要用自己的训练集重新训练。对于极小的训练集而言，可以保持非输出层参数不变而只训练输出层参数；对于稍微大一点的训练集而言，可以训练所有参数，其中非输出层参数的初值为已训练好的神经网络非输出层的参数。</p><p>于是迁移学习的步骤一般为：先利用大型训练集进行神经网络的预训练，再使用自己的训练集对参数进行微调，微调方法无异于梯度下降法或Adam算法。<br>迁移学习的原理在于，对于输入类型相同的样本集来说，每一层神经网络（尤其是底层）做的事情会被训练的几近相同，例如图像识别中的第一层往往会识别物体的边，第二层识别物体的角，第三层识别曲线和基本图形，而这些不论在数字还是物体中都是非常通用的图像特征，正是因此我们可以使用图片来预训练神经网络用于识别数字，而只需要进行部分微调就能实现一个很好的效果。不过这也告诉了我们，迁移学习的输入种类必须相同，例如图像识别要用图片集，语音识别要用音频集，但两者不能混用，这是因为只有相同类别的神经网络才具有相似性和可转移性。</p><p>接下来介绍一下精确率和召回率(Precision and Recall)的概念，对于存在极为罕见情况或二元可能差别极大的二元分类而言（例如监测患者是否患有某种罕见病），对于这样的系统而言，判断系统的好坏就不能用一个简单的“准确率”来概括了，事实上，如果我们把所有输入的患者都标记为没病，则系统的“准确率”依旧很高，但这不能说明这是一个好的预测系统。<br>对于这种系统而言，我们一般将其分为四种类型，把hat{y}=1且y=1的称为True Positive类（即正确预测阳性），把hat{y}=1但y=0的称为False Positive类（即错误预测阳性），把hat{y}=0但y=1的称为False Negative类（即错误预测阴性），把hat{y}=0且y=0的称为True Negative类（即正确预测阴性），同时我们假设y=1为罕见类。以阳性为例，预测结果的精确率被定义为正确预测阳性的数量/预测阳性的总量，预测结果的召回率被定义为正确预测阳性的数量/实际阳性的总量。一个良好的模型应该同时具有不错的精确率和召回率，而像我们之前说的那个系统，虽然预测y=0时具有良好的精确率和召回率，但y=1时由于正确预测阳性的数量=0，故精确率和召回率都为0（定义0/0=0），模型自身的问题便暴露无遗了。</p><p>事实说明，精确率和召回率两者不能兼得，又或者说两者侧重于系统的不同方面。仍拿罕见病作为例子，如果我们希望具有十足把握时系统才预测y=1，此时我们可以将逻辑回归的阈值从0.5上调到0.8甚至0.9，即只有系统认为有80%-90%概率该患者患有罕见病时才预测其有罕见病，这种情形一般出现在治疗需要花大量金钱且保守治疗效果不差时，此时系统的精确率会提高，因为预测阳性的条件更为苛刻了，但系统的召回率会降低，因为会有很多系统认为概率不那么高但实际为阳性的病例被忽略掉了。反之，如果我们希望系统宁可杀错，不可放过的话，此时我们可以将逻辑回归的阈值从0.5下调到0.3或0.2，即只要系统认为有20%-30%概率该患者患有罕见病时就预测其有罕见病，这种情形一般出现在如果患病则可能危及生命时，此时系统的精确率会下降，因为会预测错误很多实际上没患病的患者，但系统的召回率会提高，因为预测阳性的条件比较宽松，大部分患病的患者都会被检测出来。<br>事实上，精确率和召回率之间的关系随阈值的改变呈现如下趋势，阈值较高必然带来预测率的提高和召回率的下降，阈值较低必然带来预测率的下降和召回率的提高，而要想确定这个阈值究竟取何值，既可以手动根据精确率-召回率曲线结合实际需求观察，也可以自动确定：</p><p>如果想要自动确定阈值，一般是取精确率和召回率的调和平均数(F1 score)最高者。记精确率为P，召回率为R，则F1 score的公式如下图所示，调和平均数会避免P和R之中某个值过小，即对应精确率或召回率过小的系统，这样的系统不是一个好系统。</p><p>决策树(Division Tree)：接下来我们将学习另一种高级机器学习算法称为决策树，同样我们也要给定一组包含输入与输出的样本集，而决策树的各个非叶节点就是样本集的每种输入变量，这个输入变量既可以是离散的，也可以是连续的，决策树根据这个输入变量的某种区别将整个样本集分为左右两个子树，而这两个子树的根节点就是该输入变量，再对每一个子树也做如上递归，以此类推，直到满足终止条件（关于终止条件会在之后讨论）时，将仍在一起的一群样本归为一类放到叶子结点，并成为未来可能输入的预测输出。<br>我们以一个给出动物的耳型、面部和是否有胡须判断该动物是否为猫的决策树为例，由样本集训练得到的决策树如下所示，未来预测新输入是否为猫时也按照下述决策树的步骤一步步从根节点走到叶子结点，直到判断完成：</p><p>决策树学习算法：在所有可能的决策树里，尝试选择一个在训练集中表现良好，且具有推广性的最优决策树。<br>那么如何得到一棵最优决策树呢？<br>我们先来引入纯度(Purity)和熵(Entropy)的概念：纯度是一个子集同属某种类型（叶子结点）的程度，熵是一个子集分属不同类型的程度，可以认为纯度和熵是一对相反的概念。一棵最佳决策树的每一次节点分裂，不是任取某个特征就进行分裂，应当是选取能将所有的样本分割成两部分熵较小，纯度较大的样本子集的特征进行分裂。而当一个节点中的所有样本同属某种类型时（纯度为1，熵为0）时，我们就找到一个叶子结点，于是停止分裂这一节点。由于实现一个节点中的所有样本同属某种类型比较困难，当分裂会决策树超出最大深度（规定最大深度主要是为了防止决策树过拟合，即设置的特征辨别过多），或是每次分裂导致纯度的提高或熵的下降低于阈值（即将饱和），或是一个节点中样本的数量小于阈值时（即将饱和），我们也会停止分裂。<br>每个节点纯度的计算公式是：p=同属同一叶子结点的样本数量/总的样本数量</p><p>每个节点熵的计算公式由熵函数(Entropy Function)H(p)定义：</p><p>由于熵包含了纯度的概念，故通常我们就用熵来替代纯度。从熵函数可以看出，当一个节点的样本中由给定特征分出的两个子集分别各占一半时(p1=p2=0.5)，熵的结果最大为1；当一个节点的样本中由给定特征分类只有一种结果时(p1=1,p2=0/p1=0,p2=1)，熵的结果最小为0。使用Log2来定义熵函数主要是为了使当使p1=p2=0.5时，熵的结果为1，定义0log(0)=0。<br>有了熵函数，我们就定量的知晓了拆分特征时最大程度减小熵，最大化纯度的方法。每次拆分特征时熵的减小量称为信息增益(Information Gain)。我们还是以判断一个动物是否为猫为例，在确定其根节点特征时，我们将三个特征分别求解出对应的熵函数（注意：由于每次拆分时左右两个子集的数量会有所区别，在分别计算左右两部分子集的熵函数要乘以权重来得到最终的熵函数）并与拆分前的熵函数进行比较得到信息增益，信息增益最大的拆分规则即为最理想的拆分规则，每次都是最理想的拆分得到的结果也就一定是最优决策树。</p><p>信息增益的计算公式如下所示：即根节点的熵与左右子节点熵的加权平均值的差值</p><p>确定了最佳的拆分特征后，具体将训练数据发送到左分支或右分支，则取决于该实例的该特征的值。<br>于是，得到最优决策树的过程如下所示：<br>1.开始时所有的样本均在根节点<br>2.对所有可能的特征计算信息增益，选取信息增益最大的特征为实际拆分特征<br>3.根据实际拆分特征拆分样本集为左右两个样本子集<br>4.对左右子树重复过程2（一般先左再右），直到满足终止条件则设置一个叶子结点。<br>可以看到得到最优决策树是一个递归过程。如果左右子树在选择可能的特征时选择与父节点一样的特征，会发现H(p1root)=1，wleft=1，H(wleft)=1，故而信息增益为0，因此新的分类必然不可能是与父节点一样的特征。但是同一父节点的左右子节点之间是可以取用相同的特征的。<br>上面判断一个动物是否为猫的例子中，我们把所有的特征都定义为只能取两个值的特征，那么如果一个特征可以取多个离散值时应该怎么处理呢？我们引入独热编码(one-hot encoding)的概念，所谓独热编码，即如果一个特征可以取k个值时，就把它变为k个只能取两个值的二元变量。例如Ear Shape可以分为Pointy,Oval和Floppy三种时，我们就把Ear Shape变为是否是Pointy ears，是否是Floppy ears，是否是Oval Ears三个变量，这三个变量都是二元变量，且同时只有一个可以取1，其他都是0。则此时又可以用一般的决策树算法了，只是变量的数量有所增加。</p><p>此外，如果特征变量是连续的话，决策树又该如何确定该变量的节点呢？例如我们给定动物的体重，如何判断该动物是不是猫呢？对于二元特征而言，我们容易把它分为左右两个子树，而对于连续特征而言，分为两类的思想也是理所应当的，即将小于某个阈值的分为一类，而将大于该阈值的分为另一类，那么关键就在于如何确定这个阈值了。其方法是：我们先画出是否为猫与重量关系的图表，而后选择某个值作为阈值将样本分为两个子集，仍然按照离散的规则计算对应的信息增益即可。而确定所谓“某个值”的方法是取相邻两个连续特征的中点作为分界线做一次阈值尝试，故n个样本点需要做n-1次阈值尝试，最后取信息增益最高时对应的值作为实际阈值即可。</p><p>进一步地，之前的例子都是判断一个动物是否为猫，即输出的结果是离散的，那我们可不可以用决策树判断连续的结果呢？答案是可以的。此时输入的变量仍然是离散的，而输出结果是连续的。我们把这种用于预测回归问题的决策树称为回归树(Regression Tree)。在回归树中，我们预测的结果是一个连续变量的可能取值。例如，我们给定动物的耳型、面部和是否有胡须判断该动物的体重，此时分类的衡量标准便由熵变为了方差。具体地，我们对所有可能的特征计算分类后方差的加权平均数并与分类前的方差作差值得到方差增量，同理选择方差增量最高的作为实际特征并重复循环。</p><p>当只有一个决策树时，决策对样本的敏感度会非常高，样本集的轻微变化就可能导致决策树的剧烈变化。为了降低算法对样本的敏感度，通常我们会选择同时使用多个决策树做预测，并根据多数原则给出最终判断。把多个决策树构成的决策算法称为随机森林(random forest)。如果要生成多个决策树，光有一个样本集是不够的，我们要做的是利用原样本集得到多个样本集，且新训练集需要与原训练集类似而又有不同，采取的方法有以下几种：<br>1.有放回抽样：将含有n个样本的原样本集进行n次有放回抽样，把得到的结果组成一个新的样本集，这样就能保证新训练集与原训练集类似而又有不同，而后对新训练集也重复做决策树学习算法得到一棵新的决策树，重复这一过程B次便可以得到一片有B棵决策树的随机森林。<br>2.选择部分特征：有放回抽样得到随机森林的方法可能会导致每棵决策树在根节点及其附近类似或相同，不利于森林的多样性。选择部分特征的方法指出，在选择每个节点的特征时，只允许算法选择特征总量n的一部分特征k作为可选特征，一般选取k=sqrt(n)。<br>3.刻意学习：是有放回抽样的进阶版本，它把上一个决策树没有做好的地方在构建下一个决策树时更加关注。刻意学习的方法指出，当按照有放回抽样的思路得到一棵新的决策树后，把该决策树与原训练集对比，查看该决策树对原训练集的预测，在下一次抽样时，不完全随机的抽取训练集数据，而更有可能去抽取上一次决策树预测错误的样本。这个算法也被称为Boost算法，而Boost算法里最为出色的是一种被称为XGBoost（Extreme Gradient Boosting）的算法，在代码里调用XGBoost的函数如下，XFBClassifier()解决分类决策树，XFBRegressor()解决回归树问题：</p><p>最后对比一下决策树和神经网络各自的优缺点，以作出正确的选择：<br>决策树：适合作用于有结构的数据（表格），不适合作用于无结构的数据（例如图片、文本和音视频）；学习时间通常比神经网络快。<br>神经网络：既适合作用于有结构的数据，也适合作用于无结构的数据；学习时间通常比决策树慢；可以使用迁移学习进行预训练；可以串联构建更大型的神经网络</p><p>接下来我们就要学习无监督学习的相关知识了：</p><p>与监督学习不同，无监督学习给出的训练集中仅仅给定了样本输入，而没有给出其对应的输出，机器本身需要利用算法找到这些数据的某种结构以预测未来输入的结果。<br>聚类(clustering)：获取没有标签的数据并尝试将它们自动分组到不同集群中。最常用的聚类算法是一种被称为K-means的聚类算法，它采用集群中心的思想完成聚类。首先，我们根据规定的集群数k随机在工作空间初始化k个集群中心记为μ1-μk，将数据总数记为m，每个数据记为x(i)(i=1 to m)，每个数据x(i)离得最近的集群中心对应的序号记为c(i)，每个数据x(i)离得最近的集群中心记为μc(i)。K-means算法重复如下步骤：遍历每个数据，得到每个x(i)对应的c(i)；遍历每个集群中心，取属于对应集群中心的所有数据的均值更新集群中心。直到某次重复后，集群中心的值不再发生改变，即算法收敛，则此时同属于一个集群中心的所有数据便被归为同一类。<br>整个算法的思想是非常合乎逻辑的，我们从理论上验证一下，K-means的代价函数被称为失真函数(Distortion Function)，其公式如下，即每个数据到其对应的集群中心距离的平方均值：</p><p>事实证明，K-means聚类算法既适合用于分离良好的集群的聚类，又适合用于分离不是很好的集群的聚类。例如要根据人的身高和体重分配衣服的尺码SML，此时虽然数据是比较集中的，但K-means算法仍能较为清晰地分离数据组成聚类。</p><p>现在的问题是，我们如何进行集群中心的随机初始化呢？事实上，任意的随机初始化可能会出现平均值为0的集群中心，此时的解决办法一般式消除该集群中心，或者重新初始化该中心。避免这个问题的更好方法是在初始化集群中心时，只选取已知训练集中的训练点作为初始集群中心。</p><p>当然，在初始化时还会碰到的问题是算法可能会陷入局部最优情况：</p><p>为了解决这个问题，我们可以重复K-means算法多次，每次都重新在训练集中随机选择训练点作为初始集群中心运行K-means算法得到最优解，重复次数一般在50-1000之间。最后选择一个代价函数J结果最低的作为真正的全局最优解。此时得到的结果一般就是最佳的了。</p><p>最后一个问题，我们在做聚类问题时应该如何选择K的值呢？一种方法被称为肘法(Elbow Method)，一般而言，随着K的增长代价函数J会逐步减小，画出J-K曲线后选取曲线的肘部（函数二阶导最大的地方）对应的K作为聚类的数量，此时的K被认为是最佳的K。</p><p>但是，这种方法在肘部不明显的函数里将会难以使用；且事实上，我们选取聚类数量K的时候通常是带有目的的，例如我们在选择T恤尺寸分类时通常在一开始就确定了是要分三类(SML)还是五类(SMLXLXXL)，故我们其实可以直接进行K值的选择而不需要采用肘法。</p><p>异常检测(Anomaly Detection)：异常检测算法查看未标记的正常数据集，而学会检测异常数据并发出危险信号，异常检测常常用于制造缺陷和金融欺诈等问题。要实现这个功能需要使用密度估计(Density Estimation)，一般而言，异常检测中正常的样本会占绝大部分，于是我们判断一个样本是否异常的方法是设定一个阈值ε，当测试样本xtest的出现概率p小于ε时，则认为该样本有异常，否则则认为该样本正常。</p><p>由于现实生活的大部分变量符合正态分布：</p><p>于是异常检测算法的基本流程如下：<br>1.选择n个可能导致异常样本的特征xi<br>2.计算n维正态分布的所有期望和方差参数：</p><p>3.得到n维正态分布公式后，给定新的输入样例，判断p(x)与ε的大小关系：</p><p>上述p(x)公式成立的前提条件是各特征之间相互独立，但实际上各个特征可能相关，但事实证明，就算各个特征不独立该算法也能正常工作。而且由于p(x)是各特征变量的相乘，故当一个特征过小就会导致整体结果偏小，这也说明异常检测在任何维度检测到异常就会被鉴定为整体异常，这也符合异常检测的基本要求。</p><p>在异常检测中，为了选择合适的ε以及评估系统的性能，我们也会采取训练集、交叉验证集、测试集分立的方法。而且通常，我们会对异常检测的样本集进行正常或异常的标记，这可以提高异常检测的效果，尽管这有点像监督学习，但它实际上只是为了方便测试结果。例如我们有一个飞机引擎的样本集，其中有10000个被标记为正常的和20个被标记为异常的数据，此时我们一般不在训练集中使用异常数据（这就是为什么它并不是监督学习），而在交叉验证集和测试集判断系统性能时加入异常数据来看看系统检测异常的效果。例如在训练集中放入6000个正常样本，在交叉验证集和测试集中各放入2000个正常样本和10个异常样本。<br>此时选择ε的值就比较直白了，我们只需要在交叉验证集中选择把所有10个异常样本均排除在外的ε即可。当然，实际应用时我们会像罕见病的那个例子一样，综合精确率和召回率来得到一个最合理的ε值。</p><p>对比异常检测和二元监督学习，异常检测通常具有极少的阳性例子和大量的阴性例子，而监督学习的二元分布通常较为平均；此外，由于异常检测基于正常数据，因而它可以处理与原来出现的异常类型或原因完全不同的异常，凡是任何偏离正常数据的结果都会被标记为异常，而不论它是如何产生的，而监督学习检测二元分布时是基于已有的二元训练集的，因而它只能处理在训练集里见到过或近似的异常。例如金融诈骗花样百出，故采用异常检测；而垃圾邮件通常都带有推销的字样，故采用二元监督学习。</p><p>在异常检测中选择合适的监测特征也是很重要的，有的监测特征可能并不符合正态分布，此时再使用正态分布概率预测时误差就会比较大。当然，对于这种特征，我们有办法能让他变得更加符合正态分布，常见的方法是对原变量取对数log(x+c)或取小于1的幂x1/n。如果想要定量判断一个分布与正态分布的相似程度，可以查阅相关资料。</p><p>如何判断是否要为异常检测提供新的检测特征呢？一个常用的规则是如果异常和正常的样本在当前数量的特征下混在了一起无法区分，此时就要添加额外的检测特征，如下图将一维特征扩展为二维特征：</p><p>还有一种方法是根据已有特征来扩展新特征，例如在维护网站时，已有的特征是用户的CPU负载和网络流量，一般CPU负载和网络流量成正比，也许一个用户的CPU负载和网络流量都处在正常范围内，但CPU负载比网络流量相差很大，这仍然是不正常的。此时可添加新特征为CPU负载/网络流量，以此检测这种问题的出现。</p><p>推荐系统(Recommendation System)：推荐系统也是一个非常受关注的机器学习算法，现在你每在一个网站上浏览数据，网站都会向你推荐他们认为你可能想要关注或感兴趣的内容，实现这个功能就需要借助的机器学习算法就是推荐系统。<br>我们以一个根据用户对已看过电影的评分来推荐他们未来可能喜欢的电影的推荐系统为例：</p><p>在这个例子中，我们用nu表示用户的数量，nm表示电影的数量，r(i,j)表示用户j是否对电影i进行了评价，m(j)表示用户j评分电影的数量，y(i,j)表示用户j对电影i的评级（只有在r(i,j)=1时被定义）。而推荐系统的目标就在于，当给出用户对于不同电影的评价后，推荐系统要查看用户未评分（没有看过）的电影，并尝试预测用户如何评价这些电影，从而向用户推荐他们更有可能评价为5星的电影。要实现这个功能的算法比较复杂，我们循序渐进的来介绍。<br>我们先假设我们额外知道一些描述电影类型的特征，例如我们知道对应电影隶属于浪漫片和动作片的程度，同时我们用n来表示描述电影类型的特征个数，x(i)来表示电影i对应的特征向量x，则预测用户j对电影i的评分可以使用特征方程：hat{y(i,j)}=<a href="j">w</a><a href="i">x</a>+<a href="j">b</a>来实现，这个公式其实就是线性回归的公式，其中<a href="j">w</a>和<a href="j">b</a>都是用户j的预测参数矢量，<a href="j">w</a>矢量里的每个值对应了用户对每个电影的喜好程度，<a href="j">b</a>是偏差量，和线性回归一样由梯度下降法得到w和b的最优值。</p><p>和线性回归一样，当我们得到了特征方程后，下一步就是写出代价函数了，对于已知描述电影类型特征的情况，每个用户j的代价函数和线性回归代价函数一致，只是需要注意的是，求和符号的下标是用户j已经预测的电影集合（相当于已知的训练集），<a href="j">w</a><a href="i">x</a>+<a href="j">b</a>-y(i,j)即为用户j对电影i的预测值与实际值的差，我们对其做平方均值并加上正则化项即为下式：</p><p>但事实证明，我们把分母中的m(j)项去掉对于得到代价函数的最小值没有任何影响，故用户j的代价函数可以简化为：</p><p>进一步地，我们可以得到所有用户总和的代价函数：</p><p>利用这个代价函数求梯度下降，我们就可以得到每个用户的预测参数矢量<a href="1">w</a>-<a href="nu">w</a>和b(1)-b(nu)了。举个例子，对于用户1，我们利用样本集（即用户1对电影1,2,4,5的评分）优化代价函数得到了w(1)=[5,0],b(1)=0，则我们可以预测用户1对电影3的评分为w(1)x(3),b(1)=4.95接近于5分，故算法会向用户1推荐电影3。可以看到，此时的样本集即不同用户对不同电影的评分，而预测则是那些用户对还没有打分的电影的可能评分，从而决定是否向对应用户推荐对应电影。<br>同样的，我们再假设我们知道用户的参数矢量<a href="j">w</a>和<a href="j">b</a>，而学习目标是得到每个电影的特征矢量<a href="i">x</a>。</p><p>则此时代价函数的目标就应该是<a href="i">x</a>，则代价函数应该是预测值与实际值的差的平方均值并加上<a href="i">x</a>的正则化项，且此时由于主体是电影的特征向量，故求和的目标是那些为电影i打分的用户j，即为下式：</p><p>进一步地，我们可以得到所有电影总和的代价函数：</p><p>利用这个代价函数求梯度下降，我们就可以得到每个电影的特征向量<a href="i">x</a>。举个例子，我们假设w(1)=[5,0],b(1)=0，w(2)=[5,0],b(2)=0，w(3)=[0,5],b(3)=0，w(4)=[0,5],b(1)=0，则我们可以预测电影1的特征向量，即w(1)x(1)=5，w(2)x(1)=5，w(3)x(1)=0，w(1)x(1)=0，结合这四个式子可得x(1)=[1,0]可以看到，此时的样本集即不同用户对不同电影的评分，而预测则是电影的特征向量。<br>综上，当我们给出电影的特征向量和评分表后，算法可以预测用户的参数矢量<a href="j">w</a>和<a href="j">b</a>；反过来，当我们给出用户的参数矢量和评分表后，算法可以预测电影的特征向量<a href="i">x</a>。</p><p>但是实际上，我们可能既不知道描述电影的特征向量，又不知道用户的参数矢量，也就是说<a href="j">w</a>,<a href="i">x</a>,<a href="j">b</a>都是我们需要去预测的量。这时候就要使用协同过滤算法(Collaborative Filtering Algorithm)来解决问题了：协同过滤算法指出，既然已知<a href="i">x</a>学习<a href="j">w</a>,<a href="j">b</a>的代价函数和已知<a href="j">w</a>,<a href="j">b</a>学习<a href="i">x</a>的代价函数都知道了，那么当w,b,x都未知时，只需要将三者都当作优化量，而代价函数则是两者优化函数之和。注意求和项合并后即为所有已评分的项目(i,j):r(i,j)=1。</p><p>要求解这个代价函数的最小值，应用的方法仍然是梯度下降，只不过由于此时x(i)也是优化目标之一，因而求偏导时还要对x(i)求偏导</p><p>最后我们便可以利用协同过滤算法得到w,b,x的最优值。协同过滤算法通过分析多个用户的合作评价（对应打分表），可以让我们了解各变量的特征向量取值（对应一部电影可能是什么类型的），反过来，利用特征向量，我们可以得到用户的参数矢量（对应用户对不同类型电影的喜好程度），从而预测用户对于还未评价的变量会做出如何反应（对应用户对还没看过的电影可能打出的分数），从而决定是否向用户推荐该变量（对应是否要推荐这部电影给目标用户）。<br>此外，推荐系统除了有像电影评分这种0-5星的多变量/连续系统，还有一些二进制标签(Binary Labels)，例如对一个视频点赞或不点赞，收藏或不收藏等。<br>我们用数字1表示用户看到某个项目后参与了该项目（例如刷到视频后点赞投币收藏），用数字0表示用户看到某个项目后没有参与该项目（例如刷到后就划走了），用?表述用户还没看到过该项目（例如还没刷到这个视频）。则此时的样本集应该长这样：</p><p>正如之前从线性回归走向逻辑回归，我们预测用户对二进制标签的结果也应该是0或1的二元值，也就是预测用户取1的概率，这点和逻辑回归如出一辙。故类似的，在预测概率时，我们也像线性回归走向逻辑回归时一样，为<a href="j">w</a><a href="i">x</a>+<a href="j">b</a>外套上一个g(z)=sigmoid函数即可。</p><p>于是此时的预测函数就是关于w,b,x的三元sigmoid函数：</p><p>对应单个变量的损失函数是逻辑回归中的二元交叉熵函数：</p><p>而代价函数则是单个变量损失函数之和：</p><p>现在有一个问题摆在眼前，如果存在一个用户他没有评价过任何电影，事实上这也是很常见的现象，那我们向他推荐电影时应该遵循什么原则呢？（如下图的Eve）</p><p>事实说明，如果一个用户未评价任何电影的话，系统对该用户的预测参数矢量[w]和[b]应该均为0，那么由[w][x]+[b]则系统预测用户对任何电影的评分都将是0，也就不会推荐任何电影给这位用户了，这显然是不合理的。为了避免这个问题，我们通常会对样本集进行均值归一化(Mean Normalization)，我们将样本集抽象为矩阵形式，行代表不同用户对同一电影的打分，列代表同一用户对不同电影的打分，此时若对每个元素减去其对应行评分的均值μ，我们便可以得到一个每行元素之和均为0的矩阵，这就是均值归一化的结果。</p><p>由于此时减去了评分均值μ，因而在计算最后分数时还要加上μ，故公式即为<a href="j">w</a><a href="i">x</a>+<a href="j">b</a>+μi。如此这般，对于已评价用户而言其分数并不会发生变化，而对于没有评价过任何电影的用户而言，由于[w]和[b]均为0，则系统的推荐便取决于其他人评分的均值μ，这比预测用户对任何电影的评分都是0合理不少。<br>同理，如果一部电影没有任何用户评价，对应矩阵行全是？，则此时我们对列取均值μ（未评价过的用户不计入在内）重复上述步骤。则此时对于没有人评分的电影，系统认为用户对该电影的评分为每个用户评价其他电影的均值，也显得比较合理。<br>这类问题也被称为冷启动问题(Cold Start Problem)，协同过滤算法本身并不适合解决冷启动问题，我们必须对它进行均值归一化后才能得到一个比较合理的结果。<br>协同过滤算法在TensorFlow下的实现如下：<br>关键步骤在于TensorFlow的自动微分(Auto Diff)过程求解偏导项，重点公式为：<br>tf.Variable(init)，tf.GradientTape()和tape.gradient(y,x)</p><p>同理，多变量偏导的过程也类似：</p><p>推荐系统还有一个作用是，那就是寻找相关特征推荐。例如我们在视频网站上看一部电影，其下方的推荐栏总是会推荐很多类似的电影。它的实现也很简单，只要我们在协同过滤算法中算出[w],[b]和[x]后，寻找其他电影的[x(l)]与本电影[x(i)]类似的即可。类似在数学上的定义即为欧几里得范数之最小，即：</p><p>综上我们也可以看出，协同过滤算法存在一个问题就是，它只能得到一组特征向量[x]，却没办法说明这个特征向量的具体意义，基于比较的推荐也只能做到特征向量的近似。在实际的推荐系统中，我们往往可以得到用户和对象的某些信息来判断是否值得推荐，例如用户是中国人而对象是一部国风电影，那么推荐系统便可以根据这些已知的标签去进行推荐，而协同过滤算法本身不具备这种觉察性，这便引出我们接下来要讲的基于内容的过滤算法(Content-based Filtering Algorithm)。协同过滤算法基于用户的评分表来推荐你可能给高分的电影，而基于内容的过滤算法基于用户特征与电影特征的匹配程度推荐你可能喜欢的电影。</p><p>仍以用户与电影的例子说明，在基于内容的过滤算法中，我们通常知道关于用户和电影的一系列标签，我们把用户j的标签向量记为xu(j)（例如年龄、性别、国家、看过的电影与评分等），把电影i的标签向量记为xm(i)（例如上映时间、类型、平均得分等）。此时预测用户j与电影i匹配程度的函数可以参照<a href="j">w</a><a href="i">x</a>+<a href="j">b</a>，只不过此时我们通常把<a href="j">b</a>定义为0，把<a href="j">w</a>和<a href="i">x</a>分别记为vu(j)和vm(i)，其中vu(j)和vm(i)由xu(j)和xm(i)计算而来。由于vu(j)和vm(i)需要执行点乘，因而xu(j)和xm(i)向量长度可能不同，但vu(j)和vm(i)的长度必须相同。故判断电影和用户是否匹配即判断vu(j)和vm(i)的点乘值是否够大，例如vu(j)可以是用户对不同类型电影的喜好程度，vm(i)可以是一部电影分属不同类型的比例程度，两者通过点乘便可以寻找良好匹配。<br>那么如何通过xu(j)和xm(i)得到vu(j)和vm(i)的值呢？<br>我们仍然可以使用神经网络，通过输入xu和xm得到输出vu和vm，再对vu和vm做点乘得到预测结果，需要注意的是用户神经网络和电影神经网络是共用一个神经网络而不是分开训练的，输出层的结果是vu和vm的点乘。</p><p>对应的代价函数也就是预测值vu和vm的点乘减去真实值的平方误差和正则化项</p><p>同理，也考科一利用基于内容的过滤算法来寻找相关特征推荐。只需要将对应的欧几里得范数公式更改为：</p><p>基于内容的过滤算法在TensorFlow下的实现如下：</p><p>主成分分析(Principal Component Analysis)：<br>为了可视化特征数量较多的系统，我们会使用一种称为主成分分析的无监督学习算法，简称PCA。PCA可以把大量的特征（例如50个）简化为2到3个，从而可以绘制于可视图表中。基于这个特性，它偶尔也会用于简化样本集或训练过程中。<br>PCA算法缩减特征数量的关键在于寻找一个能最大化每个样本所有特征的轴。<br>以二维样本简化为一维样本为例，要找到一个能最大化每个样本所有特征的轴，也就是要找到一个各样本点在该轴上的投影方差最大的轴。根据这个要求，我们便可以利用算法得到结果了，这个轴也被称为主成分轴。下图是两种主轴的选择：可以看到第一张图中主轴的选择导致各投影的方差不大，故不是一个能明显凸出各样本区别的选择，而第二张图中主轴的选择就显得合理多了（图中黑线是最优选择，蓝线是当前选择，X是而样本点，·是投影点）：</p><p>当我们得到主轴上的投影点时，也可以近似的估计原始数据各特征的值，方法是对主轴上的点对各个初始轴做投影，注意其结果只是一个近似值，因为在做主轴投影点时部分特征值被忽略了。<br>以上都是将所有特征缩减到1个特征的情况，如果要缩减到2个特征，可以做一个与主轴垂直的轴作为第二特征轴；如果要缩减到3个特征，可以做一个与主轴和第二特征轴都垂直的轴作为第三特征轴。</p><p>此外，需要说明的是，PCA与线性回归并不是一个概念，具体区别在于差值和投影的区别，且PCA要得到最大方差，而线性回归要得到最小差值，具体可以参考下图的对比：</p><p>PCA在TensorFlow中的代码实现如下：<br>PCA函数确定要缩减为几个变量，fit函数根据原特征变量计算主轴，explained_variance_ratio打印每个轴分别体现了多大比例的原特征变量，transform得到将原特征变量的值投影到主轴（如果有的话：第二特征轴、第三特征轴）后的结果，inverse_transform得到将主轴值投影回原初始轴的原始数据近似真实值，以二维样本简化为一维样本为例：</p><p>强化学习(Reinforcement Learning)：强化学习的目的在于，我们通过给予激励和惩罚希望系统学会要做什么而不是让我们教他具体怎么去做。例如做无人机和机器狗时，如果要让我们根据其当前状态随时教育它应该怎么做，这是不可能的，因为现实的工况过于复杂。反之，我们通过激励函数来对这个系统做出的正确行为给予奖励，而对这个系统做出的错误行为给予惩罚，从而教会系统在每个状态都依据最大奖励的行为运行，这被证明能用于优化系统。</p><p>以一个简单的离散系统为例，一个火星车在任意时刻都处于如下六种状态的一种，假设初始时刻它位于状态4，我们希望它前往状态1或状态6去观测地表，但时间只允许它前往状态1或状态6之一，且状态1比状态6更远但更值得勘察，那么我们应该怎么设置激励函数来让火星车根据激励来运动？假设我们在状态1上设置激励为100，在状态6上设置激励为40，同时我们设置前往下一个状态的时间成本为0.9。于是，我们从状态4前往状态1的激励便是0+0.9<em>0+0.9</em>0.9<em>0+0.9</em>0.9<em>0.9</em>100=72.9；同理，我们从状态4前往状态6的激励便是0+0.9<em>0+0.9</em>0.9*40=32.4，则系统便在激励函数的作用下选择前往状态1。</p><p>同理，如果我们把时间成本改为0.5，则系统在不同初始状态前往不同终点的激励便是如下：</p><p>故系统在不同初始状态选择前往的目标和对应的激励也不同：</p><p>根据这个例子，我们引出强化学习的一些概念：<br>1.状态(Status)：系统当前各状态变量的集合，一般把当前状态定义为s，下一状态定义为s’。<br>2.行动(Action)：系统从当前状态前往下一个状态可以采取的动作，一般把当前状态的行动定义为a，下一状态的行动定义为a’。<br>3.决策(Policy)：系统在当前状态的行为，是s到a的映射，也用函数π(s)=a表示。<br>4.激励(Reward)：系统处于当前状态可以获得或增加的分数，也用函数R(s)表示。<br>5.折扣因子(Discount Factor)：系统前往下一状态的惩罚，其现实意义是时间成本，取值为0-1，事实说明，折扣因子对正激励和负激励同时有效：对于正激励而言，我们总是希望早点得到；对于负激励而言，我们总是希望晚点被惩罚。<br>6.返回值(Return)：系统完成整个过程后得到的总分，由奖励和折扣因子决定。其公式有一般式和递推式两种形式。一般式的形式即为：Return=R1+γR2+γ2R3+…+γn-1Rn，其中R1为起点，Rn为中点，其余为中途路径点。递推式会在之后说明。<br>对于上面这个例子，状态1-6是状态，向左走和向右走是行动，在状态2下向右走是决策，状态1和状态6的分数是激励R(1)=100/R(6)=40/R(else)=0，时间成本0.9/0.5是折扣因子，72.9和32.4是返回值。<br>而强化学习的目标就是：在每个状态s下，找到一个决策π，告诉系统在该状态下做出行为a前往下一状态s’，从而使返回值return最大。事实上，这种过程也被称为马尔可夫决策过程(Markov Decision Process)，马尔可夫决策过程的特点是系统未来的输出只取决于当前的状态和行为，而与过去的状态与行为无关。</p><p>接下来介绍状态-动作价值函数(State-Action Value Function/Q-Function)，一般记作Q(s,a)，它的值由当前的状态和要采取的行动决定。它的定义是，如果在当前状态s下采取行动a，则我们可得到的最佳最终返回值Return是多少。以火星车为例，我们给出了在每个状态下向左走或向右走的最佳返回值，也就是Q(s,a)的值。以γ=0.5，Q(2,Right)为例，如果火星车要前往状态1，则路径为2-&gt;3-&gt;2-&gt;1，值为12.5；如果火星车要前往状态2，则路径为2-&gt;3-&gt;4-&gt;5-&gt;6，值为2.5，故Q(2,Right)=12.5。</p><p>总结一下，如果我们得知了每个状态采取每个行动的Q(s,a)，这就为我们提供了一种在任意状态得到最佳返回值的方法，也就是在任意状态都能找到最佳策略和行为的方法。<br>返回值的递推式被称为贝尔曼方程(Bellman Equation)，他可以用来计算状态-动作价值函数。<br>贝尔曼方程的格式为：</p><p>也就是说在当前状态s下采取行动a得到的最佳最终返回值等于当前状态s下的激励加上折扣因子乘以下一状态s’下采取最佳行动a’得到的最佳最终返回值。<br>例如Q(2,Right)=R(2)+0.5<em>max(a’){Q(3,a’)}=R(2)+0.5</em>max(Left){Q(3,Left)}=0+0.5<em>25=12.5<br>Q(4,Left)=R(4)+0.5</em>max(Left){Q(3,Left)}=R(4)+0.5<em>max(Left){Q(3,Left)}=0+0.5</em>25=12.5</p><p>在某些情况下，当我们采取行动时，结果并不总是完全可以确定的。例如我们要求火星车往左走，它可能会因为车轮打滑等因素反而往右走，在这种随机性环境下的强化学习被称为随机强化学习问题(Stochastic Reinforcement Learning)。对于这类问题，我们感兴趣的应该是采取每一行为后的预期结果的最大值，也就是期望的最大值，因为具体会得到的值是不确定的。<br>例如s=3，a=Left，此时得到的s’可能为2也可能为4，只是2的可能会更大而已。<br>于是此时的贝尔曼方程修改为：</p><p>之前谈论的火星车的例子，它实际上还是一个离散概念。现实世界中的应用往往是连续的状态空间，则此时的状态s应该是状态变量的合集，激励应该是在每一时刻动作的回馈。且对于连续状态空间系统而言，计算返回值时使用一般式是不现实的，只能使用贝尔曼方程计算，但关键在于我们怎么得到Q函数呢？这些疑问我们在之后会阐述。<br>我们以一个登月器的例子说明，我们定义它的状态变量为位置、角度、速度、角速度、左脚着地、右脚着地的集合，定义它每一时刻的激励如下：例如平稳着陆加分，坠毁减分，打开引擎减分（节能）等。</p><p>现在来解答怎么得到Q函数的疑惑，事实上，关键思想是我们需要训练一个神经网络去逼近最佳的状态动作值函数Q，而这反过来又可以让系统自行选择一个好的行动。在搭建神经网络时，输入一般是状态变量，而输出则是在该状态下可采取的所有行为，我们对这些所有可采取的行为进行比较，选择其中Q最大的作为真实的输出，也就是该状态下最优的行为。</p><p>现在的问题是我们怎么得到关于x,y的训练集从而训练这个神经网络。我们把目光投向贝尔曼方程，观察贝尔曼方程可知，当前的状态s和行为a组合在一起成为一个输入x，而R(s)+γmax(a’)Q(s’,a’)就是一个输出y。我们在每个时刻都可以观测到以下量：当前的状态s，当前的行为a，当前可以获得的激励R(s)，下一时刻的状态s’。利用这个元组(s,a,R(s),s’)，我们就可以完全已知这个时刻的输入x=[s,a]和输出y=R(s)+γmax(a’)Q(s’,a’)（其中Q就是一个关于a’的函数，max(a’)Q(s’,a’)求解这个函数的最大值，也是一个已知量）关系。如果我们随机在一个状态s下随机采取一个动作a，重复一万次，就可以得到一个含有一万个样本的样本集了，这个样本集中x是当前的状态和采取的行为，y是获得的分数，训练目标是得到一个好的Q使Q(s,a)=Q(x)=fw,b(x)≈y。利用这个样本集训练神经网络，就可以让它学会在什么状态采取什么行为才能得到一个好的激励，从而得到一个不错的运行结果了。<br>这个算法也被称为DQN(Deep Q-Network)算法，现在让我们总结一下整个流程：<br>1.构建神经网络，其中输入是状态s，输出是Q(s,all possible action for s)<br>2.随机初始化Q函数，此时Q函数的结果可能不是最优的<br>3.重复多次的随机在一个状态s下随机采取一个动作a，根据贝尔曼方程得到样本集[x,y]<br>4.利用得到的样本集训练神经网络得到新的Q函数（实际上是修改神经网络的w，b值），从而使得Q(s,a)=Q(x)的值更加接近于输出y。<br>5.更新Q函数并重复步骤4-5直到Q(x)≈y</p><p>上述算法存在一个小问题在于，当我们在构建样本集时，如果我们在某个状态任意的选取动作a，这可能会导致算法难以收敛，因为随机选取得到的a通常是一个坏动作。于是一个自然的选择是，尽管此时的Q不是最优的Q，但我们仍然去选择能使Q(s,a)最大的a来填充样本，也就是尽力而为。事实证明，这么做能给系统一个选择的参照，但可能会陷入局部最优，例如一个动作在当前的Q下收益高就一直去尝试这个动作，而不去考虑其他动作了。但由于这个Q并不是最佳的Q，这么做一定会使算法误入歧途。解决的办法也很自然，就是选取一个概率ε，算法有(1-ε)的可能性选择能使Q(s,a)最大的a来填充样本，也有ε的可能性任意选择a完成动作，这么做的好处在于既给了算法一个优化方向，又能让算法可以尝试不同的可能性，这种算法改进也称为ε-贪婪策略(Epsilon-greedy policy)。<br>此外，ε的取值往往也不是一成不变的。在算法的开始，由于Q的随机性，我们更应该鼓励算法尝试多种的可能，故一开始的ε会给的比较大；随着算法的进行，Q会越来越趋向于合理化，此时我们就要逐步减小ε的取值，来让算法跟着最优路径去走，以此得到良好的样本。</p><p>在强化学习中，还有两个优化方法可以使用：<br>小批量(Mini-Batches)，就像在监督学习中当样本集过大时，我们改批量梯度下降为部分梯度下降一样，在训练Q的样本集过大时，我们也可以采用选取部分训练集训练的方法来加快速度，例如我们可以把上面总量为10000的样本集每次使用其中1000个来训练神经网络。<br>软更新(Soft Updates)：之前神经网络的每次迭代，我们都会将Q更新为神经网络新得到的Q，如果这个新的Q偶然比原来的Q效果还要差，会导致神经网络的倒退，从而产生较大的噪声，使收敛不够可靠。软更新的方法可以避免我们只是因为一次不幸的调整式神经网络变得更糟。它的实现方法是，相比于每次都更新Q为一个与过去的Q完全无关的函数，我们可以选择一个系数k，使Q的更新既参考过去的Q又参考新得到的Q，也就是Q=kQnew+(1-k)Qlast<br>对应于神经网络参数即w=kwnew+(1-k)wlast，b=kbnew+(1-k)blast，k通常会取到0.01。利用软更新，可以有效的减少神经网络训练过程中的振荡和转向，从而实现更加可靠的收敛。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习</title>
      <link href="/2023/10/14/DeepLearning/"/>
      <url>/2023/10/14/DeepLearning/</url>
      
        <content type="html"><![CDATA[<p>SNN(Standard Neural Network)：标准神经网络，房价预测可以使用这种神经网络。<br>CNN(Convolution Neural Network)：卷积神经网络，图像处理可以使用这种神经网络。<br>RNN(Recurrent Neural Network)：循环神经网络，语言翻译和音频处理等序列化数据可以使用这种神经网络。</p><p>非结构化（例如图片、文字、音频）的数据比结构化（例如表格）数据的学习要困难得多。</p><p>推动深度学习发展的有三大因素：数据、计算能力(GPU)和算法。</p><p>神经网络的前向传播与反向传播：<br>前向传播：是数据从输入层输入，经过一层层隐藏层计算得到中间变量，最后从输入层得到输出的过程。换句话说，前向传播计算出了神经网络对输入的预测输出。<br>反向传播：是根据前向传播计算的预测值与真实值的差距得到损失函数，并对损失函数利用梯度下降来更新参数w,b的过程。应用梯度下降的核心在于计算损失函数对各w,b的偏导数。而计算这些偏导数的过程是反向的，也就是从最后一层逐层向前去计算，去改变每一层的w和b，其原理是链式求导法则。<br>我们以一个有两层隐藏层的神经网络为例：</p><p>在这个例子中，我们使用前向传播依次得到x=&gt;z[1]=&gt;a[1]=&gt;z[2]=&gt;a[2]的值，使用反向传播结合链式法则依次得到：<br>dL/da[2]=&gt;dL/dz[2]=&gt;dL/dw[2]&amp;dL/db[2]=&gt;dL/da[1]=&gt;dL/dz[1]=&gt;dL/dw[1]&amp;dL/db[1]的值。<br>综上，前向传播是神经网络根据输入得到输出的过程(a[l-1]=&gt;a[l])，反向传播是神经网络根据损失函数得到参数偏导，从而利用梯度下降更新参数的过程<br>(dJ/da[l]=&gt;dJ/da[l-1],dW[l],dB[l])。<br>一个神经元从输入到输出的过程也可以用下面这张图表示，即x-&gt;z-&gt;a：</p><p>除了线性激活函数，sigmoid激活函数和ReLU激活函数外，再介绍两个激活函数：tanh激活函数和leaky ReLU激活函数。他们分别是sigmoid激活函数和ReLU激活函数的同位替补。</p><p>其中tanh激活函数的值处于[-1,1]之间，其具有基值为0的特点，在处理非二元分类问题时通常比sigmoid激活函数更有优势，因而除了二元分类问题，适合使用sigmoid激活函数的场合都可以使用tanh激活函数替代。<br>而leaky ReLU激活函数在负值区域（0.01可以修改为任意小值）具有斜率，可以避免ReLU激活函数在负值区域斜率为0的缺点，而在实际使用时使用ReLU还是leaky ReLU激活函数不会产生特别大的差别，故大部分场合使用ReLU激活函数就可以了。<br>使用ReLU或者leaky ReLU激活函数作为隐藏层激活函数会使神经网络的效率相比于使用sigmoid和tanh激活函数高出不少。</p><p>常见激活函数的导数如下：</p><p>神经网络的矢量化：对神经网络的矢量化既涉及不同的神经元，又涉及不同的训练数据。<br>1.前向传播的矢量化：<br>对于同一训练数据而言，当其经过一个有n个神经元（换句话说就是有n个输出）和m个输入（换句话说就是上一层有m个神经元）的网络层时，基于公式可知，该层的[w][l]是一个n<em>m的矩阵，而该层的[b][l]和输出aj[l]是一个n</em>1的向量。<br>而对于一组训练数据样本而言，我们可以用矩阵X表示数据样本集，其中X的每列代表一个数据样本，而每行代表一个数据样本的不同输入。假设样本个数为m，每个样本的输入个数为n，则X的规模为n*m：</p><p>由于单个样本时的X规模为(n*1)，因而[w]和[b]的规模都不需要修改，对X的矢量化会自动对Z和A矢量化，即Z和A的每列都会是不同样本的值，而横向则是不同的神经元。</p><p>2.反向传播的矢量化：假设每层神经元输入输出满足：z[l]=W[l]a[l-1]+B[l],a[l]=g<a href="z[l]">l</a><br>则按照反向传播规则，对于每个样本来说，有：<br>①dL/dW[l]=dL/dz[l]<em>dz[l]/dW[l]=dL/dz[l]</em>a[l-1]T<br>②dL/dB[l]=dL/dz[l]<br>③dL/dz[l-1]=dL/dz[l]<em>dz[l]/da[l-1]</em>da[l-1]/dz[l-1]=W[l]T<em>dL/dz[l]</em>g[l-1]’(z[l-1])<br>以此类推得到反向传播递推式，从而可以反向传播得到各偏导值，而最后一层的dL/dz[l]值可以由dL/da[l]<em>da[l]/dz[l]=dL/hat{y}</em>hat{y}/dz[l]直接得到。<br>如果要扩展为样本总集的矢量化，由于dJ=1/m<em>∑(dL)，则有：<br>Z[l]=W[l]A[l-1]+B[l],A[l]=g<a href="Z[l]">l</a><br>①dJ/dW[l]=1/m</em>dJ/dZ[l]<em>dZ[l]/dW[l]=1/m</em>dJ/dZ[l]<em>A[l-1]T<br>②dJ/dB[l]=dJ/dZ[l]<br>③dJ/dZ[l-1]=dJ/dZ[l]</em>dZ[l]/dA[l-1]<em>dA[l-1]/dZ[l-1]=W[l]T</em>dJ/dZ[l]*g[l-1]’(Z[l-1])</p><p>深度神经网络是指有很多隐藏层的神经网络，它的优势在于：它可以让前面的神经层学习一些级别较低的简单特征，而让后面更深的神经层汇聚前面所检测到的简单信息以便检测更复杂的事物。<br>我们把神经网络的层数、每层的神经元数量、每个神经元用到的激活函数、总迭代次数、学习率α称为神经网络的超参数，而把[W]和[B]称为参数。即超参数是可以认为设置的，而参数则是神经网络自己学习而来的。大量事实表明，神经网络超参数的可选性是很高的，且要找到一个最佳的超参数组是没有理论和系统方法的，对于不同的神经网络，超参数的最佳取值也会不同，因而在构建神经网络时应该大胆尝试超参数的选值，并利用交叉验证集以寻求一个不错的结果。<br>在机器学习中，我们了解了神经网络的正则化，事实上那种正则化方法被称为L2正则化，而正则化作为一个泛类，还包含了其他很多方法，但其目的都是为了解决过拟合问题，我们再介绍一个被称为随机失活的正则化方法：<br>随机失活(Dropout)：仿照L2正则化引入正则化项以整体减小w的目的，随机失活指出，我们遍历每层网络层的每个神经元，并为每层网络层设置一个留存率(keep-prob)，对该层上的每个神经元进行一次随机留弃，决定丢弃的各神经元会被切断所有的输入输出通路。随机失活的结果会带来一个比原有神经网络小得多的新神经网络，并对该神经网络进行前向和反向传播。其原理即把某些神经元的[W]和[B]参数完全置0，其效果类同于L2正则化减小w。换个角度思考，因为我们可能把任意的神经元失活，这会促使神经网络在学习参数时不过度依赖于某个输入特征，进而将w更均匀且更小的分配给每个输入特征。</p><p>对于每一层，由于随机失活消去了一部分的神经元，这会导致该层的输出期望改变为原来的输出期望乘以留存率；为了保持输出期望不变，我们最后还要对随机失活处理后的输出值除以留存率才能作为下层输入。</p><p>在新的一次迭代时，神经元的留弃会被重新确定。同时，正如L2正则化只在训练集中起作用一样，随机失活也只会针对训练集，而对于测试集数据，我们只会使用完整的神经网络而不进行随机失活。对于不同的网络层，我们可以使用不同的留存率，对于输入输出关系越复杂的网络层（上层和下层都有很多神经元），越有可能产生过拟合，就越可以采取较低的留存率，可见留存率也是一个可供选择的超参数。<br>随机失活的缺点在于，它让代价函数变得不够明确，因为每次的随机失活都会导致代价函数发生变化，当你想要去检验梯度下降算法表现时，你很难确认代价函数真的随着迭代减小了。<br>随机失活常常用于计算机视觉领域。<br>梯度消失与爆炸：<br>深层的神经网络会受制于梯度消失与爆炸的问题，具体表现为权值[W]随着层数产生指数级减小或增大的现象，这会导致训练神经网络时梯度的计算结果会过小或过大，进而影响训练效率和效果，而这个问题始终是训练深层神经网络的巨大壁垒。为了减弱梯度消失和爆炸的影响，我们可以在神经网路的权值[W]初始化中下功夫：<br>数学证明，对于ReLU类的激活函数和tanh类的激活函数，我们可以使用不同的权值初始化方法来达到减弱梯度消失和爆炸的效果。<br>对于ReLU类的激活函数，我们可以使用Xavier初始化(Xavier Initialization)，具体地：<br>让权重[W]满足均值为0，方差为sqrt(2/n)的正态分布，其中n为该层网络层的输入个数。<br>而对于tanh类的激活函数，我们可以使用Kaiming初始化(Kaiming Initialization)，具体地：<br>让权重[W]满足均值为0，方差为sqrt(1/n)的正态分布，其中n为该层网络层的输入个数。<br>此外，也有一些其他的权值初始化方法，例如让权重[W]满足均值为0，方差为sqrt(2/n+m)的正态分布，其中n为该层网络层的输入个数，m为该层网络层的输出个数。<br>如果你觉得有必要，也可以把权值初始化方法当作超参数经由交叉验证集检验。</p><p>梯度检验：<br>当我们算出一个函数的偏导公式时，如何检验这个公式真的准确无误又或是可能因为马虎写错了呢？此时就要使用我们的梯度检验，所谓的梯度检验事实上就是导数检验。<br>如果要得到一个函数对应导数的数值解，可以使用双边公式f’(x)=[f(x+ε)-f(x-ε)]/2ε，其中ε是一个很小的值，然后拿这个数值解与导数的解析解f’(x)=[f(x)]’做比较，就可以检验导数的解析解是否真的是对的了。对应到反向传播算法中，我们如何检验dJ/dW和dJ/dB的公式准确无误呢？我们只需要将[W]和[B]组合成一个大的矩阵[θ]，并根据代价函数得到J([θ])，然后对每一项θi都进行一次双边公式得到数值解并与解析解J’(θi)作比较即可。</p><p>比较的方法是，两值的欧氏距离与他们各自与原点的欧氏距离之和的比值：</p><p>如果结果介于10-7-10-5之间，说明梯度检验通过，导数并没有解析问题，反之则要好好检查。值得注意的是，如果J有L2正则化项，则求导数的解析解和数值解时都应该要带上该项；且梯度检验不适用于随机失活方法中，因为此时的J不具有参考价值。</p><p>神经网络的小批量(Mini-Batch)梯度下降法（称为随机梯度下降SGD）：在神经网络中同样也有小批量的概念用于处理大规模的样本集。将大规模的样本集平均分为相等的几部分，每部分分别记为X{t}和Y{t}，对于每个部分进行一次梯度下降的迭代，并在下一部分继承上一部分迭代得到的参数，故n部分的小批量梯度下降总共需要做n次梯度下降。由于只采用部分数据，因此它的每一步在接近全局最小值时可能不够可靠甚至有些嘈杂，有时甚至会背离最小值移动，但它整体仍沿着趋向全局最小值的方向运动。但其优势在于当训练集很大时，它仍然能以较快的速度完成每一步迭代，这也是为什么当训练集很大时我们总是去使用小批量梯度下降法。</p><p>其他的梯度下降算法：<br>梯度下降算法有很多更好的变体，例如之前学过的Adam算法，这里我们从理论上解释其优化原理。在此之前，我们先介绍指数加权平均的思想。<br>指数加权平均曾在软更新中得到过应用，其公式即：</p><p>其中vt是本次的加权平均结果，vt-1是上次的加权平均结果，θt是本次的原始结果，β是介于(0,1)之间的权重因子，通常取β=0.9。<br>上式是一个递推式，如果写成一般式，即：</p><p>可以看到，指数加权平均结合了所有的过去数据来得到最终结果，且当前的原始结果是最大参照项。利用指数加权平均，我们结合了过去数据和本次数据，从而得到了一个值得信赖的结果。且由于指数加权平均的递推公式，使得其在编程中非常容易实现，其中递推终点为v0，定义v0=0。这样进行指数加权平均有一个问题，由于v0=0，故在前几次迭代中平均值vn和原始值θt会相差很大，例如v1=0.1θ1，v2=0.09θ1+0.1θ2…为了解决这个问题，我们引入偏差修正的概念：我们发现，θ的各系数是一个等比数列，其和为(1-βt)，因而如果我们把最后的结果再除以(1-βt)就可以得到一个比较合理的归一化结果，且当t趋于无穷时(1-βt)趋于1，就和原来的指数加权平均公式类似了，偏差修正主要为了平和迭代次数较少时平均值和原始值的差距。例如v1=0.1/0.1θ1，v2=(0.09/0.19)θ1+(0.1/0.19)θ2<br>①动量梯度下降(Momentum Gradient Descent)：<br>在运行一般梯度下降时，我们可能会遇到下面的情况：</p><p>动量梯度下降希望加快横轴方向的学习速度，减缓纵轴方向的学习速度，此时就可以用指数加权平均的思想。在每次迭代计算出原始值dW和db后，利用指数加权平均得到计算值vdW和vdb，并使用指数加权平均后的计算值来更新W和b，其公式即：</p><p>由于我们要迭代多次且只取最后的迭代结果，因而没有必要进行偏差修正，且通常仍取β=0.9。<br>②均方根前向传播(Root Mean Square Prop=RMSprop)：<br>其公式与动量梯度下降类似，仍然是利用指数加权平均的思想。只是此时的原始值为dW和db的平方，记计算值为Sdw和Sdb，更新参数为dW/sqrt(Sdw)和db/sqrt(Sdb)。</p><p>通常取β=0.999。<br>当然，运用均方根前向传播时可能碰到的问题在于，Sdw和Sdb可能会非常小以至于dW/sqrt(Sdw)和db/sqrt(Sdb)趋于无穷，这不利于算法的稳定。解决办法是在分母加一个小量ε，通常取ε=10-8。即：</p><p>③Adam算法(Adaptive Moment Estimation)：<br>Adam算法结合了动量梯度下降和均方根前向传播，被认为是运行梯度下降的最佳权威算法。<br>记动量梯度下降的相关参数为：vdW，vdb，β1。<br>记均方根前向传播的相关参数为：SdW，Sdb，β2。<br>初始时，令vdW，vdb，SdW，Sdb均为0，在每次迭代时遵循以下规则：</p><p>即利用动态梯度下降的方法计算出vdW，vdb，利用均方根前向传播的方法计算出SdW，Sdb，然后对vdW，vdb，SdW，Sdb进行偏差修正，最后的更新量为vdW/(sqrt(Sdw)+ε)，vdb/(sqrt(Sdb)+ε)。<br>参数的选择一般直接取默认值β1=0.9，β2=0.999，ε=10-8。</p><p>学习率衰减(Learning Rate Decay)：<br>加快学习算法的另一个方法是随时间慢慢减少学习率α，这么做的话可以让开始时有一个较大的学习率，从而加快学习速度；同时快要结束时有一个较小的学习率，从而能够更加细致地探查局部最小值，从而达成收敛，避免耗费无意义的时间在低谷附近反复摆动。<br>衰减学习率的方法也有很多，下面简单介绍几种：<br>①：其中decay-rate为衰减率，是一个超参数；epoch-num为迭代次数，α0是初始学习率。</p><p>②：其中0.95可以是任意小于1的值</p><p>③：</p><p>利用上面三种方法，可以使学习率α随着迭代次数epoch-num增加而减小。</p><p>接下来让给我们看一下局部最优的问题：<br>曾经我们被教导，梯度下降算法可能会陷入局部最优中而无法找到全局最优。但事实上，对于大型神经网络组成的高位空间而言，其存在局部最优的可能性是很小的，其整体图形大概率不是左边的峰谷型而是右边的马鞍形。这是因为局部最优产生的条件是，对于每个维度而言都在该处取到极小值，如果我们认为各维度下导数为零的点是极小值或极大值的概率均等，则对于n维空间而言，导数为零的点会产生局部最小值的概率仅为0.5^n，这对于高维空间而言几乎是不可能出现的，而导数为零的点更有可能出现右边的马鞍形结构，称该点为鞍点(Saddle Point)。即部分维度在鞍点取到极小值，部分维度在鞍点取到极大值。</p><p>对于马鞍形结构，梯度下降算法是有能力破局的。假设起点如下图所示，依照梯度理论，损失函数将逐渐下降到鞍点，并在鞍点附近因为随机扰动离开鞍点，往某一边继续进行梯度下降，从而完成破局。当然，存在的问题在于鞍点附近的导数接近于0，这可能会导致梯度下降算法在鞍点附近花费较长的时间，而这也是Adam等算法脱颖而出的原因。</p><p>综上，在高维度的神经网络中，我们通常不用去担忧梯度下降算法可能会陷入局部最优的问题，但鞍点的存在同样会导致梯度下降算法在鞍点附近花费较长的时间，幸运的是，Adam等算法的问世有效的提高了梯度下降在鞍点附近的效率。</p><p>在之前的学习过程中，我们学习了很多的超参数。例如学习率α，Adam算法中的β1，β2和ε，神经网络的层数，每层神经网络神经元的数量，学习率衰减参数，小批量更新的规模等。这些参数的调整也存在一定的优先级，一般来说，学习率α总是最重要的，其次是每层神经网络神经元的数量和小批量更新的规模，再其次是神经网络的层数和学习率衰减参数，而Adam算法中的β1，β2和ε通常直接取默认值就可以，无需更改。现在的问题是，对于一个完全陌生的神经网络，我们如何为这些超参数选值呢？<br>一个很好的方法是对所有的超参数在给定的可能最优范围内随机取值并重复多次，找到这些取值里效果最好的一组或几组超参数集合，并缩小可能最优范围到这些超参数附近，再次重复上述步骤，直到认为找到了接近全局最优的超参数。即随机选取与逐级精细。</p><p>对于可能最优范围内的随机取值，需要根据范围选择使用自然坐标轴还是对数坐标轴。例如[50,100]内的随机取值用自然坐标轴更好，而[0.0001,0.1]或[0.9,0.999]内的随机取值用对数坐标轴更好。对数随机在Python中的实现可以参考以下代码（以[0.0001,0.1]为例）：<br>n=-3*np.random.rand()-1;<br>result=10^n;<br>return result;</p><p>补充知识：关于归一化、标准化和正则化<br>归一化（Normalization）：把数据变为（0，1）之间的小数，比如min-max归一化。主要是为了方便数据处理，因为将数据映射到0～1范围之内，可以使处理过程更加便捷、快速。<br>标准化（Standardization）：数据的标准化是将数据按比例缩放，使之落入一个小的特定区间。并不是为了方便与其他数据一同处理或比较，比如:z-score标准化，即零-均值标准化,数据经过零-均值标准化后，更利于使用标准正态分布的性质，进行处理；<br>正则化（Regularization）：用一组与原不适定问题相“邻近”的适定问题的解，去逼近原问题的解，这种方法称为正则化方法。利用先验知识，在处理过程中引入正则化因子(regulator)，增加引导约束的作用，比如在逻辑回归中使用正则化，可有效降低过拟合的现象。</p><p>Batch归一化(Batch Normalization)：<br>在之前的学习过程中，我们意识到对于神经网络和一般的线性或逻辑回归而言，对输入变量进行归一化或正则化可以有效的改善程序运行效率。事实上，我们对于隐藏层的各层结果也可以进行归一化，这被证明可以加快神经网络的学习速度。其基本过程如下：</p><p>首先需要注意的是，我们要进行Batch归一化的对象是各隐藏层的[z]，由z[l]=W[l]a[l-1]+B[l]，我们先接受上一层的输入，再经W和B得到z[l]，之后对z[l]进行Batch归一化（Batch归一化的过程在后面详述）得到tilde{z[l]}，最后对tilde{z[l]}进行激活得到a[l]=g<a href="tilde{z[l]}">l</a>作为下一层的输入。可见相比于一般的神经网络，Batch归一化在a=g(z)上额外加了一步算法。<br>现在让我们看看这步算法究竟干了什么，我们采用z-score标准化的逻辑：<br>首先，我们假设在逻辑层[l]上存在n组样本数据z(1)~z(n)，利用这些数据我们计算出该层z的均值和方差，从而利用z-score标准化变换得到均值为0，方差为1的数据集znorm（为了防止分母为零加了小量ε），但是我们不希望要求神经网络对z有一个明确的分布，因此tilde{z}是znorm线性化的结果，其中γ和β都是由神经网络通过梯度下降等方法训练更新迭代而来的参数，其性质和更新过程等同于w和b。</p><p>Batch归一化能奏效的原因是它限制了前层的参数更新影响数值分布的程度。<br>值得指出的一点是，Batch归一化下每层的学习参数似乎有四个w,b,γ和β，但由于要对z进行z-score标准化为均值为0，方差为1的数据集，因此参数b的取值是无意义的，可以不进行学习而固定为0，从而减少学习参数为三个w,γ和β。此外，实际应用时Batch归一化常与小批量更新mini-batch共用，故此时对于每个mini-batch而言，其均值和方差的计算均是基于该mini-batch对应的数据集得到的，即对于不同的mini-batch来说其均值和方差是不同的，和真正全局的均值和方差之间是存在噪声的，这也是mini-batch的一个特性。<br>而当模型训练完毕后使用测试集测试训练效果时，如何为测试样本选择均值和方差呢？<br>我们通常采用指数加权平均的方法，即不选择任一mini-batch的均值和方差作为最终测试用的均值和方差，而是使用指数加权平均将每个mini-batch的均值和方差综合纳入最终的考量。<br>机器学习策略：<br>1.正交化（解耦）：<br>所谓正交就是一个参数的调试只能影响一个结果，在调试过程中，我们应尽量避免一个参数的调试会同时改变多个结果，那么这个参数将会很难调整出一个多维都很完美的结果。就像调整电视屏幕一样，我们安排三个旋钮，其中一个只调整屏幕宽度，一个只调整屏幕高度，一个只调整屏幕角度，如此只需要对不同旋钮分别操作就可以得到一个很好的结果，反过来，如果一个旋钮可以同时控制屏幕宽度和屏幕角度，那么这个旋钮很难调出一个好结果。反映到深度学习领域，判断一个模型的好坏主要要参照四个参数：训练集的适配程度，交叉验证测试集（也叫开发集dev set）的适配程度，测试集的适配程度，在真实情况下的表现。为了分别调整这些参数，我们显然也要采用四个正交化的旋钮，保证在改变一个数据集适配程度时不影响其他数据集的适配程度。例如改变训练集的适配程度可以采取更大的神经网络或更好的梯度下降算法</p><p>2.单一数字评估指标：<br>有时候，我们判断一个模型的好坏可能会涉及多方面的参数，要一一比较这些参数的好坏是很困难的，最好的解决方法是给出一个由这些参数根据某个函数计算出的综合结果，也即所谓的单一数字，利用该数字做升序或降序排列便可以很好的评估不同模型的效果。典型的例子是精确率和召回率的矛盾，以及F1 Score的提出。<br>3.满足指标和优化指标：<br>有时单一数字评估指标并不是特别容易得到，应对这种多参数问题的有效方法是设置满足指标和优化指标。所谓满足指标是指一旦指标满足要求就被认为可行，而不在意该指标到底有多好；所谓优化指标是需要尽可能优化到最佳的指标，两者结合选择出最佳模型。例如下图是一个辨识猫的神经网络，我们设置满足指标为Running time&lt;100ms，优化指标为Accuracy。则符合满足指标的为A和B，取优化指标最佳的则最佳模型为B。</p><p>4.训练、开发、测试集的划分：<br>要求数据集中不同类型(Distribution)的数据被按比例均分到每个集中，而不是将某个类型全分到训练集中，而把另一类型全分到开发集中。开发集和测试集的数据量对于不同体量的神经网络差别不是很大，这意味着随着数据集的增大，训练&amp;开发&amp;测试集的占比不是一成不变的。一般开发和测试集数据量在1w左右，对于小型神经网络而言三集比例一般在60-20-20左右，而对于大型神经网络可以扩大到98-1-1。<br>5.优化神经网络：<br>调整评估指标：当原有的评估指标认为最佳的神经网络模型经人为检验存在问题时，就有必要调整评估指标。<br>改变开发-测试集：开发-测试集作为检验实际运行的样本，需要确保与实际过程的匹配。例如辨别猫的神经网络，人们拍出的照片往往模糊而构图不专业，此时若以一些高清而专业的照片作为开发-测试集，会因脱离实际情况而存在误差。<br>用人的表现衡量神经网络：在机器学习中提到过相应的概念，为了衡量神经网络的效果，通常需要有一个基准误差，这个基准误差应当是理论最低误差，也被称为贝叶斯最优错误率，但一般而言，选取人类在该问题上的误差就可以得到一个很好的基准了。利用训练集误差与基准误差的差值，交叉验证集误差与训练集误差的差值之间的关系可以判断神经网络目前存在高偏差（欠拟合）还是高方差（过拟合）问题，从而选择相应的方法解决问题。在人类擅长解决的领域中（比如自然语言处理），人类误差接近于贝叶斯最优错误率，训练集误差几乎难以超越人类误差，使用这个方法判断神经网络出现的问题是很不错的；而在人类不擅长解决的领域中（比如大数据分析），神经网络学习得到的训练集误差是可以超越人类误差的，当训练集误差超越人类误差时，对神经网络下一步改进的思路便会变得复杂，难以预料。</p><p>误差分析：所谓误差分析，即人类在系统判断错误的样本中抽取一部分来观察出错的原因，并取其中占比较大的优先解决。我们可以为样本集添加大量由最大原因导致的同类错误样本来集中训练神经网络在这方面的缺陷。误差分析适合该任务人类擅长时，可以作为指导方向的参考，避免花了大量精力解决了一个可能不是那么重要或者占比不是那么大的出错原因。<br>清除标注错误的数据：有时训练集中的数据标注可能有误，例如把一张明明是狗的图片标注为猫，如果在进行误差分析时认为标注错误的数据占比较大，则可以进行重新标注。但一般而言，随机性的标注错误并不会对高鲁棒性的神经网络造成很大的影响。<br>6.初始化神经网络原则：<br>在开始搭建神经网络时，一般不考虑任何可能会导致误差和干扰的因素，要求快速构建起神经网络并迭代，而后分析其结果，根据结果来决定下一步做什么，解决哪些关键的干扰和误差因素。</p><p>不匹配数据的神经网络：<br>仍以辨别猫的神经网络为例，人们拍出的照片往往模糊而构图不专业，此时若以一些高清而专业的照片作为训练集训练神经网络，会导致训练数据与实际数据的不匹配而难以得到很好的效果。例如有20w个高清照片和1w个人们拍的照片，我们不希望直接对人们拍的照片进行模型训练，因为训练样本太少了；我们也不提倡按之前讲的将不同类型的数据按比例均分到每个集中，因为我们真正希望模型分辨的是人们拍的照片，假设选取2500个开发集数据的话，如此均分则人们拍的照片只有119张，而开发集的目的在于告诉我们模型在真实数据下的表现，显然均分得到的开发集将会花费大量精力处理那些高清图片上，这不是我们想要的。一个合适的选择是，选取20w高清图片和5k张模糊图片组成训练集，再选取各2500张模糊图片组成开发集和测试集，这么做的好处在于开发集中的所有数据均来自于我们真正关心的图片分布，但这么做也会带来一个问题，那就是训练集中大部分数据仍是高清图片，如此训练得到的神经网络在实际模糊图片的输入下可能达不到一个很好的效果。<br>要解决这个问题，我们首先要知道怎么判断不匹配数据的神经网络的效果好坏：<br>我们假设基准误差为0，如果训练集误差为1%，开发集误差为10%，对于一般的神经网络我们可以认为其具有高方差的问题。但对于不匹配数据的神经网络，由于开发集与训练集的数据并非来自同一类别，开发集误差高究竟是因为模型训练的差还是两者数据不匹配程度高是很难有定论的，解决方法是将训练集拆出一部分作为训练-开发集(Training-dev Set)，训练-开发集不参与模型训练，而专门用于检测模型训练的结果。由于训练集和训练-开发集属于同一类型，故训练得到的模型经过训练-开发集的验证可以得到模型训练效果，也就是说训练-开发集承担了一般神经网络中开发集的作用。而训练-开发集与开发集的比较则可以看出数据的不匹配程度。</p><p>于是五者之间的关系如下：基准误差与训练集误差反映了偏差，训练集误差与训练-开发集反映了方差，训练-开发集误差与开发集误差反映了数据的不匹配程度，开发集误差与测试集误差反映了对开发集的过拟合程度。</p><p>如果出现高偏差或高方差的问题，可以参考之前的方法解决；而若发现数据的不匹配程度较高，一个很好的方法是进行人工数据合成，比如语言识别的训练集没有背景音，而实际应用时嘈杂的环境可能存在各种噪声，我们可以为原训练集增加背景噪声作为新训练集来训练神经网络，这被证明可以有效减小数据的不匹配程度，也就是提高了训练集与实际的接近程度。<br>端到端(end-to-end)的深度学习：<br>在了解端到端深度学习之前，我们先来看看一般的神经网络是怎么解决问题的。<br>以语音识别转文字模型为例，一般情况下它需要经过提取低层次特征，寻找音位，发现单词，最终得到文字这几个过程；以人脸识别系统为例，它需要经过提取画面中所有人脸，拿出人脸与数据库中的人脸进行比对的过程。相比于这种多阶段的流水线工程，端到端的强大之处在于它可以输入音频，并经过神经网络直接得到文字。端到端深度学习需要建立在庞大的数据库和神经网络的基础上，只有大量的数据集才能让神经网络尝试完成这种映射，真正的做到了让数据说话，减少了人类思维对神经网络过多的干预。端到端深度学习具有良好的发展前景，但在当下，让神经网络得到人类的干预会是更好的方法。</p><p>卷积神经网络：<br>基于深度学习的计算机视觉得到了巨大发展，可以承担诸如图片分类，目标检测等多种功能。但在应用计算机视觉时，有一个严峻的考验。对于大型高清的图片，它的输入变量规模约可以达到1000<em>1000(尺寸)</em>3(信道)=3m，这是很大的一个输入变量，如果放到一个有1000个神经元的输入层，其参数规模将会达到3m<em>1k=3b，这是不能承受的。而卷积神经网络为我们提供了一个解决办法。<br>相比于密集层可以得到上一层的所有激活作为输入，卷积层的每个神经元只能得到上一层的部分激活作为输入，换句话说，卷积层的每个神经元只能看到上一个网络层的一部分。<br>于是一个卷积层的基本架构包含四部分：上一层的输出（原始输入），过滤器(filter)，过滤后的输入，线性化和激活后的输出。其中过滤器是卷积层的核心，过滤器是一个f</em>f的矩阵，其中各矩阵元素可以给定，但在当下的深度学习框架下这些参数一般就是我们要利用反向传播算法学习的参数，基本原则仍然是代价函数和梯度下降，其地位等同于w和b，显然一个f<em>f的过滤器就有f</em>f个学习参数。它会按序遮罩输入层的各部分，并对原始输入和过滤器相同位置的元素进行标量相乘后相加，将结果放入过滤后输入矩阵的对应位置。值得注意的是，过滤器只有在完全包纳于上层输出时才会过滤元素，否则将会跳转到下一位置，跳转逻辑是从左至右，从上至下。<br>填充(Padding)：由卷积规则，对于n<em>n的输入矩阵和f</em>f的过滤器而言，得到过滤后的输入矩阵规模为(n-f+1)<em>(n-f+1)。这里要引出两个概念，分别是Valid卷积和Same卷积，其中Valid卷积是不经过填充的卷积，由上式可知对于任意f&gt;1的过滤器而言，经过逐层卷积后的矩阵规模必然会越来越小，这有时会导致深层数据的规模过小而不足以训练参数；而Same卷积则经过填充来使输出的过滤结果与输入矩阵规模相同。而填充就是将原始输入扩大几圈的操作，其中填充元素均取0，这么做的好处是能使位于原始输入边缘的元素也能被卷积多次，从而增强边缘元素对模型训练的作用，记填充圈数为p，则填充p圈后再过滤得到的矩阵规模为(n+2p-f+1)</em>(n+2p-f+1)。要做到Same卷积，则填充圈数应满足n+2p-f+1=n，即p=(f-1)/2。<br>为了方便实行Same卷积，以免p不是一个整数，故f通常取奇数；此外，f取奇数还有一个好处是是可以找到过滤器的中心点，方便在程序里表示出过滤器的位置。<br>步长(Stride):步长就是过滤器跳转到下一位置距离当前位置的长度。之前的讲解都是基于步长为1的情况，如果假设原始输入矩阵为n<em>n，过滤器为f</em>f，填充为p，步长为s，则过滤后的输入矩阵规模即为（其中符号⌊⌋为向下取整）：</p><p>以上的讨论均基于二维卷积，实际应用时三维卷积更加常见，即增加了信道的维度。对于三维卷积，则过滤器也是三维的，且过滤器的信道数与原始输入的信道数保持一致，卷积计算的规则仍是过滤器遮罩部分相乘再相加，只不过此时过滤器遮罩的是一个三维立体，用包裹会比遮罩更形象。由此，三维卷积过滤后的输入仍然是一个二维矩阵。如果要使过滤后的输入是一个三维张量，可以对原始输入同时使用多个过滤器，每个过滤器分别负责不同的功能，并将每个过滤器的结果叠起来以形成三维张量，可见对于一个p=0，s=1，输入为n<em>n</em>nc张量，过滤器为f<em>f</em>nc张量的卷积层而言，其过滤结果规模为(n-f+1)<em>(n-f+1)</em>nc。<br>补充：张量，即Tensor。在数学概念中，张量是一个多维数组，它是标量、向量、矩阵的高维拓展，几维数组就是一个几维张量，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量，一张RGB图片的像素就是三维张量（高度，宽度，信道）。</p><p>于是一个卷积层就可以被描述为：</p><p>以上图为例，输入为一6<em>6</em>3的张量，过滤器为两个3<em>3</em>3的张量，则过滤后的输入为一4<em>4</em>2的张量，为该张量增加总数为nc=2的统一偏差b1，b2得到z，再对计算偏差后的输入z进行激活得到a=g(z)，本例中取g=ReLU，则最后的输出为一4<em>4</em>2的张量作为下一层的输入。该卷积层涉及的学习参数是：第一个过滤器的27个参数w1-w27，第二个过滤器的27个参数w28-w54，偏差b1和b2共计56个参数，相比一般的聚集层减少了很多。<br>最后对卷积层做个总结，如果一个层为卷积层，那么它包含了以下参数：<br>过滤器规模：f[l]        填充圈数：p[l]        步长：s[l]            过滤器数：nc[l]<br>输入张量：nH[l-1]<em>nW[l-1]</em>nC[l-1]                过滤器：f[l]<em>f[l]</em>nc[l-1]<em>nc[l]<br>过滤后输入张量：nH[l]</em>nW[l]<em>nC[l]        偏差：1</em>1<em>1</em>nC[l]        激活：nH[l]<em>nW[l]</em>nC[l]<br>输出张量：nH[l]<em>nW[l]</em>nC[l]<br>其中nH[l-1]和nH[l]，nW[l-1]和nW[l]的关系如下：</p><p>卷积神经网络中除卷积层(Convolution)外，还有池化层(Pool)和全连接层(Fully Connected/FC)。<br>池化层只有超参数f和s（通常取f=2，s=2，如此处理池化层的输出高度和宽度便是输入的一半），没有学习参数，神经网络不从中学习来更新参数；也几乎不进行padding，即p=0。<br>可见对于一个nH<em>nW</em>nC的原始输入而言，其池化层过滤结果为*nC<br>池化层分为最大池化和平均池化两种，最大池化相较于平均池化更加常见。<br>最大池化(Max Pooling)：取过滤器遮罩部分的最大值作为结果得到过滤后的输入。对于多信道原始输入的话，则是对每个信道的遮罩部分均取最大值。最大池化操作的功能在于只要在任何一次过滤内提取到某特征（比如说人脸识别中发现了人眼），它都会被保留在最大池化的输出中，如果没有提取到该特征，那么该次过滤的最大值就会比较小。</p><p>平均池化(Average Pooling)：取过滤器遮罩部分的平均值作为结果得到过滤后的输入。对于多信道原始输入的话，则是对每个信道的遮罩部分均取平均值，</p><p>全连接层：也就是一般的神经网络层，上一层的输入被全部映射到本层的所有神经元。</p><p>常见的卷积神经网络的架构通常同时包含卷积层，池化层和全连接层。单独的卷积层重复叠加是得不到一个很好的卷积神经网络的。根据LeNet-5规定的卷积神经网路架构，卷积层和池化层是共生的，在一个卷积层(CONV)后需要跟进一个池化层(POOL)，由于池化层不存在学习参数，故习惯上把一组卷积层和池化层的组合当做卷积神经网络的一层layer。在前期经历了若干层卷积+池化的组合后，随着卷积神经网络深度的加深，一个常见现象是a[l]的高度和宽度将会逐渐减小，而信道的数量会逐渐增大。在最后阶段，将卷积展开成为一维向量，经过若干层的全连接层（FC，即一般的神经网络层）后进入输出层得到输出。</p><p>该例对应每层的激活规模和学习参数为，可见激活规模正逐渐减小，且全连接层需要的参数数量远远大于卷积层需要的参数数量：</p><p>卷积有两个优势：参数共享和稀疏连接。参数共享表明一个特征检测器可以在输入的任何地方发挥作用，稀疏连接表明每个卷积层的输出均值取决于输入的一部分。</p><p>最后介绍两种特殊的过滤器，垂直边缘检测器与水平边缘检测器，两者分别用于检测图像的水平边缘和垂直边缘，分别定义为：</p><p>利用垂直边缘检测器与水平边缘检测器，我们会得到一个输出矩阵，矩阵各元素偏移零点的程度可以检测图像的水平边缘和垂直边缘，还可以根据值的正负来判断边缘由暗变亮或由亮变暗的趋势。假设输入为灰度图，则有：<br>垂直边缘检测：</p><p>水平边缘检测：</p><p>除了基本的边缘检测器之外，还有其他的边缘检测器：</p><p>当然，现今更流行的仍然是使用神经网络去自己学习边缘检测，这样子得到的边缘检测器不仅可以检测水平或垂直边缘，甚至可以检测各种角度和弧度的边缘。</p><p>对于RGB彩图而言，可以使用三维垂直边缘检测器与水平边缘检测器，即3<em>3</em>3的过滤器张量，每一层可以分别检测RGB某个信道下的垂直边缘与水平边缘，例如下例1检测红色信道边缘，下例2检测RGB各色组合的边缘。</p><p>从之前的讨论中我们可以发现，卷积神经网络中包含了极大量的超参数，这使得在自行构建卷积神经网络时往往无从下手。但好在由于卷积参数共享的优势，在计算机视觉任务中表现良好的神经网络框架往往也适用于其他任务，这使得我们可以参考前人提出的优秀网络架构来训练自己的模型，下面简单介绍几种：</p><p>LeNet-5可以识别图片中的手写数字，它是基于灰度图像训练的，输入为32<em>32</em>1。</p><p>它经过了两层卷积+池化层，两层全连接层。LeNet-5的学习参数大约有60000个。</p><p>AlexNet可以识别图像的基本构造模块，基于RGB彩色图训练，输入为227<em>227</em>3。</p><p>AlexNet的学习参数大约有六千万个。</p><p>VGG-16的功能与AlexNet类似，但它的优势在于其网络架构非常清晰，各超参数之间存在明显关联，而缺点在于其学习参数高达约1.38亿个。</p><p>残差网络(ResNets)：在之前我们讨论过，由于存在梯度消失和梯度爆炸的问题，非常深的神经网络是很难被实现的，而残差网络可以在一定程度上解决这个问题。在介绍残差网络之前，我们先介绍残差块(Residual Block)的概念：</p><p>上图是一个从a[l]到a[l+2]的神经网络，正常情况下a[l]会经历主路径(Main Path)的流程得到a[l+2]，此时我们可以让a[l]通过捷径(Shortcut)或远跳连接(Skip Connection)将信息不经过主路径直接传递到神经网络的更深层。即此时有a[l+2]=g(z[l+2]+a[l])，值得注意的是，远跳连接的介入时刻位于线性激活后ReLU函数前，且由于z[l+2]和a[l]相加的要求，需要z[l+2]和a[l]需要具有相同维度，这在残差网络里是由多个Same卷积实现的。<br>由这些残差块组成的网络就是残差网络：</p><p>残差网络被证明能够有效避免梯度消失与爆炸问题，从而能使人们构建起更深层的神经网络。可以看到，它的构成是多层的Same卷积层穿插少量的池化层，并在最后进行Softmax分类。其能建立更深层神经网络的原因大致在于，前层的输入可以更加容易的进入更深层神经网络，从而可以削弱梯度消失与爆炸的影响。</p><p>1<em>1卷积(1</em>1 Convolution)：<br>即f=1的过滤器，其主要作用是改变信道数量。之前讲到过池化层可以在保持信道不变的基础上改变张量的宽度和高度，而1*1卷积则可以在保持张量的宽度和高度不变的基础上改变信道数量。让我们来看两个例子：</p><p>在上例中，可以看到1<em>1卷积就是对原始输入在对应位置的切片相乘再相加，从而保持张量的宽度和高度不变，而由之前所学，过滤后输入的信道数量就是1</em>1卷积过滤器的个数。在下例中实现了32个1*1卷积过滤器来使原始输入的192个信道缩减为32个。</p><p>Inception网络：鉴于卷积神经网络中大量的超参数难以人工调整，Inception网络提供了一个方法来代替人工确定卷积层中的过滤器大小或是否需要创建卷积层或池化层，也就是让神经网络自己通过学习得到应该选用什么类型的过滤器，或是选择是否应用池化层。Inception网络的选择有四种，分别是应用卷积层1<em>1，应用卷积层3</em>3，应用卷积层5<em>5和应用池化层。以28</em>28<em>192的输入为例，选择应用卷积层1</em>1的规模是28<em>28</em>64，选择应用卷积层3<em>3的规模是28</em>28<em>128（需要进行Same卷积），选择应用卷积层5</em>5的规模是28<em>28</em>32（需要进行Same卷积），选择应用池化层的规模是28<em>28</em>32（需要进行Same池化，这点比较特殊），最后将这些选择全部叠在一起得到28<em>28</em>256的合成张量，让网络自己学习它需要什么样的参数。当然，这么做会碰到的问题是大量的计算成本。<br>例如计算5<em>5的参数时需要进行(28</em>28<em>32)</em>(5<em>5</em>192)=1.32亿次运算</p><p>为了降低计算成本，我们可以先进行一次1*1卷积计算：</p><p>此时计算次数为28<em>28</em>16<em>1</em>1<em>192+28</em>28<em>32</em>5<em>5</em>16=12.4m次，仅为前面的10%。<br>于是Inception网络的每层结构便如下图所示：</p><p>综上所述，在实际应用卷积网络时，我们有很多现成的模版可以套用，这大大较少了我们构建和训练网络的时间。也就是说当我们选定好网络架构后，便可以从github上寻找开源方案，这些网络已经被搭建完毕且经过了预训练，我们便可以使用该网络进行迁移学习。对于极小的训练集而言，可以保持非输出层参数不变而只训练输出层参数；对于稍微大一点的训练集而言，可以训练所有参数，其中非输出层参数的初值为已训练好的神经网络非输出层的参数。当训练集样本数量较少时，可以对图片进行旋转，放缩，扭曲，添加噪声等来对一个示例提出更多具有类似标签的新示例，实现在有限的样本集中添加数据。</p><p>目标定位(Object Location)：之前讲过了图像分类问题，即给出一张图片判断它属于什么类别，其基本思路是将图片喂到训练好的卷积神经网络中，经过卷积+池化层，全连接层和softmax输出层得到类别。</p><p>而目标定位问题是在图片中标记出对象的位置，既适用于单对象又适用于多对象问题。要标记出对象位置，我们需要定位一个矩形（称为边界框bounding box），为此我们补充四个参数bx,by,bh,bw，定义图片左上角坐标为(0,0)，右下角坐标为(1,1)，则bx和by是边界框的中心坐标，bh是边界框的高度，bw是边界框的宽度。<br>我们假设一个模型既要判断图中物体是行人、汽车、摩托车还是背景（三者都不是），又要标记出图中物体的位置，为此输出变量应该包含以下元素：是否存在物体pc，边界框坐标参数bx,by,bh,bw，是否为行人c1、汽车c2、摩托车c3。如果采用平方误差函数作为代价函数，则其函数如下图所示，注意当pc=0时除了pc其他元素的值均无意义，不作为参考。</p><p>特征点检测(Landmark Detection)：以人脸识别为例，相比于标记出人脸的边界框，我们可能更需要若干个标记人眼、鼻子、嘴巴的特征点来确认人脸，如此处理还可以做到判断人的表情等更高级的功能。为此，我们需要准备一个特征点训练集和对应的卷积网络，当输入人脸时输出一个包含各个特征点位置的高维向量。</p><p>目标检测(Object Detection)：<br>我们先介绍基于滑动窗口的目标检测算法(Sliding Windows Detection Algorithm)：<br>所谓的滑动窗口，就是在图片上按固定步长移动的小矩形视窗。我们每次只视察视窗内的物体，判断其中是否含有目标物体。以检测汽车为例，为此，我们先要创建一个标签训练集，其中x是视窗相同大小的图片，y是图片中是否包含汽车来训练一个卷积神经网络。而后，我们对原始图片应用滑动窗口，每滑动到一个地方，就把该窗口输入到训练好的卷积神经网络，判断其中是否含有汽车，如果有，则把此时的窗口作为边界框即可。其中步长和窗口大小可以自由确定。<br>这么做的问题在于计算成本，将原始图片分割成多个部分，再分别输入神经网络。更好的方法是将整张图片直接输入神经网络，而后利用过滤器来卷积出对应的窗口，最后在输出矩阵中反映每部分是否含有汽车。论文OverFeat提除了这种卷积滑动窗口的实现。<br>在此之前，我们先看看OverFeat怎么把全连接层转换成卷积层及其架构规定：</p><p>可以看到，一个n维的FC层可以用n个与上层输入维度相同的过滤器过滤后的结果表示。</p><p>对于任意大小的图片输入，OverFeat都会以这种卷积网络架构进行分析，其实际意义等效于进行大小为14<em>14，步长为2的滑动窗口，而每个滑动窗口的结果都会被保存在输出矩阵的对应位置，例如输出矩阵的第三行第二列的值表示滑动窗口右移两次，下移一次对应窗口是否有汽车。使用卷积来等效滑动窗口使得输入网络只需要一整张图片，大大减少了计算成本。但两者都存在的问题是，由于此时窗口大小是固定的正方形，而实际物体的边界可能是长或高的矩形，这么做可能会导致边界框的不准确，而YOLO算法可以解决这个问题。<br>YOLO算法(You Only Look Once)：<br>YOLO算法将一整张图片均分为19</em>19个小部分，然后对某一个小部分应用图像分类和目标检测算法，每个部分都会输出一个八维向量y，YOLO算法判定一个物体是否在对应部分的方法是查看该物体的中心是否位于该部分内，例如下图中左车位于左中部分，右车位于右中部分，而虽然中间部分含有两车的部分，但由于不存在中心，故认为中间部分pc=0。可见如此处理的网络输出规模为19<em>19</em>8，其局限性在于可能存在一个部分里存在多个物体中心的问题，此时仅凭一个八维输出无法解决，但由于19*19的细分，出现这种情况的概率很低。YOLO的优势在于相比滑动窗口以窗口和步长表示物体的模糊，YOLO的边界框可以具有任意的宽高比和更精确的坐标，且YOLO的均分也是基于卷积实现的，这意味着输入神经网络的仍然是一整张图片而不是某一部分，效率比较高，甚至可以做到实时识别。YOLO对于边界框的坐标规定如下：对于每个部分，认为左上角为(0,0)，右下角为(1,1)，单位长度为均分边。所以bx和by一定是小于1的，而bh和bw则可以大于1（跨部分）。</p><p>交并比(Intersection Over Union/IoU)：算法给出的边界框和实际的边界框之间的交集与并集之比，实际应用目标检测算法时认为当IoU&gt;0.5时，算法给出的边界框与实际的边界框匹配。IoU阈值设置的越高，则算法给出的边界框的匹配程度就越高。<br>非极大值抑制(Non-Max Suppression)：在YOLO算法的实现时，可能存在很多个居于同一物体中心的均分块，它们都有可能判断令pc=1，这时候就可能给出很多个边界框。为了避免这一现象，我们可以先舍去所有pc&lt;=0.6的低概率中心均分块，然后选取pc值最大的中心作为真正的中心，对应的边界框为真正的边界框，并舍去所有与最大可能边界框交并比IoU&gt;=0.5的其他可能边界框，最后重复上一步骤，直到所有的待选中心均分块都被选取或舍去。这么做的好处是它根据pc的最大值确定某个物体最有可能的中心，同时对于不同的物体中心，由于IoU&lt;=0.5，这些可能的物体中心不会被舍去，而是会在之后的循环中被找到。如果要同时判断多个不同类型的物体位置，需要对每个类型的物体判断均使用非极大值抑制。<br>Anchor Boxes：之前提到YOLO算法无法解决一个部分里存在多个物体中心的问题，Anchor Boxes可以解决这个问题，例如下面这个例子，车和人的中心都位于下方这个均分块，此时一个八维向量就无法表示了。需要用更高维的8*n向量，例如用16维向量，其中前八个量用于表示均分块内是否有车及其边界框，后八个量用于表示均分块内是否有人及其边界框。关键就在于怎么区分车和人，这就是Anchor Boxes的作用。Anchor Boxes规定了物体边界的样子，比如车一般是宽而矮的，而人一般是窄而高的。根据YOLO捕捉到物体边界框和规定的Anchor Boxes的交并比来判断捕捉到的物体是车还是人，然后确定向量对应位置的值。Anchor Boxes的选择既可以由人根据需要和训练集的分析预先确定，也可以由神经网络自行学习得到。</p><p>候选区域(Region Proposal)：<br>在常规的目标检测算法中，事实上有很多地方是基本不会检测出物体的，例如下图2中的左下角和右上角，我们可以对图片运行图像分割算法得到图片的色块分布，根据色块的大致形状预测其在对应位置的真实图片里可能存在物体，并同步在对应位置运行分类器来判断是否存在物体，这么做可以减少一些不必要区域的物体判断，且同样可以被卷积神经网络实现。这种算法也被称为R-CNN。</p><p>人脸识别：人脸识别的关键在于比较当前输入的人脸和数据库中的人脸的“相似度”，定义差异函数d(img1,img2)为两张图片的差异程度，显然，比对成功即d(img1,img2)小于等于某个阈值τ，比对失败则d(img1,img2)大于τ。当然，直接拿两张图片给计算机来得到d是很难的，我们可以先把图片输入到训练的卷积网络中，并把某个全连接层作为输出层得到一个图片对应的多维矢量，如果两个图片相似，则它们在同一卷积网络的同一输出层的多维矢量也类似。这个卷积网络被称为Siamese网络架构，输入称为x，映射的多维矢量为f(x)。</p><p>于是两张图片x(i)和x(j)的差异函数便可由两个多维矢量的差异函数表示，而两个多维矢量的差异函数就是两者的欧几里得范数，也就是两矢量对应位置的元素差值的平方和的开方。也就是：‖f(x(i))-f(x(j))‖2。于是如果x(i)和x(j)相似，则‖f(x(i))-f(x(j))‖2小于等于阈值τ；如果x(i)和x(j)不同，则‖f(x(i))-f(x(j))‖2大于阈值τ。</p><p>那么怎么训练能使神经网络实现上述效果呢？反向传播算法仍然可以使用梯度下降及其变体，问题的关键在于使用什么样的损失函数。在此之前，我们先介绍三元组(Triplet)的概念：人脸识别的训练集通常由若干个三元组组成，每个三元组记为(A,P,N)，其中A表示Anchor，是对应人脸的基准图片；P表示Positive，是对应人脸的匹配图片；N表示Negative，是对应人脸的不匹配图片。于是要使神经网络正常工作，差异函数应该满足d(A,P)&lt;=d(A,N)，也就是‖f(A)-f(P)‖2&lt;=‖f(A)-f(P)‖2。当然，为了让AP与AN之间差异函数的值差的足够大，通常会增加一个间隔(Margin)α，即d(A,P)+α&lt;=d(A,N)。</p><p>于是其损失函数可以定义为：L(A,P,N)=max{‖f(A)-f(P)‖2-‖f(A)-f(P)‖2+α,0}<br>如此定义的原因是当d(A,P)+α&lt;=d(A,N)时，认为神经网络正常工作，于是其损失为0；而当d(A,P)+α&gt;d(A,N)时，神经网络不够优秀，需要使用损失限制。<br>而代价函数则是训练集每个三元组的损失函数之和，即：</p><p>人脸识别的训练集通常不会太大，例如1k人只需要约1w张照片即可。但在构建三元组的时候A，P，N的选择通常不会随机，因为这通常会导致正常工作条件d(A,P)+α&lt;=d(A,N)非常容易满足，达不到训练神经网络的效果。于是我们需要选择一些比较由训练难度的APN组成三元组，也就是说选择那些d(A,P)和d(A,N)相差无几的组成三元组，这么做可以训练神经网络参数使d(A,P)变得尽可能小而d(A,N)变得尽可能大。<br>此外，也可以用二分类网络来进行相似度判断：<br>我们同样使用Siamese网络架构，即数据库中的图片和新输入的图片经过同一个网络架构得到输出矢量f(x(i))和f(x(j))，其中数据库图片对应的输出矢量可以进行预处理提前得到。我们通过比对数据库中的图片和新输入的图片对应的输出矢量并传递到Sigmoid单元，根据Sigmoid单元输出结果是0还是1来判断两张图片是否属于同一个人。</p><p>神经风格切换：即两张图片的整合，整合图片G的内容借鉴自内容图C，风格借鉴自风格图S。要判断生成图的结果好坏，可以用下图的代价函数J(G)表示：</p><p>其中J(G)由内容代价函数Jcontent(C,G)和风格代价函数Jstyle(S,G)组成，且有α+β=1。<br>内容代价函数Jcontent(C,G)体现了C和G内容的相似程度，所谓内容，可以直接和前文的“相似度”画等号。其定义仍然是欧几里得范数，其中a<a href="c">l</a>为输入内容图C时神经网络第l层对应的多维向量，a<a href="G">l</a>为输入整合图G时神经网络第l层对应的多维向量。具体地，其定义为：</p><p>风格代价函数Jstyle(S,G)体现了S和G风格的相似程度，风格被定义为同一位置不同信道的多维矢量的相关性。（原文：Define style as correlation between activation across channels）<br>那么相关性是如何决定图片风格的呢？我们可以举个简单的例子看看，假设某个信道可以检测图片中的垂直边缘，另一个信道可以检测图片中橙色的区域，于是这两个信道的相关性决定了这个图片垂直边缘为橙色的可能性，也就是感性理解中的风格。我们可以用两矢量对应元素的乘积来表示相关性。则对于信道数量为nc的输入张量，我们定义nc*nc的风格矩阵Gkk’<a href="S">l</a>为输入风格图S时神经网络第l层对应的信道k和信道k’的相关性，Gkk’<a href="G">l</a>为输入整合图G时神经网络第l层对应的信道k和信道k’的相关性。其具体公式如下：</p><p>对应的代价函数为（其中前面为归一化项）：</p><p>更进一步地，如果想要把每一层的代价函数整合在一起得到一个更加综合风格代价函数，有：</p><p>在得到代价函数后，我们只需对G先随机化后进行梯度下降算法就能学习到不错的结果了。</p><p>卷积的1D和3D推广：其原理和2D大体一致。<br>1D：对于n的输入向量和f的过滤器，假设步长为s，则过滤后的输入结果为floor((n-f)/s+1)</p><p>此外，如果输入有nc个信道，则过滤器也需要有nc个信道。如果有n个过滤器，则过滤后的输入结果规模为floor((n-f)/s+1)*n。心电图和各类信号是典型的1D数据。</p><p>3D：对于n<em>n</em>n的输入张量和f<em>f</em>f的过滤器，假设步长为s，则过滤后的输入结果规模为：<br>(floor((n-f)/s+1),floor((n-f)/s+1),floor((n-f)/s+1))。</p><p>此外，如果输入有nc个信道，则过滤器也需要有nc个信道。如果有n个过滤器，则过滤后的输入结果规模为floor((n-f)/s+1)<em>floor((n-f)/s+1)</em>floor((n-f)/s+1))*n。CT图和视频是典型的3D数据。</p><p>序列模型(Sequence Model)：可以用于训练语音识别，文本处理，机器翻译等问题。序列模型大多为1D模型，即一串时序数据或文本数据。序列模型利用循环神经网络在整个社会的深度学习发展中掀起了极大变革。<br>我们以一串文本数据为例介绍序列数据及循环神经网络的数学符号表示：<br>比如说有以下一段文字数据输入：Harry Potter and Hermione Granger invented a new spell.<br>我们要做的是判断这段文字中可能是人名的单词，即：1 1 0 1 1 0 0 0 0<br>各单词为一个基本输入单元，记为x<t>；判断某单词是否为人名是基本输出单元，记为y<t>。<br>序列x的长度记为Tx，序列y的长度记为Ty，本例中Tx=Ty，但很多时候Tx不等于Ty。<br>如果有多组输入样本，则需要加上样本序号i，即：x(i)<t>，y(i)<t>，Tx(i)，Ty(i)。<br>对于文本这种非数字输入来说，基本思路是要把它先转换成数字输入，为此我们需要引入一张词表(Vocabulary)，其中收录了按序排列的大部分常见单词（推荐选取10000个），这样子就能用单词在词表中的序号代表对应单词了，当然序号作为标量不是很适合，我们可以把它转换成之前学过的独热编码的形式，即x(i)<t>为一个10000维向量，在对应序号的位置的值为1，而其他的值均为0。对于那些不在词表里的单词，可以用<UNK>Unknown统一标识。</p><p>经过上面的讨论我们思考一个问题，为什么序列模型不适用于标准的神经网络？</p><p>可以看到，如果序列数据需要被标准神经网络处理，那么就要构建成上述形式。问题在于，序列数据的输入和输出长度并不是固定的，而且标准神经网络不能做到参数共享，而序列数据作为一种模式相似的学习，很多参数在某个位置的学习是可以反映到其他位置从而加快学习进程的。于是引入循环神经网络的架构：<br>一个标准的多对多单层循环神经网络的架构如下图所示。</p><p>可以看到，循环神经网络最大的特点在于它一层就具有标准神经网络多层的神经元，且每个输入仅占其中的一个标准神经网络层，而每个标准神经网络层都会进行一次输出，同时前一个标准神经网络层的激活和输入会被同时传递到后一个标准神经网络层作为激活。可见某个标准神经网络层的激活a<t>由上层的激活a<t-1>和本层的输入x<t>决定，而某个标准神经网络层的输出y<i>由本层的激活a<t>决定。记a<t-1>影响a<t>的系数为waa，x<t>影响a<t>的系数为wax，影响a<t>的偏移系数为ba；a<t>影响hat{y<t>}的系数为wya，影响hat{y<t>}的偏移系数为by。<br>于是循环神经网络的前向传播关系便可以由下式表述：</p><p>其中激活函数g1通常采用tanh或ReLU，而g2是输出层函数，通常根据输出的要求选择采用二分类的sigmoid或多分类的softmax等。一般规定a<0>=0。<br>在实际应用中，通常将式1的Waa和Wax合并写作矩阵形式，即：<br>a<t>=g1(Wa[a<t-1>;x<t>]+ba)，其中Wa=[Waa,Wax]。假设a是100维列向量，x是10000维列向量，则Waa是100<em>100的矩阵，Wax是100</em>10000的矩阵，ba是100维向量。于是Wa是100*10100的矩阵，[a<t-1>;x<t>]是10100维列向量。<br>学习完了前向传播后，接下来看看循环神经网络的反向传播：<br>循环神经网络的代价函数取决于各输出层对应的损失函数，以判断单词是否为名字的循环神经网络为例，此时的输出显然需要使用二分类的sigmoid函数，故单个输出的损失函数也就是逻辑回归的损失函数，即：</p><p>而最终的代价函数就是每个输出层损失函数之和，也就是：</p><p>由于循环神经网络的反向传播是t从后往前进行的，故也被称为穿越时间的反向传播(Back Propagation Through Time)。</p><p>当然除了上面所说的标准的多对多单层循环神经网络的架构，我们还有一对一单层循环神经网络的架构，一对多单层循环神经网络的架构，多对一单层循环神经网络的架构以及多对多而数量不等的单层循环神经网络的架构，如下图所示：</p><p>比如我们输入一段评价文字，要让网络得到这段文字可能代表的评分，这就是一个多对一的网络，RNN需要在所有输入均接收完毕时才能给出一个输出判断；又或者我们输入一个主题，要让网络输出一段相关的文章，就是一个一对多的网络；又或者机器翻译，我们输入一种语言要求网络翻译成另一种语言，就是一个多对多而数量不等的网络，前半段称为编码层Encoder，后半段称为译码层Decoder。</p><p>语言模型(Language Model)：语言模型的作用是，输入一组文本序列y<1>,y<2>…y<Ty>，然后语言模型会估计该文本序列中各单词出现的可能性P(y<1>,y<2>…y<Ty>)。语言模型常常用于语音转文字和自然语言处理中，比如说我说一句话，模型转文字是如何确定是应该转化成”The apple and pair salad”还是”The apple and pear salad”呢？我们可以调用语言模型发现前者的概率为3.2<em>10-13，而后者的概率为5.7</em>10-10，两者相差近千倍，显然应该选择后者。<br>要想训练这样的语言模型RNN，需要找到对应语言的语料库(Corpus)作为训练集，语料库中包含了大量规范的语言句式，通过学习语料库，可以让语言模型具备理解句式和词汇构成的能力，从而对输入的文本序列进行检验。对于语料库中的句子，仍然是先使用词表和独热编码进行预处理，同时句尾可以用结束符<EOS>标记，如果有需要，也可以把标点加入词表。以这些句子作为训练集训练网络，我们应该怎么做呢？<br>首先我们来看看语言模型RNN是怎么工作的：语言模型RNN的特殊结构是x<t>=y<t-1>，并规定x<1>=0。RNN的每个输出都会利用softmax层预测词典中的任意单词处于句子中t这个位置的可能性，然后将可能性最大的当做hat{y<t>}；从第二层开始，每层的输入x<t>都是上一层实际的单词y<t-1>，也就是在前一个单词为给定的单词时，再让softmax层预测词典中的任意单词处于句子中这个位置的可能性；随着网络的深入，之前所有的输入，也就是前面的所有的单词都会被保留。语言模型RNN每层的工作也就是在给定前面的所有单词时，给出当前位置的单词为词表中的哪个单词的可能性。假设我们输入一段文字”Cats average 15 hours of sleep a day.<EOS>”，第三层的工作也就是得到P(Words in Vocabulary|”Cats average”)的值。而模型的输出也就是P(y<1>,y<2>…y<Ty>)=P(y<1>)<em>P(y<2>|y<1>)</em>…*P(y<Ty>|y<1>…y<Ty-1>)，其中右边的各项均可以从语言模型RNN的各层输出中得到。</p><p>语言模型RNN各层的损失函数即softmax的损失函数：</p><p>对应的代价函数即各层损失函数之和：</p><p>反向传播的训练方法仍然是梯度下降及其变体。<br>当我们训练好一个语言模型后，如果想要检验它的效果，可以使用新序列采样的方法：<br>我们运行一遍训练好的模型，根据模型给出的概率进行采样（比如说模型认为第一个单词为the的概率为90%，为a的概率为10%。那么第一个单词就进行90%为the，10%为a的采样）<br>从第二层开始，每一层都使用上一层的采样结果hat{y<t>}作为输入再进行预测采样（注意不是模型训练过程中的实际结果y<t>），直到采样输出的结果为<EOS>为止就可以得到语句了。<br>除了可以建立基于词汇的RNN模型，还可以建立基于字符的RNN模型。基于字符的RNN模型的词表由大小写字符和各类标点符号组成，其好处是不会存在<UNK>，而缺点在于训练成本高，且序列过长会使得模型难以捕捉句子前后的依赖关系。</p><p>对于较深的循环神经网络，靠后的输出对靠前的输入的捕获能力将会不断减弱，梯度消失的问题仍然会出现。为了让循环神经网络应对这个问题，可以使用GRU单元或LSTM解决，GRU和LSTM可以再循环神经网络中建立起非常深的连接，让我来看看：<br>GRU(Gated Recurrent Unit)门控循环单元：<br>引入几个重要概念：<br>1.记忆单元c<t>(Memory Cell)：提供了记忆能力，当c<t>持续等于某个值时，其对应的特征会被神经网络记忆，比如我们要用语言模型生成一段很长的文本the cat,which…,was full.由于英文语法要求单数cat用was而复数cats用were，我们怎么让网络有能力穿越cat到was这一长段的定语从句呢？这时候就需要记忆单元帮忙，具体地在之后会详细讨论。<br>2.相关门Γr：表示c<t>和c<t-1>的相关性，使用sigmoid函数让其介于[0,1]之间，公式为：</p><p>3.候选值tilde{c<t>}：其公式由c<t-1>递推而来，辅以相关门系数，其公式为：</p><p>由于c<t>和c<t-1>的递推关系与a<t>和a<t-1>的递推关系相同，所以在GRU中，a<t>=c<t><br>4.更新门Γu：表示新旧参数的更新程度，也就是将候选值更新为真实值的程度，使用sigmoid函数让其介于[0,1]之间，公式为：</p><p>5.候选值tilde{c<t>}，记忆单元c<t>和c<t-1>，更新门Γu之间的更新关系满足：</p><p>可见更新门参数Γu越接近1，当前记忆单元c<t>的值由候选值tilde{c<t>}决定；反过来，更新门参数Γu越接近0，当前记忆单元c<t>的值由前一时刻的值c<t-1>决定。<br>综上，GRU单元的前向传播由以下五个公式决定，而其中的W和b均由学习得到：</p><p>于是对于给的例子，GRU要做和学习的就是在发现主语the cat时，让c<t>=1记忆该特征，随后在之后的网络深入中令更新门Γu保持为0，即c<t>=1，该特征被始终记忆，最后在找到谓语时根据记忆的结果输出was，同时记忆结果将可以被遗忘，故可以令Γu=1，即c<t>=0。</p><p>长短期记忆(LSTM)：<br>记忆细胞c<t>的概念仍然不变，相比于GRU由两个门Γr和Γu组成，LSTM由三个门组成：<br>1.更新门Γu：沿用GRU单元的概念<br>2.遗忘门Γf：相比于GRU用1-Γu表示对之前记忆参数的遗忘程度，在LSTM中使用专门的遗忘门参数Γf来表示对之前记忆参数的遗忘程度，即：</p><p>3.输出门Γo：相比于GRU直接令a<t>=c<t>，LSTM中的a<t>和c<t>之间存在比例函数关系，即：</p><p>综上，LSTM的前向传播由以下六个公式决定，而其中的W和b均由学习得到：</p><p>有时，在学习参数Γu，Γf和Γo时，除了a<t-1>和x<t>外还会加入c<t-1>，这样的LSTM变体也被称为窥视孔连接(Peephole Connection)。观察LSTM的网络架构可以看到，浅层的输入c<0>可以比较容易的通过一条直线深入到网络内部，这也是为什么LSTM可以解决梯度消失。</p><p>比较GRU和LSTM，由于GRU只由两个门组成，因此它在架构上更加简单，运行速度也更快；而LSTM则更加强大也更加灵活，在大型RNN中更加喜好LSTM架构。</p><p>双向循环神经网络(Bidirectional RNN/BRNN)：<br>我们仍以判断文字是否为人名的RNN为例，我们看以下两句话：<br>He said:”Teddy bears are on sale.”<br>He said:”Teddy Roosevelt was a great president.”<br>如果使用单向循环神经网络，我们只能依赖之前的单词做出判断，而这两句话的前三个单词完全一致，由此判断Teddy是否为名字显然是不可能的。故我们要使用双向循环神经网络BRNN，使神经网络可以同时依赖前方和后方的单词做出判断。</p><p>一个典型的BRNN结构如上图所示，其中每层的激活都包含由左至右和由右至左两个部分。<br>其中由左至右的激活从a-&gt;<1>开始前向传播到a-&gt;<4>，而由右至左的激活从a&lt;-<4>开始前向传播到a&lt;-<1>。此时激活的递推公式不变，只是存在了两个方向而已。而同一个输出由于存在两个激活，故递推公式修改为：</p><p>利用BRNN，在预测一个输出时，我们既可以参考之前的数据，也可以参考之后的数据。例如求解hat{y<3>}时，过去的数据x<1>和x<2>可以从由左至右的激活通道进入，未来的数据x<4>可以从由右至左的激活通道进入。<br>在实际应用时，往往使用BRNN和LSTM、GRU的综合结构。BRNN的缺点在于它必须事先知道整条输入信息，这使得其在进行实时语音识别等任务时不是很有效。</p><p>深层循环神经网络(Deep RNN)：<br>我们之前学习的RNN都是单层的RNN，可以看到所有的x只经过了一层神经层就得到了y。可见一层RNN在横向上由若干个标准神经网络层组成，而要得到多层的RNN，需要对单层的RNN进行纵向上的延伸。下图就是一个三层的循环神经网络：</p><p>可以看到与单层的RNN相比，所有参数都多了描述层级关系的[l]符号，比如说a[2]<3>表示第二层第三时刻的激活，且上一层的输出成为了下一层的激活，而不是直接作为整个神经网络的输出。同时，每个激活也都改为了由前一层的激活和前一时刻的激活共同影响决定，例如：</p><p>此时要学习的参数也拓展到了不同层级，例如Wa[2]和ba[2]。<br>由于时间尺度较长的原因，深层循环神经网络通常无法做到很深，但可以改进的点在于可以将DRNN的若干个输出单独拉出来作为输入再分别构建一个比较深的标准神经网络，这倒是很常见的。此外，DRNN的各单元也可以结合使用BRNN、LSTM、GRU等构架起一个综合的循环神经网络。</p><p>之前用词表+独热编码表示一个单词的缺点在于，它把每个单词都孤立起来看了，这使得算法对相关词的泛化能力不够强。例如算法已经学会构成语言模型I wanna a glass of orange juice，如果此时让算法学习I wanna a glass of apple juice，可能仍需要花费一定时间。但事实上，由于如果能够关注算法对相关词的泛化能力，这两句话应该能利用同一个模型快速得到。<br>为了表征单词之间的关联性，我们引入词嵌入(Word Embedding)向量作为表示某个单词的新方法：<br>词嵌入向量的每个维度都表示了对应单词的某种特征，例如下图将特征分为了型别、尊贵、年龄和食物等维度，然后得到该单词对应于每个特征维度的相关程度，词嵌入向量就是一个由多维度相关程度组成的多维向量。词嵌入向量的维度远小于独热编码的维度，一般在50-1000之间，记位于词表n位置的独热编码为on，词嵌入向量为en。于是网络判断两单词的相关性就可以参考它们的词嵌入向量，比如Apple和Orange是一对近义词，两者在大部分维度上的值相似；Man和Woman是一对反义词，两者除了性别这一维度相反外。在其他维度上的值相似，然后对相关性高的单词做出类似的学习结果。</p><p>需要注意的是，虽然我们这里用一个直观的类别概念去区分词嵌入向量的不同维度，在实际学习过程中，你无法保证词嵌入向量的各维度有明确的意义，学习算法能做的只有保持相关词之间的词嵌入向量也存在某种相关性。</p><p>我们来看词嵌入模型的一个应用，就是进行类比推理(Analogy Reasoning)：<br>类比推理是人类思维的一个体现，例如我们给出Man对应King，那么Woman对应什么呢？显然Woman对应的是Queen，那么词嵌入模型怎么学习到这个对应关系呢？<br>我们可以看到，利用词嵌入向量，我们可以得到eman-ewoman≈eking-equeen≈[-2,0,0,0]。词嵌入模型就是使用词嵌入向量的相似性学习类比推理的，也就是找到一个单词w，使ew和eking-eman+ewoman的相似程度最高，写作数学表达式就是：</p><p>其中argmax函数返回数据结构取到最大值时的索引，sim函数是一种度量两个向量之间相似性的函数，在这里我们使用余弦相似度。所谓余弦相似度，就是两个向量之间的余弦夹角，可以知道，当两个向量相同时，余弦相似度=1；当两个向量正交时，余弦相似度=0；当两个向量相反时，余弦相似度=-1，这是一个比较好的判断相似度的性质。<br>经过这个表达式，我们发现w=Queen，便完成了一次类比推理。如果在词嵌入向量所在的多维空间里观察man和woman，king和queen之间的向量距离，可以发现两者是近似的。</p><p>那么我们怎么得到词嵌入向量的这些参数呢？一个方法是训练自己的词嵌入矩阵E，为此，我们需要一个极大量的语料库作为训练集。所谓词嵌入矩阵E，是词表中每个单词的词嵌入向量按序横向排列得到的一个矩阵，而我们训练的目标不是某个单词的词嵌入向量，而是整个词嵌入矩阵E的所有参数，假设词表有10000个单词，每个单词的词嵌入向量为300维，那么词嵌入矩阵E的规模就是300<em>10000。从词嵌入矩阵E中得到某单词的词嵌入向量en也很简单，就是用E乘以对应n的独热编码，即en=E</em>on，故得到了E也就得到了所有的en。<br>接下来我们具体看看怎么学习E中的各参数，历史上曾经出现过很多种学习词嵌入的方法：<br>1.建立一个语言模型是学习词嵌入矩阵的一个好方法。首先随机生成一个词嵌入矩阵E，将语料库作为训练集，根据输入单词的独热编码得到各输入的词嵌入向量，然后把这些词嵌入编码组合成一个组合向量输入神经网络，最后在一个softmax输出层输出预测结果。这个模型要学习的模型参数为E，w[1]，b[1]，w[2]和b[2]，把预测结果和语料库的实际结果的差值作为代价函数，由此训练出的神经网络可以得到词嵌入向量与softmax输出的关系。</p><p>这被认为是早期训练词嵌入矩阵比较成功的案例，究其原因在于语料库中存在了大量有关apple juice和orange juice的描述，于是训练好的语言模型对于I want a glass of apple <strong>和I want a glass of orange </strong>都有较大概率预测同一个输出juice，故如果观察包含词嵌入向量的隐藏层，apple和orange对应的词嵌入向量应该也大概率近似才会得到这样的结果。<br>基于这个模型，我们引入几个概念，我们把要预测的目标单词称为Target，把目标单词附近的其他已知单词称为Context。如果你的目的是得到一个语言模型，那么通常选取Context为Target的前k个单词（k是超参数，若如果不限制Context，则使用这个模型的输入长度将会无法确定，就会碰到之前在RNN中所说的问题了）；事实证明，如果你的目的仅仅是学习一个词嵌入矩阵，那么Context可以选取很多其他的模型：<br>1&gt;在Target前后各取k个单词<br>2&gt;取Target前的一个单词<br>3&gt;取Target附近的一个单词，这个方法会在之后重点讲解，被称为Skip-Gram。</p><p>2.Skip-Gram模型(Word2Vec)：<br>抽取Context-Target对来构造一个监督学习问题：我们要做的是从语料库的各个句子中随机选取一个词作为Context，然后随机在Context一定词距以内选择另一个词作为Target构成Context-Target对，将Context-Target对作为模型的训练集。于是监督学习的目标就是给定Context，然后要求网络预测在Context一定词距以内的某个Target值。<br>显然，这并不是一个非常简单的学习问题，因为在Context附近可能存在各种各样的单词，但我们构造这个监督学习问题的目标并不是解决这个监督学习问题本身，而是借助这个问题去得到一个良好的词嵌入模型。<br>Skip-Gram的网络模型非常简单，输入的是Context的词嵌入向量，经过一层softmax输出Target为各单词的可能性。如下图所示：</p><p>此时的softmax单元我们舍弃偏移b，并把w用θ表示，则zt=wt<em>x+bt=θtT</em>ec。<br>于是在输入Context为c时，输出Target为t的概率就是：</p><p>对应的损失函数为：</p><p>如果能得到一个不错的Skip-Gram模型，我们就可以得到一个不错的词嵌入矩阵E了。因为如果输入apple和orange都能得到输出juice，那么两者对应的词嵌入向量也将是类似的。<br>如此处理会碰到的一个问题是计算成本，指数相加是很耗费算力的。故因此，我们通常不会直接采用10000级的softmax函数，而是改为采用分级(Hierarchical)结构，也就是所谓的哈夫曼树，把出现频率更高的单词放在高层，每经过一个节点，将总集进行二分，直到找到目标单词，经过如此处理，低效的softmax就变为了多层的逻辑回归，可以加快程序运行速度。<br>此外，如何随机抽取c也是一个值得探讨的问题，如果按照出现概率进行随机抽取的话，网络可能会大量抽取诸如the，a等高频但无意义多关联的词汇，这会导致网络致力于训练这些不是很有用的词汇，而忽略真正想让网络训练的apple和orange等词汇。</p><p>3.负采样(Negative Sampling)：<br>负采样的每组训练数据由一个正样本和k个负样本组成，对于一组训练数据而言，其Context对应的单词是固定的，而Target则只有一个选取自Context附近文本，而其他都由词表中随机选取，于是数据中的的x是选取的Context和Target，y是两者是否真的能成为Context-Target对，显然选取自Context附近的Target对应的y是1，而随机选取的Target对应的y是0。</p><p>负采样对应的神经网络如下图所示，输入仍然是Context对应的词嵌入向量，而输出则是10000个逻辑单元，其中每个逻辑单元代表输入为Context时对应的输出为Target的概率。</p><p>由于我们每组训练数据只包含一个正样本和k个负样本，故每次反向传播学习参数并不需要更新所有的10000个逻辑单元，而只需要更新这些样本对应单词所代表的k+1个逻辑单元即可。对于小的训练集，一般选取k=5-20；对于大的训练集，一般选取k=2-5。可见每次更新并不会更新大量参数，加快了学习时间。<br>同样在逻辑回归单元我们舍弃偏移b，并把w用θ表示，则zt=wt<em>x+bt=θtT</em>ec。<br>于是在输入Context为c时，Target为t时，两者能组成Context-Target对的概率就是：</p><p>同样的，负采样也会碰到如何在词典中选取负样本的问题，前面提到如果随机选取会出现大量无意义的高频单词，而负采样的发明者提出了以下的经验公式。选取单词wi的概率是wi在语料库中出现的词频f(wi)的3/4方除以所有词表中单词出现词频的3/4方，即：</p><p>负采样将skip-gram中的softmax单元拆解成了若干个逻辑单元，且每次只需要更新其中的几个逻辑单元即可，这样的做法大大减轻了算法的计算成本。</p><p>4.GloVe(Global Vectors For Word Representation)词向量：<br>定义Xij为i出现在Context j附近的次数，这里i的地位就等同于Target，于是i和j可以用t和c代替。通过遍历训练集可以得到Xij的取值，如果将附近定义Context的左右若干个单词，则Xij和Xji的取值大致相等。可见Xij表示i和j之间的关联程度。GloVe也有对应的高频惩罚函数f(Xij)：当Xij=0时，f(Xij)=0；当Xij过于高频时，限制其权重；当Xij比较低频时，提高其权重。于是其代价函数为：</p><p>其中θiT为i的权重向量，ej为j的词嵌入向量，bi和bj分别为i和j的偏移向量，这些就是神经网络的学习参数。GloVe的目标就是，学习θi，ej，bi和bj使得线性函数θiTej+bi-bj与Xij的差距尽可能小，一旦实现了这个目标的话，由于apple juice和orange juice出现的概率差不多，故j=apple或orange，i取juice时的Xij值是相似的，故此时eapple和ejuice的值也应当是相似的。此外，相比于Skip-Gram和负采样来说，GloVe下的θi和ej的地位是相等的，因为i可以变成j，j也可以变成i。所以每个单词w最终的词嵌入向量可以取θw和ew的平均值。<br>可以看到，GloVe方法的函数非常简单，且效果不错。</p><p>说了那么多学习词嵌入矩阵E的方法，可能你会觉得非常难。但幸运的是，网络上已经有人上传了已经经过预训练的大量单词的词嵌入向量。我们也可以直接下载这些模型进行迁移学习，将这些词嵌入向量用在自己的小规模数据集中的每个单词上即可。</p><p>seq2seq模型：<br>seq2seq（序列到序列）模型是机器翻译和语音识别过程中的基础模型，实际上seq2seq模型就是一个多对多而数量不等的单层循环神经网络架构的变体。</p><p>它包含了绿色部分的编码网络和紫色部分的译码网络，编码网络将输入向量训练并整合成一组综合向量输入进译码网络，然后译码网络对这个综合向量进行处理得到最终输出。seq2seq模型的特点是译码网络的每个输出hat{y}会作为RNN的下一层输入，这点与语言模型相似，语言模型是随机输出一组语句的概率，而可以把seq2seq模型看作是条件语言模型，即根据限定的输入条件输出一组语句的概率，即P(y<1>,y<2>…y<Ty>)和P(y<1>,y<2>…y<Ty>|x<1>,x<2>…x<Tx>)的区别。比如说机器翻译在输入法语语句时输出英语语句，语音识别在输入语音时输出文字，都是存在条件而不是随机输出的。如果对seq2seq模型的结果进行随机采样，得到的结果可能不是最优的，而机器翻译和语音识别的输出结果总是希望是最优的，所以我们需要构建一个算法找出在特定输入x的时候，概率最大也即效果最优的输出y。即：</p><p>而P(y<1>,y<2>…y<Ty>|x<1>,x<2>…x<Tx>)=P(y<1>|x)<em>P(y<2>|x,y<1>)</em>…*P(y<Ty>|x,y<1>,…,y<Ty-1>)。<br>所以上式也可以写作：</p><p>要实现这个效果，我们通常使用集束搜索(Beam Search)。集束搜索是一种近似搜索算法，以机器翻译和规模为10000的词表为例，假设我们要得到一个长度为10的翻译结果，如果要搜索出概率最高即效果最优的结果，需要比较1000010次，这个计算成本是不能接受的。集束搜索的思路是，对译码网络的每层输出概率进行排序，即对P(y<n>|x,y<1>,…,y<n-1>)进行排序（n为层数），挑选出其中前k个作为本层最有可能的k个输出，这个k被称为束宽。而后，将这k个结果记录作为下层的输入，再挑选出在上一层结果为这k个时的最有可能的k个输出，再以此类推直到输出结束符，最终输出最后k个输出中概率最高的那个。可见第一层需要在10000个词中挑选k个，从第二层起每层需要在k*10000种组合中挑选k个，最后在k个最终结果中挑选1个。当束宽等于1时，集束搜索等效于贪心搜索，即每层只挑选概率最高的进行输出，这被认为不利于输出整体最优的语句。如果选择束宽B较长，则算法可以考虑更多的可能；如果选择束宽B较窄，则算法具有更低的计算成本。<br>值得注意的是，由于集束搜索是一种近似搜索算法，因此它只能输出相对较优的结果而不保证一定是全局最优，但是低廉的时间成本和足够优秀的输出结果使它脱颖而出。<br>进一步优化目标函数，将概率的乘积转换为对数的相加：</p><p>如此处理可以避免一堆小于1的数相乘导致数据下溢失去精度。但它还存在的一个问题是，这个目标函数可能不自然地倾向于简短的翻译结果，因为短句子的概率是由更少数量的小于1的数字乘积或小于0的对数求和得到的，这样的结果通常比长句子要大。<br>为此，可以在对数目标函数前加一个简短惩罚(Brevity Penalty/BP)，其中α是取值为0-1之间的柔和因子，α越趋近于0，简短惩罚就越没有效果。简短惩罚使短句承受了更低的结果。</p><p>接下来我们看看seq2seq模型的误差分析：<br>seq2seq模型的误差可能同时来源于编译码网络RNN和集束搜索算法，首先编译码网络RNN可能会训练的不够好以至于无法输出不错的结果，而集束搜索算法作为一种近似搜索算法，可能会因为束宽长度的选择无法搜索到比较好的输出。要想区分seq2seq模型的误差究竟是来源于RNN还是集束搜索算法，可以采取以下方法：</p><p>我们还是以机器翻译为例，我们让人和seq2seq模型同时翻译一个语句，记人翻译的结果为y<em>，模型翻译的结果为hat{y}，显然人翻译的是比较精确的，且模型相比于人翻译的不够好。于是进行误差分析，我们可以直接将y</em>和hat{y}喂给RNN模型，让模型判断P(y<em>|x)和P(hat{y}|x)的好坏。如果P(y</em>|x)&gt;P(hat{y}|x)，则RNN模型本身没有问题，因为人翻译的结果确实比模型好，那就可能是集束搜索算法没有找到这个比较好的结果，于是要从集束搜索算法的优化入手；反过来，如果P(y<em>|x)&lt;=P(hat{y}|x)，则RNN模型本身就有问题，因为它埋没了一个本应比较好的翻译。于是，当模型出现问题时，我们可以人为列出几句话对应的翻译，并让模型也翻译一遍，根据P(y</em>|x)和P(hat{y}|x)的大小关系判断是RNN的问题还是集束搜索算法的问题，列出表格看看两者谁占主要方面，并着重解决这一主要问题。</p><p>Bleu(Bilingual Evaluation Understudy 双语评估替补)得分：<br>Bleu得分是seq2seq模型中一个比较不错的单一实数评估指标，可以用于评估seq2seq模型的结果。仍以机器翻译模型为例，我们会遇到的一个问题是，由于翻译结果可能同时存在多个正确答案，我们如何从这么多答案中评估模型的结果呢？我们假设机器翻译给出了两个参考结果，这两个参考结果都足够优秀。</p><p>当模型的翻译结果hat{y}输出后，我们把整个句子拆分为若干个n个连续的词组，每个词组称为n-grams，则定义pn如下，其中Count是整句n-gram的数量，Countclip是整句n-gram与参考结果中的某个n-gram相同的数量，但每个Countclip(n-gram)不能超过单个参考例句中n-gram的最大值。</p><p>例如输出为The cat the cat on the mat，则分母为6，分子为4，p2=2/3，计算过程如下：</p><p>Bleu得分中也存在简短惩罚，如果模型MT输出的长度大于参考输出长度，那么就不进行简短惩罚，否则就要进行指数级的简短惩罚。</p><p>Bleu得分的公式为：Bleu Score=BP<em>exp(1/n</em>∑pi)，一般取n=4，即exp内计算p1-p4的均值。</p><p>注意力(Attention)模型：在翻译一个长句时，我们不希望神经网络去具备记忆一个长句子的能力，而是希望它更像人类一样，一次去翻译一个句子的一部分。这就是所谓的注意力，即在翻译某一个词语时，让神经网络只注意到句子的一部分，对应的模型就是注意力模型。<br>注意力模型在一般双向RNN的基础上，将多个输出hat{y}经过注意力参数整合为一个上下文变量c再次输入一个新的RNN中，新的RNN中每层会接收上个输出的词和经过注意力参数整合的语句向量作为输入，输出在新位置上的词。将新RNN中的激活命名为s<t>以示区分，于是注意力模型就可以表示为：</p><p>为了表示神经网络在翻译某个词语时对句中其他词语的重视程度（注意力），我们引入注意力参数α<t,t’>，代表在翻译词语t时对句中词语t’的注意力。为了让α<t,t’>之和为1，我们使用softmax模型的公式：</p><p>其中e<t,t’>可以看作是原始注意力参数，而经过softmax得到归一化后的注意力参数α<t,t’>。<br>那么怎么得到e<t,t’>呢？直观地想，作为注意力参数，e<t,t’>应该与前一个输出单词和各输入单词有关，而其对应的参数可以是上层输出激活s<t-1>和各输入激活a<t’>。现在的问题是，我们不知道e<t,t’>和s<t-1>，a<t’>之间究竟存在怎样的函数关系，于是我们可以训练一个小的神经网络，专门用来得到e<t,t’>和s<t-1>，a<t’>之间的函数关系。得到了e<t,t’>后，我们也就得到了α<t,t’>，那么c和各输入激活a<t’>的关系就可以表示为：c<t>=∑α<t,t’>*a<t’>。<br>然后训练整个注意力模型即可。</p><p>语音识别：当下语音识别的一个有效模型就是注意力模型，通过输入一段音频来转换为文字，由于音频的输入量（取样总数）往往远大于文字的输出量，所以注意力模型显得尤为重要。<br>假设输入一段10s，100Hz的采样音频以得到文字”The quick brown fox”，则注意力模型为：</p><p>还有一种常见的训练方法是CTC(Connectionist Temporal Classification)损失函数，CTC损失函数对应的训练网络是一个输入和输出数目相等的双向LSTM循环神经网络架构（这里简单用单向RNN表示）。与注意力模型不同，CTC损失函数将每个采样的输入都得到一个输出字母，这意味着有很多字母都会重复，也会有部分采样不存在字母（定义这种情况输出为空blank，不要和空格space混淆），最后得到1000个输出，对于这个输出，将空白符blank之间重复的字符折叠起来作为一个输出，同时不输出blank，以此类推得到最终输出。</p><p>触发字检测：可以训练一个RNN，当某人说完触发字之后，就把输出拉高为1一段时间，而其他时候输出始终为零，以此训练一个触发字检测系统。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda虚拟环境</title>
      <link href="/2023/10/09/Anaconda/"/>
      <url>/2023/10/09/Anaconda/</url>
      
        <content type="html"><![CDATA[<p>安装torch的方法：有驱动的前提下，取pytorch官网寻找命令安装torch+cuda<br>查询虚拟环境：conda env list<br>创建虚拟环境：conda create -n name python=3.xx<br>删除虚拟环境：conda remove -n name all<br>进入虚拟环境：conda activate name<br>退出虚拟环境：conda deactivate</p><p>能正常运行我电脑里的一个torch代码需要以下包：<br>pip3 install torch torchvision torchaudio —index-url <a href="https://download.pytorch.org/whl/cu121">https://download.pytorch.org/whl/cu121</a><br>Conda install nb_conda<br>Pip install jupyter matplotlib d2l tensorboard</p>]]></content>
      
      
      <categories>
          
          <category> 编译进化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C学习</title>
      <link href="/2023/09/24/C/"/>
      <url>/2023/09/24/C/</url>
      
        <content type="html"><![CDATA[<p>文件架构：每个.c文件只包含对应的.h文件，每个.h文件只包含要用到的.h文件</p><h1 id="ifndef只能解决重复包含的问题，比如a-h包含了c-h，b-h也包含了c-h，此时如果在d-h里同时包含a-h和b-h，那么如果没有ifndef就会报错。"><a href="#ifndef只能解决重复包含的问题，比如a-h包含了c-h，b-h也包含了c-h，此时如果在d-h里同时包含a-h和b-h，那么如果没有ifndef就会报错。" class="headerlink" title="ifndef只能解决重复包含的问题，比如a.h包含了c.h，b.h也包含了c.h，此时如果在d.h里同时包含a.h和b.h，那么如果没有ifndef就会报错。"></a>ifndef只能解决重复包含的问题，比如a.h包含了c.h，b.h也包含了c.h，此时如果在d.h里同时包含a.h和b.h，那么如果没有ifndef就会报错。</h1><p>如果a.h里包含了b.h，b.h里又包含了a.h，那么这样也会报错，且这个问题无法使用ifndef解决，且有时不会显式报错，发现的时候已经为时已晚，可谓代码杀手。<br>建议在规划文件时先把文件的架构以图的形式捋顺再动手。</p><p>extern置于变量前,标示变量的定义在别的文件中,提示编译器遇到此变量和函数时在其他模块中寻找其定义。</p><p>函数指针<br>函数指针 —存放函数地址的指针；<br>&amp;函数名 —得到的就是一个函数的地址；<br>正如数组名=&amp;数组名，函数名也是等于&amp;函数名的<br>函数指针定义：函数的返回值类型（<em>指针名）（函数的参数列表类型）=&amp;函数名/=函数名<br>函数指针调用：(</em>函数指针)(函数的参数列表类型)=函数指针(函数的参数列表类型)=函数名(函数的参数列表类型)<br>例：<br>void Add(int x, int y){return x+y;}<br>int main(){<br>int (<em>pf)(int,int)=&amp;Add=Add;<br>int ret=(</em>pf)(3,5)=pf(3,5)=Add(3,5)=8;</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习</title>
      <link href="/2023/09/17/C#/"/>
      <url>/2023/09/17/C#/</url>
      
        <content type="html"><![CDATA[<h1 id="1-C-数据类型"><a href="#1-C-数据类型" class="headerlink" title="1.C# 数据类型"></a>1.C# 数据类型</h1><p>在 C# 中，变量分为以下几种类型：<br>值类型（Value types）：如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用sizeof方法。表达式sizeof(type)产生以字节为单位存储对象或类型的存储尺寸。<br>引用类型（Reference types）：<br>指针类型（Pointer types）：C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p><h1 id="2-C-强制类型转换"><a href="#2-C-强制类型转换" class="headerlink" title="2.C# 强制类型转换"></a>2.C# 强制类型转换</h1><p>在 C# 中，强制类型转换有两种方法：<br>其一是在变量前面加(type)，例如将一个 int 类型的变量赋值给 byte 类型的变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">byte b = (byte)i;</span><br></pre></td></tr></table></figure><br>其二是使用Convert中的方法，例如将一个 double 类型的变量转化成 single 类型的变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double i=3.14;</span><br><span class="line">float b=Convert.ToSingle(i);</span><br></pre></td></tr></table></figure><br>强制类型转换也作用于字符串与数字的转换，其中将数字转换成字符串既可以使用i.ToString(“Fx”)也可以使用Convert.ToString(i)。<br>强制类型转换可能会造成数据丢失。</p><h1 id="3-C-支持的其他一些重要的运算符"><a href="#3-C-支持的其他一些重要的运算符" class="headerlink" title="3.C# 支持的其他一些重要的运算符"></a>3.C# 支持的其他一些重要的运算符</h1><h1 id="4-C-中的foreach循环："><a href="#4-C-中的foreach循环：" class="headerlink" title="4.C# 中的foreach循环："></a>4.C# 中的foreach循环：</h1><p>C# 的 foreach 循环可以用来遍历集合类型，例如数组、列表、字典等。<br>以下是 foreach 循环的语法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach (var item in collection)</span><br><span class="line">&#123;</span><br><span class="line">    // 循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>collection 是要遍历的集合，item 是当前遍历到的元素。</p><h1 id="5-C-封装"><a href="#5-C-封装" class="headerlink" title="5.C# 封装"></a>5.C# 封装</h1><p>C# 支持的访问修饰符如下所示：<br>public：所有对象都可以访问；<br>private：只有在该类对象内部可以访问；<br>protected：只有该类对象及其子类对象可以访问<br>internal：同一个程序文件内的对象可以访问；</p><h1 id="6-C-方法与参数传递："><a href="#6-C-方法与参数传递：" class="headerlink" title="6.C#方法与参数传递："></a>6.C#方法与参数传递：</h1><p>在 C# 中，定义方法的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;访问修饰符&gt; &lt;返回类型&gt; &lt;方法名&gt;(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">   //方法主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>按值传递参数：是参数传递的默认方式。在这种方式下，当调用一个方法时，会为每个值参数创建一个新的存储位置。实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。<br>按引用传递参数：引用参数是一个对变量的内存位置的引用。当按引用传递参数时，它不会为这些参数创建一个新的存储位置，而是与提供给方法的实际参数具有相同的内存位置。在 C# 中，使用 ref 关键字声明引用参数。例如在定义时public void swap(ref int x, ref int y)，在使用时int a=3,b=5;swap(ref a, ref b)。<br>按输出传递参数：return 语句只能从函数中返回一个值。如果要从函数中返回多个值，可以使用输出参数，输出参数会把方法输出的数据赋给自己以供外部调用。在 C# 中，使用 out 关键字声明输出参数。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void getValue(out int x )</span><br><span class="line">&#123;</span><br><span class="line">int temp = 5;</span><br><span class="line">x = temp;</span><br><span class="line">&#125;</span><br><span class="line">int a = 100;</span><br><span class="line">getValue(out a);//提醒：作为输出参数的变量可以不提前赋值</span><br><span class="line">Console.WriteLine(a);//a=5</span><br></pre></td></tr></table></figure></p><h1 id="7-C-可空类型："><a href="#7-C-可空类型：" class="headerlink" title="7.C# 可空类型："></a>7.C# 可空类型：</h1><p>C# 提供了一个特殊的数据类型，nullable 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值再加上一个 null 值。例如Nullable&lt; bool &gt; 变量可以被赋值为 true 或 false 或 null。声明一个 nullable 类型（可空类型）的语法如下：<br>&lt;变量类型&gt; ? &lt;变量名&gt; = null;    //例如int? num1 = null;<br>此外，C#还提供了一个被称为Null 合并运算符的功能，Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。它的格式为：<br>&lt;变量名&gt;??&lt;常量&gt;        //例如num3=num2 ?? 5.34<br>其意义是，如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。在上例中，如果num2为空值则num3=5.34。</p><h1 id="8-C-数组："><a href="#8-C-数组：" class="headerlink" title="8.C# 数组："></a>8.C# 数组：</h1><p>（1）一维数组：<br>在 C# 中声明一个一维数组的语法是：&lt;变量类型&gt;[] &lt;数组名&gt;;<br>声明一个数组不会在内存中初始化数组。只有数组被初始化后，才可以赋值给数组。<br>数组是一个引用类型，所以数组初始化需要使用 new 关键字来创建数组的实例。<br>例如：<code>double[] balance = new double[10];</code><br>我们也可以在初始化数组的同时为其赋值，比如：<code>int [] marks = new int[5] &#123; 99, 98, 92, 97, 95&#125;;</code><br>其中new int[5]中的5可以省略，即可以改写为<code>int [] marks = new int[] &#123; 99, 98, 92, 97, 95&#125;;</code><br>我们可以使用foreach来遍历一个数组。<br>（2）多维数组：<br>在 C# 中声明一个多维数组的语法是：&lt;变量类型&gt;[,…,] &lt;数组名&gt;;<br>其中逗号的数量是数组的维数，数组中的每个元素使用形式为 a[ i , j , k, …]的元素名称来标识，其中 a 是数组名称， i , j , k, …是各维度的值。<br>初始化赋值公式例如：<code>int[,] a = new int[5, 2] &#123;&#123;0,0&#125;, &#123;1,2&#125;, &#123;2,4&#125;, &#123;3,6&#125;, &#123;4,8&#125; &#125;;//&#123;&#125;为行,为列`（3）交错数组：交错数组是数组的数组，也就是说交错数组是一维数组，而数组中的每个元素也都是数组。在 C# 中声明一个交错数组的语法是：<变量类型>[][] <数组名>;初始化赋值公式例如：`int[][] scores = new int[2][]&#123;new int[]&#123;92,93,94&#125;,new int[]&#123;85,66,87,88&#125;&#125;;</code><br>交错数组中各元素的数组长度可以不一样。<br>（4）传递数组给函数：可以通过数组名称来给函数传递一个指向数组的指针。<br>例如：<code>double getAverage(int[] arr, int size);</code><br><code>int [] balance = new int[]&#123;1000, 2, 3, 17, 50&#125;;</code><br><code>avg = getAverage(balance, 5 ) ;</code><br>（5）参数数组：当声明一个方法时，如果不能确定要传递给函数的参数数目，则可以使用参数数组解决这个问题，参数数组通常用于传递未知数量的参数给函数。为此，C# 提供了 params 关键字，当调用数组为形参的方法时，既可以传递数组实参，也可以传递一组数组元素。其格式为：访问修饰符 返回类型 方法名称( params 类型名称[] 数组名称)<br>例如：<code>public int AddElements(params int[] arr);</code><br>         <code>int sum = AddElements(512, 720, 250, 567, 889);</code><br>（6）：数组具有很多方法，可以用数组名.或Array.呼出。比较常用的有：<br>数组名.Length，Array.Copy/Sort/Reverse等</p><h1 id="9-C-字符串："><a href="#9-C-字符串：" class="headerlink" title="9.C# 字符串："></a>9.C# 字符串：</h1><p>C# 定义字符串既可以使用char数组进行new创建，也可以直接用字符串string。<br>例如：<code>string Name=”Alan”;</code><br>又例如：<code>char[] letters = &#123; &#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;,&#39;o&#39; &#125;;</code><br>            <code>string greetings = new string(letters);</code><br>字符串string同数组array类似，也具有很多的内置方法。比较常用的有：</p><h1 id="10-C-结构体："><a href="#10-C-结构体：" class="headerlink" title="10.C# 结构体："></a>10.C# 结构体：</h1><p>在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构体。<br>例如，您可以按照如下的方式声明 Book 结构体：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Books&#123;</span><br><span class="line">   public string title;</span><br><span class="line">   public string author;</span><br><span class="line">   public string subject;</span><br><span class="line">   public int book_id;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><br>在 C# 中的结构体与传统的 C 或 C++ 中的结构体不同。C# 中的结构体有以下特点：<br>结构体可带有方法、字段、索引、属性、运算符方法和事件。<br>结构体可定义构造函数，但不能定义析构函数。<br>结构不能继承其他的结构或类，也不能作为其他结构或类的基，但可实现一个或多个接口。<br>结构成员的访问修饰符只能为public。<br>可以使用 New 操作符调用适当的构造函数创建结构体，也可以不使用 New 操作符即可被实例化，如果不使用 New 操作符，只有在所有的字段都被初始化之后，对象才能被使用。<br>比较类和结构，可以发现两者的不同在于：类是引用类型，结构是值类型且不支持继承。</p><h1 id="11-C-枚举："><a href="#11-C-枚举：" class="headerlink" title="11.C# 枚举："></a>11.C# 枚举：</h1><p>C#声明枚举的一般语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum &lt;枚举体名&gt;</span><br><span class="line">&#123; </span><br><span class="line">枚举列表//用逗号分隔的标识符列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>枚举列表中的每个符号代表一个比它前面的符号大一的整数值。默认情况下，第一个枚举符号的值是0，但我们也可以对第一个枚举符号进行赋值定义以规定其值。<br>例如：enum Days { Sun=1, Mon, tue, Wed, thu, Fri, Sat };<br>枚举体可以看做是一个类，因而使用对应枚举体符号时必须加上枚举体名前缀，例如Day.Sun。<br>枚举列表的符号类型属于枚举体名，因而在使用时通常需要进行强制类型转换来得到需要的数据类型（通常为int）。例如：int x = (int)Day.Sun;         //x=1</p><h1 id="12-C-类："><a href="#12-C-类：" class="headerlink" title="12.C# 类："></a>12.C# 类：</h1><p>类的定义是以关键字 class 开始，后跟类的名称。类的主体，包含在一对花括号内。<br>下面是类定义的一般形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;访问修饰符&gt; class  类名</span><br><span class="line">&#123;</span><br><span class="line">    //成员变量</span><br><span class="line">    &lt;访问修饰符&gt; &lt;变量类型&gt; 变量名1;</span><br><span class="line">    ...</span><br><span class="line">     &lt;访问修饰符&gt; &lt;变量类型&gt; 变量名n;</span><br><span class="line">    //成员方法</span><br><span class="line">    &lt;访问修饰符&gt; &lt;返回类型&gt; 方法名1(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        //方法体</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;访问修饰符&gt; &lt;返回类型&gt; 方法名m(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        //方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类的默认访问修饰符是 internal，成员的默认访问修饰符是 private。<br>如果要访问类的成员，需要使用点（.）运算符。<br>类的成员函数是一个在类定义中有它的定义或原型的函数，就像其他变量一样。作为类的一个成员，它能在类的任何对象上操作，且能访问该对象的类的所有成员。<br>构造函数是类的一个特殊成员函数，当创建类的新对象时执行。构造函数的名称与类的名称完全相同，它没有返回类型，即public 类名(初值参数){方法体}。例如class line的构造函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Line(double len)  // 参数化构造函数</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(&quot;对象已创建，length = &#123;0&#125;&quot;, len);</span><br><span class="line">  length = len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。析构函数用于在结束程序之前释放资源。析构函数不能继承或重载。例如~Line(){}。<br>可以使用 static 关键字把类成员定义为静态成员。这意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本，换句话说，这意味着类中只有一个该成员的实例。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class StaticVar</span><br><span class="line">&#123;</span><br><span class="line">  public static int num;</span><br><span class="line">    public void count()</span><br><span class="line">    &#123;</span><br><span class="line">      num++;//所有类的实例每调用一次count()，都只会给唯一的num加一</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>你也可以把一个成员函数声明为 static，这样的函数只能访问静态变量。</p><h1 id="13-C-继承"><a href="#13-C-继承" class="headerlink" title="13.C# 继承"></a>13.C# 继承</h1><p>继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承已有的类的成员即可。这个已有的类被称为的基类，这个新的类被称为派生类。<br>一个类可以派生自多个类或接口，这意味着它可以从多个基类或接口继承数据和函数。<br>C# 中创建派生类的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;访问修饰符&gt; class &lt;基类&gt;</span><br><span class="line">&#123;</span><br><span class="line"> //基类内容</span><br><span class="line">&#125;</span><br><span class="line">&lt;访问修饰符&gt;class &lt;派生类&gt; : &lt;基类&gt;</span><br><span class="line">&#123;</span><br><span class="line">  //派生类内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>基类的初始化<br>派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。<br>C# 多重继承：<br>多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。<br>C# 不支持多重继承。但是，我们可以使用接口来实现多重继承。</p><h1 id="14-C-多态性"><a href="#14-C-多态性" class="headerlink" title="14.C# 多态性"></a>14.C# 多态性</h1><p>多态是同一个行为具有多个不同表现形式或形态的能力。在面向对象编程中，多态性往往表现为”一个接口，多个功能”。<br>多态性可以是静态的或动态的。在静态多态性中，函数的响应是在编译时发生的。在动态多态性中，函数的响应是在运行时发生的。<br>（1）静态多态性：<br>在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性，分别为函数重载和运算符重载。<br>函数重载：您可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同，但不能只是返回类型不同。<br>（2）动态多态性：<br>C# 允许您使用关键字 abstract 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。抽象类包含抽象方法，抽象方法可被派生类实现（需要使用重载关键字override）。派生类具有更专业的功能。下面是有关抽象类的一些规则：<br>您不能创建一个抽象类的实例。<br>您不能在一个抽象类外部声明一个抽象方法。<br>通过在类定义前面放置关键字 sealed，可以将类声明为密封类。当一个类被声明为 sealed 时，它不能被继承。抽象类不能被声明为 sealed。<br>下面的例子演示了一个抽象类及其实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">abstract class Shape//抽象类，可以包含虚方法</span><br><span class="line">&#123;</span><br><span class="line">  abstract public int area();//抽象方法，可以在派生类中实现，用abstract声明</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle:  Shape//派生类实现抽象方法</span><br><span class="line">&#123;</span><br><span class="line">  private int length;</span><br><span class="line">  private int width;</span><br><span class="line">  public Rectangle( int a, int b)</span><br><span class="line">  &#123;</span><br><span class="line">    length = a;</span><br><span class="line">    width = b;</span><br><span class="line">  &#125;</span><br><span class="line">  public override int area ()//实现抽象方法，用override声明</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(&quot;Rectangle 类的面积：&quot;);</span><br><span class="line">    return (width * length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当有一个定义在类中的函数需要在继承类中实现时，可以使用虚方法，虚方法是使用关键字 virtual 声明的，虚方法可以在不同的继承类中有不同的实现，而对虚方法的调用是在运行时发生的。动态多态性是通过抽象类和虚方法实现的。</p><h1 id="15-C-运算符重载"><a href="#15-C-运算符重载" class="headerlink" title="15.C# 运算符重载"></a>15.C# 运算符重载</h1><p>您可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。C#要求所有的运算符重载都声明为public和static，且重载的运算符需要与原运算符有相同的操作数，故其格式为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;返回类型&gt; operator&lt;重载运算符&gt; (与与原运算符数量相同的参数列表)</span><br><span class="line">&#123;</span><br><span class="line">  //重载体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Box operator+ (Box b, Box c)//重载运算符+</span><br><span class="line">&#123;</span><br><span class="line">Box box = new Box();</span><br><span class="line">box.length = b.length + c.length;</span><br><span class="line">box.breadth = b.breadth + c.breadth;</span><br><span class="line">box.height = b.height + c.height;</span><br><span class="line">return box;</span><br><span class="line">&#125;</span><br><span class="line">Box3 = Box1 + Box2;//使用新重载的运算符</span><br></pre></td></tr></table></figure></p><h1 id="16-C-接口"><a href="#16-C-接口" class="headerlink" title="16.C# 接口"></a>16.C# 接口</h1><p>接口一般与其派生类结合使用，其中接口定义了所有派生类继承接口时应遵循的结构。即接口定义了 “是什么” 部分，派生类定义了 “怎么做” 部分。接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明，其本身并不实现任何功能，只是和实现该接口的派生类订立一个必须实现哪些行为的契约；而成员的具体定义是接口的派生类的责任。<br>接口使得实现接口的派生类在形式上保持一致。<br>抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。<br>接口使用 interface 关键字声明，它与类的声明类似。接口声明默认是 public 的。<br>下面是一个接口声明的实例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">    void MethodToImplement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上代码定义了接口 IMyInterface。通常接口命令以 I 字母开头，这个接口只有一个方法 MethodToImplement()，且该方法在接口中并没有具体的实现。<br>接下来我们定义一个继承自该接口的派生类来实现以上接口：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class InterfaceImplementer : IMyInterface//实现接口的派生类继承自接口</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()//接口不能被实例化，只有实现了接口功能的派生类才能被实例化</span><br><span class="line">    &#123;</span><br><span class="line">        InterfaceImplementer iImp = new InterfaceImplementer();</span><br><span class="line">        iImp.MethodToImplement();</span><br><span class="line">    &#125;</span><br><span class="line">    public void MethodToImplement()//实现接口</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MethodToImplement() called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>InterfaceImplementer 类实现了 IMyInterface 接口，接口的实现与类的继承语法格式类似。<br>当一个派生类继承接口后，就必须实现接口的方法 , 且方法名必须与接口定义的方法名一致。<br>接口继承：<br>如果一个接口继承其他接口，那么实现该接口的派生类就需要实现该接口以及其父类接口的所有成员。<br>以下实例定义了两个接口，分别是IMyInterface 和 IParentInterface。其中IMyInterface 继承自IParentInterface 接口，因此接口IMyInterface对应的派生类必须实现MethodToImplement() 和ParentInterfaceMethod()两个方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface IParentInterface</span><br><span class="line">&#123;</span><br><span class="line">    void ParentInterfaceMethod();</span><br><span class="line">&#125;</span><br><span class="line">interface IMyInterface : IParentInterface//接口IMyInterface继承自接口IParentInterface</span><br><span class="line">&#123;</span><br><span class="line">    void MethodToImplement();</span><br><span class="line">&#125;</span><br><span class="line">class InterfaceImplementer : IMyInterface//实现接口的派生类继承自接口</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()//实例化派生类后可以同时使用所有接口的方法</span><br><span class="line">    &#123;</span><br><span class="line">        InterfaceImplementer iImp = new InterfaceImplementer();</span><br><span class="line">        iImp.MethodToImplement();</span><br><span class="line">        iImp.ParentInterfaceMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    public void MethodToImplement()//实现IMyInterface的方法</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MethodToImplement() called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void ParentInterfaceMethod()//实现IParentInterface的方法</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;ParentInterfaceMethod() called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="17-C-命名空间"><a href="#17-C-命名空间" class="headerlink" title="17.C# 命名空间"></a>17.C# 命名空间</h1><p>命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突，即不同命名空间中的名称可以重复。定义命名空间以关键字 namespace 开始，后跟命名空间的名称，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace &lt;命名空间名&gt;</span><br><span class="line">&#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了调用对应命名空间的函数或变量，会把命名空间的名称置于前面并用点分隔，如下所示：<br> &lt;命名空间名&gt;. &lt;函数或变量名&gt;;<br>下面的程序演示了命名空间的用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">namespace first_space</span><br><span class="line">&#123;</span><br><span class="line">   class namespace_cl</span><br><span class="line">   &#123;</span><br><span class="line">      public void func()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Inside first_space&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace second_space</span><br><span class="line">&#123;</span><br><span class="line">   class namespace_cl</span><br><span class="line">   &#123;</span><br><span class="line">      public void func()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Inside second_space&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;  </span><br><span class="line">class TestClass</span><br><span class="line">&#123;</span><br><span class="line">   static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line">      first_space.namespace_cl fc = new first_space.namespace_cl();</span><br><span class="line">      second_space.namespace_cl sc = new second_space.namespace_cl();</span><br><span class="line">      fc.func();</span><br><span class="line">      sc.func();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当上面的代码被编译和执行时，它会产生下列结果：<br>Inside first_space<br>Inside second_space<br>此外，我们也可以用using 关键字表明程序使用的是给定命名空间中的名称，这样在使用的时候就不用在前面加上命名空间名称，编译器在随后的代码会默认使用指定命名空间中的名称。例如，我们在程序中使用 System 命名空间，其中定义了类 Console。<br>我们可以只写：Console.WriteLine (“Hello there”);<br>当然，我们也可以写全称：System.Console.WriteLine(“Hello there”);<br>此外，命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace &lt;外部命名空间名&gt; </span><br><span class="line">&#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">   namespace &lt;内嵌命名空间名&gt; </span><br><span class="line">   &#123;</span><br><span class="line">     // 代码声明</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其访问关系仍然是使用点运算符访问嵌套的命名空间的成员。</p><h1 id="18-C-预处理器指令"><a href="#18-C-预处理器指令" class="headerlink" title="18.C# 预处理器指令"></a>18.C# 预处理器指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG</span><br><span class="line">#define VC_V10</span><br><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">  #if (DEBUG &amp;&amp; !VC_V10)</span><br><span class="line">  Console.WriteLine(&quot;DEBUG is defined&quot;);</span><br><span class="line">  #elif (!DEBUG &amp;&amp; VC_V10)</span><br><span class="line">  Console.WriteLine(&quot;VC_V10 is defined&quot;);</span><br><span class="line">  #elif (DEBUG &amp;&amp; VC_V10)</span><br><span class="line">  Console.WriteLine(&quot;DEBUG and VC_V10 are defined&quot;);</span><br><span class="line">  #else</span><br><span class="line">  Console.WriteLine(&quot;DEBUG and VC_V10 are not defined&quot;);</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="19-C-异常处理"><a href="#19-C-异常处理" class="headerlink" title="19.C# 异常处理"></a>19.C# 异常处理</h1><p>异常是在程序执行期间出现的问题。C# 中的异常是对程序运行时出现的特殊情况的一种响应，比如尝试除以零。异常提供了一种把程序控制权从某个部分转移到另一个部分的方式。C# 异常处理时建立在四个关键词之上的：try、catch、finally 和 throw。<br>①try：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。<br>②catch：程序通过异常处理程序捕获try块中的异常。<br>③finally：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。<br>④throw：当问题出现时，程序抛出一个异常，使用 throw关键字来完成。一般用于抛出用户自定义的异常，当try语句捕捉到throw抛出的异常，就会进入catch捕获阶段。<br>使用 try/catch 语法如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">   // 可能引起异常的语句</span><br><span class="line">&#125;</span><br><span class="line">catch( ExceptionName e1 )//检测这些语句抛出的异常</span><br><span class="line">&#123;</span><br><span class="line">   // 错误处理代码</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">catch( ExceptionName eN )//可以列出多个 catch 语句捕获不同类型的异常</span><br><span class="line">&#123;</span><br><span class="line">   // 错误处理代码</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">   // 最终执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 System.Exception 类。System.ApplicationException 和 System.SystemException 类是派生于 System.Exception 类的异常类。System.ApplicationException 类支持由应用程序生成的异常。程序员定义的异常都派生自该类；而System.SystemException 类是所有预定义的系统异常的基类。<br>下表列出了一些派生自 System.SystemException 类的预定义的异常类：</p><ul><li>System.IO.IOException                处理 I/O 错误。</li><li>System.IndexOutOfRangeException    处理当方法指向超出范围的数组索引时生成的错误。</li><li>System.ArrayTypeMismatchException    处理当数组类型不匹配时生成的错误。</li><li>System.NullReferenceException        处理当依从一个空对象时生成的错误。</li><li>System.DivideByZeroException        处理当除以零时生成的错误。</li><li>System.InvalidCastException            处理在类型转换期间生成的错误。<br>下面是一个当除以零时抛出系统异常的实例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void division(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    result = num1 / num2;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (DivideByZeroException e)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(&quot;Exception caught: &#123;0&#125;&quot;, e);</span><br><span class="line">  &#125;</span><br><span class="line">  finally</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(&quot;Result: &#123;0&#125;&quot;, result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">  DivNumbers d = new DivNumbers();</span><br><span class="line">  d.division(25, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当上面的代码被编译和执行时，它会产生下列结果：<br>Exception caught: System.DivideByZeroException: Attempted to divide by zero.<br>下面的实例演示了抛出用户自定义的异常：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">  Temperature temp = new Temperature();</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    temp.showTemp();//当temperature=0时会抛出自定义异常被try捕捉</span><br><span class="line">  &#125;</span><br><span class="line">  catch(TempIsZeroException e)//捕获到自定义异常</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(&quot;TempIsZeroException: &#123;0&#125;&quot;, e.Message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TempIsZeroException: ApplicationException//自定义异常，继承ApplicationException</span><br><span class="line">&#123;</span><br><span class="line">  public TempIsZeroException(string message): base(message)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Temperature</span><br><span class="line">&#123;</span><br><span class="line">  int temperature = 0;</span><br><span class="line">  public void showTemp()</span><br><span class="line">  &#123;</span><br><span class="line">    if(temperature == 0)//抛出自定义异常TempIsZeroException的时机</span><br><span class="line">    &#123;</span><br><span class="line">        throw (new TempIsZeroException(&quot;Zero Temperature found&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Temperature: &#123;0&#125;&quot;, temperature);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当上面的代码被编译和执行时，它会产生下列结果：<br>TempIsZeroException: Zero Temperature found</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式通信协议</title>
      <link href="/2023/09/12/communicate/"/>
      <url>/2023/09/12/communicate/</url>
      
        <content type="html"><![CDATA[<p>SPI(Serial Peripheral Interface)：串行外设接口</p><p>采用一主多从模式，主机和从机之间可以互相通信，从机和从机之间无法通信。<br>主要信号线：<br>片选信号SS：由主机决定与哪个从机通信<br>时钟信号SCK：在时钟信号上升沿或下降沿瞬间MOSI或MISO的值才会被采样认为是通信内容<br>主发从收MOSI(Master Output Slave Input)：由主机向从机发送的内容<br>主收从发MISO(Master Input Slave Output)：由从机向主机发送的内容</p><p>WIFI：无线局域网ESP32，ESP8266<br>WIFI是一种允许电子设备连接到一个无线局域网的技术，相比于蓝牙，WIFI具有更远的通讯距离和更高的通讯效率。<br>ESP8266采用串口与单片机通讯，其内置TCP/IP协议栈，能够实现串口与WIFI之间的转换。两者通讯的基本流程即：WIFI模块接收无线WIFI数据，并转换为串口信息，通过串口发送到单片机；反过来，单片机发送串口信息给WIFI模块的串口，由WIFI模块转换为无线WIFI数据，并发送出去。<br>ESP8266 WIFI模块具有以下三种主模式：<br>1.AP:Access Point，也就是无线接入点，是一个无线网络的创建者，是网络的中心节点，允许其它无线设备接入，提供数据访问。一般家庭或办公室使用的无线路由器就是一个AP。AP和AP之间允许相互连接。<br>2.STA：Station，也就是站点，站点就是每一个连接到无线网络中的终端(如笔记本电脑、PDA及其它可以联网的用户设备)。STA本身并不接受其它无线设备接入，但它可以连接到AP。<br>3.AP+STA：兼具两者特点，即允许其它无线设备接入，其本身又能连接到其他WIFI模块。</p><p>此时WIFI模块本身充当无线路由器的作用。</p><p>此时WIFI模块本身作为一个接入设备，连接无线路由器。<br>此外，AP和STA下还各有三个子模式：TCP服务端、TCP客户端、UDP<br>区分它们的关键在于服务端和客户端、TCP和UDP的区别：<br>服务端和客户端：一般由客户端发送请求，服务端接收请求，一个服务端可以同时连接多个客户端，两者之间通过IP地址和端口号连接，所谓IP地址，即连接在因特网上的主机的标识符，所谓端口号，即同一主机上不同网络服务程序的标号。有了IP地址和端口号，我们便可以确定信息传输到哪个主机的哪个网络服务程序处理了。<br>TCP与UDP：TCP的可靠性更高，UDP的传输速度更快。<br>对于ESP8622而言，我们采用AT串口指令来进行wifi模块与单片机之间的连接与通信，具体地，AT指令可以配置wifi模块的模式，也可以进行数据的发送与接收。<br>AT指令集：</p><p>注意：只有打了双引号的部分才需要加双引号，别的不要加！<br>      波特率的设置为115200，命令结束必须加回车换行符\r\n<br>  设置的WIFI名尽量为英文，中文会出现乱码<br>1.自检：AT<br>2.重启：AT+RST<br>3.恢复出厂设置：AT+RESTORE<br>4.设置主模式：AT+CWMODE=模式（1:STA/2:AP/3:AP+STA）<br>5.列出当前可用的AP：AT+CWLAP<br>6.加入要求的AP：AT+CWJAP=”WIFI名”,”WIFI密码”<br>7.退出当前加入的AP：AT+CWQAP<br>8.设置该模块在AP模式下的参数：AT+CWSAP=”创建的WIFI名”,”WIFI密码”,通道号（最多5）,WPA预共享密钥（一般选3:WPA2_PSK）。本指令只在该模块要作为AP时使用。<br>9.查看该模块作为AP时接入设备的IP：AT+CWLIF。本指令只在该模块作为AP时使用。<br>10.获取该ESP8266模块的IP：AT+CIFSR<br>11.是否启动多连接：AT+CIPMUX=0/1。只有在非透传模式下，才能设置为多连接；只有关闭服务器模式(CIPSERVER)，才能设置为单连接。<br>12.与目标IP建立TCP连接：AT+CIPSTART=”TCP”,”目标IP”,端口号。此时的模块作为TCP Client。<br>13.配置该模块为TCP Server：AT+CIPSERVER=是否开启Server(0/1),端口号。AT+ CIPMUX=1时才能配置为TCP Server。每有一个Client接入就会自动按顺序占用一个连接。会在服务器和客户端同时返回CONNNECT，服务器还会显示接入编码，从0开始按接入先后顺延。<br>14.设置发送的数据长度并等待发送数据：AT+CIPSEND=发送数据的长度（字节）。之后输入的数据直到超过长度会被发出，该指令必须在关闭透传模式以及单连接模式下使用，故TCP Server是不能发送数据的。接收方接收的数据格式为：+IPD,设备编码,数据长度：数据内容。<br>15.设置该模块作为STA时的IP地址：AT+CIPSTA=”IP地址”。本指令只在该模块作为STA时使用。<br>16.设置该模块作为AP时的IP地址：AT+CIPAP=”IP地址”。本指令只在该模块作为AP时使用。<br>17.是否启用透传模式：AT+CIPMODE=0/1。透传模式只有关闭TCP Server时才可以配置。<br>18.获取该模块当前的连接状态：AT+CIPSTATUS<br>19.关闭当前的TCP连接：AT+CIPCLOSE<br>20.设置该模块作为TCP Server时对其下Client的超时容限：AT+CIPSTO=0-7200s。作为TCP server，会踢掉一直不通信直至超时的TCP client，如果设置AT+CIPSTO=0，则永远不会超时。<br>会在服务器和客户端同时返回CLOSED。服务器还会显示接入编码，从0开始按接入先后顺延。</p><p>检查电脑的WIFI配置，在cmd中：<br>1.ipconfig:无限局域网适配器WLAN-&gt;IPv4地址，这是电脑连接的网络的IP地址<br>2.netstat -ano:查看已被占用的端口号<br>3.tasklist|findstr “xxx”：查看被占用端口号xxx对应的网络程序<br>4.netstat -ano | findstr “4710”<br>5.taskkill /pid 29212 /f</p><p>网络调试助手：</p><p>设置协议为TCP Server，使电脑作为TCP服务器，此时本地主机地址会自动匹配到对应连接WIFI的IP地址，选择本地主机端口时注意不要与其他网络程序冲突。</p><p>串口助手与网络调试助手互联，单片机发送串口信息与网络调试助手互联<br>两个ESP8266间通过串口助手互联，两个ESP8266借助外部WIFI通过串口助手互联<br>两个ESP8266间实现单片机数据互传<br>安信可官网：<a href="https://www.ai-thinker.com/product/esp">https://www.ai-thinker.com/product/esp</a></p><p>USART：VCC，TX，RX，GND</p><p>CAN：CAN_H和CAN_L</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPC模型预测控制</title>
      <link href="/2023/08/29/MPC/"/>
      <url>/2023/08/29/MPC/</url>
      
        <content type="html"><![CDATA[<p>假设系统的模型为x(k+1)=Ax(k)+Bu(k)（离散形式状态空间方程）<br>即下一时刻的状态量由本时刻的状态量和输入量决定</p><p>其中u(k+i|k)表示在k时刻预测k+i时刻的输入<br>为做简化，设误差E即为状态x：</p><p>此时的J是关于x和u的二元函数，为了得到二次规划的标准形式，我们至少需要消去变量x或u之一，由于控制器由输入u决定，故我们决定消去变量x。<br>其中Q为误差加权矩阵，R为输入加权矩阵，F为终端误差加权矩阵。</p><p>由于x(k|k)即为k时刻下预测k时刻的状态，也就是当前状态作为的初始条件，这是一个已知量。那么根据模型函数就可以进行以下递推：</p><p>写作矩阵形式即：</p><p>注意这里右边黑色的xk是k时刻的初始状态向量，而左边绿色的Xk量矩阵则是k时刻下预测的N区间内的状态变量值矩阵。<br>回到J，我们将误差加权和展开结合终端误差得到以下矩阵形式：</p><p>同理我们也将输入加权和展开，则J可以写作：</p><p>其中bar{R}为R的一个对角阵。<br>我们看到第二项和第三项，由于J为一个数（1*1矩阵），由矩阵相加原则，第二项和第三项也必然为一个数，而一个数的转置即为它本身，故事实上第二项与第三项相等。</p><p>勘误：这里的结果应该是2倍的第二项或第三项，即：</p><p>同时，我们把第四项和第五项合并得到合成参数矩阵H，最终J的格式即为红框内的式子。<br>对比二次规划型可以看出，此时的J就是一个标准的二次规划型。<br>我们利用MATLAB的Quadprog()函数来求这个二次规划的最优解minJ对应的uk的值。<br></p><p>由于J的第一项为无关常量项，因而二次规划只需针对后两项，故事实上要得到最优的uk可以不求取矩阵G的值</p><p>为了更加明晰矩阵的运算，我们用公式编辑器结合一个例子再重复一遍以上操作：<br>假设输入量个数为p，状态量个数为n，预测区间为N</p><p>这里要注意的是，x(k|k)和u(k|k)也是一个矩阵，规模分别为n<em>1和p</em>1<br>在我们给出的例子中，p=2，n=1，N=3故有：</p><p>X[k]/U[k]是当前时间步k下对未来位于预测区间N内各状态量/输入量的预测<br>其中对X[k]的预测始终比U[k]多一步（一般地，可以多任意步）</p><p>矩阵M和C格式如下：</p><p>这里要注意的是，之前C矩阵中的0事实上也是一个零矩阵而非一个数<br>0</p><p>在我们给出的例子中：</p><p>对应J的形式即为：</p><p>其中G，E，H均为与M，C，Q，R，F相关的相，则整个J都能被求解。</p><p>在上述例子中，我们让误差E=x，而所有控制系统的控制目标均为误差等于0，故上述例子中的x的目标即为0。更一般的，我们希望x的目标为Xdesire（简写为Xd），则此时E=Xd-x。<br>那么把它推广到一般形式应该怎么做呢？其实很简单，我们只需要把控制的主体改为误差就可以了，即状态变量x本身就是误差E（之前的特例中是值相等，此时我们把其看做意义相等），原来的控制目标是让x=0，而我们只要将x换成E，用同样的控制逻辑控制E=0，那此时的x自然就是Xd了。</p><p>底盘MPC状态方程：</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VESC学习</title>
      <link href="/2023/08/26/vesc/"/>
      <url>/2023/08/26/vesc/</url>
      
        <content type="html"><![CDATA[<p>VESC的上位机使用手册<br>// 1.本手册对应vesc_tool版本为0.95，vesc_tool 3.00版本类似，仅做简单介绍<br>// 2.一切内容都可点击对应栏目尾端的显示详情<br>// 3.使用时相对重要的部分会加粗标红提示，其他在初学阶段可仅作了解，以后再深入学习<br>// 4.如果只想先了解整定流程请直接参阅“整定流程”部分<br>/<strong><strong><strong><em>*</em></strong></strong></strong>左侧参数栏<strong><strong><strong><em>*</em></strong></strong></strong>/<br>零、Welcome&amp;Wizard：<br>左键为连接VESC，中键为开始整定电机的向导。</p><p>一、 Connection：<br>正确接线硬件设备查看((USB-)Serial)部分，Port将显示串口端口，Baud为波特率一般设置为115200bps不用更改，TCP和Bluetooth LE部分不用管。之后点击 Welcome&amp;Wizards界面的或右边栏的，连接成功则在底部栏右侧显示信息</p><p>二、 Firmware：<br>vesc的固件信息，简单了解即可<br>三、 Motor Setting：<br>    ①. General：</p><pre><code>    1. General：Motor Type表示控制方式，一般选择FOC（关于FOC算法的相关知识可以自己找点资料，但现阶段还不用了解的太深）；Invert Motor Direction表示电机认为的正转方向（给正转速时的旋转方向）；Sensor Port Mode为编码器的选择，队内一般使用AS5047 Encoder；Encoder Counts表示编码器的反馈线束，与精度相关，队内为8192线</code></pre><p>·        2. Current：Current Max和Max Brake表示运行时电流限制和刹车时电流限制，与电机参数相关，需要根据电机实际参数调整，初学时建议调整为30A；Absolute Maximum Current是绝对最大电流，峰值电流；Slow ABS Current Limit是开启滤波后的电流作为判定依据；Battery栏的内容设置同电池相关，通常与电机的参数对应；DRV8301不管</p><pre><code>    3. Voltage：检测到低于Start部分电压是电流输入会减少至End停止输入电压    4. RPM：电转速（电转速=极对数×转速）限制    5. Wattage：功率限制    6. Temperature：温度限制        7. Advanced：Minimum Input Voltage表示最低电压限制，欠电压报错依据；Maximum InputVoltage表示最高电压限制过电压报错依据；Minimum Duty Cycle表示最低占空比设置；Max Duty Cycle为最高占空比设置；Fault Stop Time表示出现报错后电机进入禁止使用状态的时间；后两项我也不知道是啥②. BLDC不重要③. DC不重要④. FOC:    1. General：Sensor Mode中Sensorless表示无感模式，Encode及使用编码器，Hall及霍尔传感器，后两者为有感模式；Resistence和Inductance还有Linkage是电机参数，一般通过整定得到；Current Kp/Ki为电流环参数，通过整定得到；Observer Gain，观察者参数，用来在整定数据不太ok的情况下可以适当调整（一般直接重新整定了）    2. Sensorless（无感模式相关设置）：Openloop ERPM无感模式下，低于该电转速使用开环模式换向，该项内容可根据负载特性调整；Openloop Hysteresis如果电转速在这段时间一直低于开环转速，那就转化到开环模式；Oponloop Time在触发后保持这一段时间的开环；Stator Saturation Compensation定子饱和补偿，开环模式下大电流低转速启动困难，可以尝试增大该参数以试图补偿定子饱和，但是这一项参数不要大于15%；Temp Comp对观察者使用的电机电阻进行温度补偿，当电机温度和测量温度差距过大可以开启这一补偿，低速模式下可能有一点效果；Temp Comp Base Temp测量电机电阻的温度。    3. Hall Sensors（霍尔传感器下的有感模式相关设置）：暂时不需要，可以补充进来    4. Encoder（普通编码器下的有感模式相关设置）：Sensorless ERPM：高于该转速，则使用无感换向；Encoder offset编码器偏移量（似乎不是很有效）；Encoder Ratio编码器和电机之间的比率，比如带有直接连接编码器的14极对数电机的该项值为7；Encoder Inverted电机旋转方向控制    5. Advanced：Switching Frequency开关频率，控制器和估计器以该频率的一半运行，如果V0和V7中的“采样”选项处于活动状态，则控制器和估计器将以全开关频率运行，但此选项仅在具有相位分流器的硬件上可用（我也不知道啥意思，但是咱暂时不用）；Dead Time Compensation死区时间失真补偿，低速时或许有效；Speed Tracker Kp/Ki速度跟踪器比例/积分增益，速度跟踪器通过跟踪相位角来估计电动机速度；Duty Downramp Kp/Ki占空比下降斜坡控制器的比例/积分增益，这个控制器用于占空比模式，由于占空比的下降是通过限制调制来实现的，占空比降低时可能出现较大的电流尖峰，这个控制器可以限制这些电流尖峰；D Current Injection Duty在低于工作循环的情况下注入D轴电流，可以帮助低速观测；D Current Injection Factor使用此系数乘以D轴电流注入的Q轴电流，某些情况下，D轴电流注入可以帮助低速观测；Sample in V0 and V7 对空间矢量调制的V0和V7中的电流和电压进行采样，并以两倍的速率运行控制回路可用于开关频率有限的高速电机，或用于降低调制噪声，对于给定的开关频率，此选项将需要两倍的计算能力，此选项仅适用于带有相位分流器的硬件，如VESC Six；High Current Sampling Mode在采样过程中选择最低电流以获得最高电流，由于电机电流是平衡的，并且总和为0，因此可以使用其中两个相电流来导出第三个相电流，启用此选项将使电流测量比较所有电机电流，并从两个较低的电流中得出最高电流，通过这种方式，可以测量出比ADC增益允许的电流高出2/sqrt（3）倍或大约1.15的电流，此选项仅适用于具有三个分流器的硬件，如VESC Six；Observer Gaim At Minimum Duty观测器增益按最小占空比缩放，减小该参数将使观测器在较低的调制下增益较低，这有助于跟踪电机，将此参数设置为1将使观测者增益在所有调制下保持恒定；Current Filter ConstantFOC实现中滤波电流的常数，将影响慢速abs最大电流故障触发的速度。范围从0到1，其中0是最慢的，1是无筛选。⑤. PID    1. 速度环：正常的pid；Speed PID Kd Filter对速度控制器的导数项进行滤波，0表示忽略导数项的结果，1表示不处理；Minimum ERPM电转速低于这个值时速度控制器将被禁用；Allow Braking允许速度控制器施加制动电流，一般情况下，应该启用此选项，但对于某些应用程序，在速度控制期间禁用制动可能是有意义的。    2. 位置环：正常的PID；Position PID Kd Filter同上；Position Angle Division位置控制器的角度划分，可用于将一个控制旋转映射到多个电机旋转，有点像加减速比的操作⑥Additional Info：    1. General：前面的都不重要；Motor Poles电机极对数；Position</code></pre><p>Sensor 位置信息编码器，同FOC中的Sensor Mode类似，队内常用AS5047；Motor Loss Torque电机损失扭矩</p><pre><code>    2.Descrip和Quality不用管</code></pre><p>四、 App Settings：<br>①. General：<br>1.APP to Use：不用调整<br>2.VESC ID：设置VESC驱动器的CAN ID，需要与单片机程序对应。VESC的ID从    1开始。<br>3.Timeout：超时时间，当VESC接收不到信息超过该时间后将会断连并失能电机<br>4.Timeout Brake Current：超时后用该电流对电机施加制动，不用调整<br>5.Send CAN Status：是否定期在CAN总线上发送状态消息。有助于让其他VESC    知道哪些VESC在CAN总线上。<br>6.Can Status Rate：当启用Send CAN Status时，状态消息发送的频率。<br>7.CAN Baud Rate：CAN总线的波特率，总线上的所有设备必须具有相同的波特率，    否则VESC将会无法接收到CAN报文。队内CAN的波特率为1M。</p><p>②．PPM：<br>1.General：<br>1&gt;Control Type：控制方式<br>Off：无论输入如何，输出都将关闭。<br>Current：电流控制。当输入居中时，输出关闭。输入小于中心的制动器，    直到电机停止，此时电机以相反方向启动。<br>Current No Reverse：电流控制。当输入最小时，输出关闭。<br>Current No Reverse Brake：电流控制。当输入居中时，输出关闭。输入    小于中心的制动器，直到电机停止，但不能进一步停止。<br>Duty Cycle：电流控制。当输入居中时，输出关闭。小于中心的输入给出    负占空比。<br>Duty Cycle No Reverse：占空比控制。当输入最小时，输出关闭。<br>PID Speed Control：PID速度控制。当输入居中时，输出关闭。小于中心    的输入给出负的设定速度。<br>PID Speed Control No Reverse：占空比控制。当输入最小时，输出关闭。</p><p>2&gt;Median Filter：是否对解码的脉冲使用中值滤波器。开启后将略微延迟信号，    但会避免由噪声引起的异常值。<br>3&gt;Safe Start：是否开启安全启动<br>4&gt;PID Max EPRM：使用PID速度控制时与最大输入相对应的电转速设置点。<br>5&gt;Positive Ramping Time：正斜坡时间常数。通过斜坡来过滤输入，这个常数    表示从零到完全输出所需的秒数。<br>6&gt;Negative Ramping Time：负斜坡时间常数。与上个参数恰好相反。</p><p><7.8.9是总线上存在多个VESC时需要考虑的参数><br>7&gt;Multiple VESCs Over CAN：是否监听CAN总线上的其他VESC，并向它们    发送相同的控制命令。请注意，只需在主VESC上设置应用程序。<br>8&gt;Traction Control：是否启用通过CAN总线连接的多个VESC之间的牵引力    控制。<br>9&gt;TC Max ERPM Difference：最快的电机完全关闭的ERPM差异。如果ERPM    的差值低于该差值，则流向更快电机的电流将按比例缩小。<br>2.Mapping和Throttle Curve不重要</p><p>③．ADC：参考PPM，不重要<br>④．UART：设置波特率为115200bps即可<br>⑤．Nunchuk：参考PPM，不重要<br>⑥．Nrf：<br>五、 Data Analysis：<br>①.Realtime Data：接收VESC反馈来的电机数据，需要打开右侧栏的按钮才能接收</p><p>1.Current：电机电流<br>2.Temperature：电机温度<br>3.RPM：电机转速（实际上是电转速）<br>4.FOC：FOC算法下给出的直轴与交轴电流ID与IQ<br>5.Rotor Position：转子位置，对于无感模式而言，可以点击右侧的Observer观察；对于有感模式而言，可以点击右侧的Encoder观察，Encoder的数据会随着电机转动而在0-360之间变化，在判断编码器是否有问题时，可以观察此界面的数据是否随电机转动而变化。</p><p>②.Sampled Data：不重要</p><p>/<strong><strong><strong><em>*</em></strong></strong></strong>右侧操作栏<strong><strong><strong><em>*</em></strong></strong></strong>/<br>连接<br>断连<br>读取Motor Settings参数①<br>复位Motor Settings参数<br>写入Motor Settings参数①<br>读取App Settings参数②<br>复位App Settings参数<br>写入App Settings参数②<br>启用方向键控制③<br>启用数据波形图④<br>不重要<br>启用心跳报文<br>不重要</p><p>①：当整定完成后，你在之后对任何Motor Settings参数的修改（例如PID）都必须点击“写入Motor Settings参数”键才能使之写入VESC从而生效，这点还请切记！当整定完成后，整定的数据将存入VESC驱动器中并得以保存，允许掉电或插拔（注意：由于三相线的接法会影响电机的正方向，因而尽量不要拔掉电机与驱动器的三相线连接，如果非要如此，请记住三相线线序并在下次按原序接回）而不丢失，当下次使用同一块VESC整定同一电机时，可以直接点击“读取Motor Settings参数”键来直接获取相关信息而无需重新整定。<br>②：同理于①，整定完成后如果修改App Settings的参数（例如VESC ID）都必须点击“写入App Settings参数”键以生效，当下次使用同一块VESC整定同一电机时，可以直接点击“读取App Settings参数”键来直接获取相关信息。综合①②，在修改参数完成后，请统一点击“写入Motor Settings参数”和“写入App Settings参数”；当下次使用同一块VESC整定同一电机时，请统一点击“读取Motor Settings参数”和“读取App Settings参数”。<br>③：启用方向键控制后，可以用上下左右键控制电机转动，其中上下键控制加正反向电流，左右键控制加正反向速度。一般用来检验整定后电机是否能正常控制，在加电流时电机会不断加速，请留心占空比不要过大，注意安全！（同时按下左右键也会为电机加速，请小心）<br>④：启用数据波形图后，便可以在Realtime Data中查看电机运行时的各项参数了。</p><p>/<strong><strong><strong><em>*</em></strong></strong></strong>下方操作栏<strong><strong><strong><em>*</em></strong></strong></strong>/<br>当电机整定完成后，我们便可以设定下方操作栏的参数来控制电机了</p><p>1.D：占空比模式，设置电机运行时的占空比<br>2.I：电流模式，设置电机运行时的电流<br>3.ω：速度模式，设置电机运行时的速度<br>4.P：位置模式，设置电机要转到的角度<br>以上四个模式相互独立，要使用哪个模式时，就在哪个模式对应的文本框中修改参数，并点击该模式右侧对应的按键，请注意：在按下该按键后，电机就会立刻启动，请注意安全！<br>我们一般只会用到速度模式，初学时速度请设置在10000-25000 ERPM之间。<br>停止电机的按钮是这两个：</p><p>左边的按钮是急停，右边的按钮是缓停，可以都试试看感受一下区别。<br>最右边的是状态栏：</p><p>上方为占空比，可以根据占空比判断当前状态下的电机负荷情况，并推测电机满载值<br>下方为当前电机电流情况，电流的最大值不会超过整定时设置的最大电流<br>占空比和电流都有正负显示，当占空比过大或电流拉满时，请立即停止电机！</p><p>/<strong><strong><strong><em>**</em></strong></strong></strong>整定流程<strong><strong><strong><em>**</em></strong></strong></strong>/<br>在整定之前，请确保硬件连接无误且已连接上VESC<br>在Welcome&amp;Wizard界面，点击下方中键Motor Setup Wizard[Motor]弹出如下界面：</p><p>点击Next后弹出如下界面：</p><p>点击Next后弹出如下界面，在这里设置电机运行的最大电流，初学时建议把Motor Current Max和Motor Current Max Break都设置为30A：</p><p>点击Next后弹出如下界面，在这里设置电池节数，我们在Cell这里修改为6，并点击Apply：</p><p>点击Next后弹出如下界面，在这里设置无感或有感模式，无感请选择Sensorless，有感请选择队里使用的AS5047 Encoder编码器：</p><p>点击Next后弹出如下界面，我们会在这个画面整定电机，请注意安全！<br>请根据向导，先点击问号图标右边的第一个按钮，此时VESC会检测电机的电阻与电感，弹出如下对话框后点击OK，电机将会在短暂延迟后产生明显的噪声，属正常现象，这一步通过后，R和L的背景颜色将会变成绿色。</p><p>接下来，按顺序点击问号图标右边的第二个按钮，此时VESC会检测电机的旋转参数，请注意：在弹出的对话框中点击OK后，电机将会高速旋转，请确保电机已经被良好固定且旋转过程中不会受到任何阻滞，这一步非常危险，初学时最好有学长陪同，请注意安全！这一步通过后，λ，KP，KI和Observer Gain的背景颜色将会变成绿色。当所有的框都变为绿色后（如下图），意味着这一步的整定完成，点击Apply上传参数。</p><p>IF：在这一步中很有可能会出现整定失败的情况或看似整定成功的情况。整定失败的明显特征是点击OK后连续出现三次噪声（这是VESC在尝试让电机旋转起来，无需惊慌，有时候第一次不行，后面两次就可以了），最后弹出带有红色感叹号的警告框（当然有时候它能转起来，是否整定失败的关键还是看该警告框是否出现）。由于这一步的整定与是否有感整定无关，故大概率是由于电机阻力或机械结构等问题导致的，此时我们可以通过调高I,λ或降低ω来尝试通过整定。通常调大I不超过10A，占空比λ不超过0.7（一般I给7-8A就可以了）。这样子VESC将会加大功率来让电机转起来以测定参数，当然这么做带来的必然结果是电机会转的更快，因而也是非常危险的！<br>有的时候也会出现看似整定成功的情况，其明显特征就是虽然框都绿了，但参数非常不对劲，例如R和λ的值达到了几千的情况，这也是不合理的，即使整定完成电机也转不起来，请按照上面的方法重新整定。<br>这一步会出现非常多可能的异常情况，如果自己尝试无果后请联系学长解决！</p><p>如果成功通过了这一步，对于无感模式来说，整定便已经完成了；而对于有感模式而言，我们还有最后一步，即整定编码器，点击Next后弹出如下界面：</p><p>点击I:10.00A后的启动键，电机就会开始有感整定，具体分为两步，首先电机会朝着一个方向缓慢运动后反向，如果编码器连接无误，接下来电机会朝着一个方向脉动后反向并完成有感整定。如果编码器连接出现错误，电机会在第一步完成后弹出错误窗口，请检查你的编码线连接以及编码器本身是否有问题（可以在Rotor Position-&gt;Encoder中检查）</p><p>这一步完成后，恭喜你，你就已经完成了一个电机的整定，可以通过方向键或下方操作栏来尝试控制电机了！如果方向键控制没什么问题的话，电机整定就基本算通过了，下方操作栏的控制与PID有一定的关系，请尝试调整PID得到完美的控制曲线吧！<br>最后来总结一下一般的整定流程吧：<br>先空载整定各基本参数，PID可以先不着急整定，但可以大致看看纯Kp曲线最后会不会趋平，如果会有固有振荡，则机械上可能存在一定问题。当完成基本参数整定后，这些参数会被保存在本杰明板里，因而一般整定完成后电机与本杰明连接的三相线，编码器与本杰明连接的编码线就不会再进行拆卸。当装上负载并连接完成后，依次点击连接本杰明，并把本杰明的数据读到电机里，之后就可以整定PID了。</p><p>/<strong><strong><strong><em>**</em></strong></strong></strong>其他事项<strong><strong><strong><em>**</em></strong></strong></strong>/<br>1.祖传PID：</p><p>2.关于位置环：<br>VESC的位置环范围仅限0-360°<br>但利用PID Controllers-&gt;Position Controller-&gt;Position Angle Division调整减速比以实现转多圈的效果。<br>VESC位置环符合约瑟夫环思想，即总是以最近角度达到所在的位置。例如现在角度为260，如果输入10，VESC不会认为从260反转到10，而认为是260正转到10（260-&gt;360(0)-&gt;10）</p><p>3.关于VESC驱动器警报：<br>红灯闪三下：芯片故障</p><p>V3.00使用说明（大本杰明）<br>1.整定流程：<br>Autoconnect不变-&gt;Setup Motors VESC-&gt;电机选型为Small Outrunner-&gt;Battery Cells Series=6-&gt;设置减速比（电机侧与轮系侧比例，如果直驱则直接勾选Direct Drive即可）-&gt;Run Detection(no CAN)，之后VESC就会自动完成整定流程，基本流程仍是振动-&gt;转圈-&gt;编码器。<br>整定成功后会弹出如下窗口，重要参数是最后一个Sensors，它表明了你是否使用编码器（有感还是无感），之后把界面close即可，整定完成。<br>注意：大本杰明缺省的波特率CAN Baud Rate是500K，要把它改成队里通用的1M（在App Settings-&gt;General-&gt;CAN Baud Rate里）<br>调整Can Status Message Mode可以将本杰明反馈的报文设置精简或详细，可以发送0-5条不同信息的报文，一般设置为4即可（4即为对应小本杰明的0x901-0x908，反馈最基本的速度角度电流信息）</p><p>后记<br>在此之前，队内一直都没有一个系统的VESC使用指南，该指南由戚竣皓提议与牵头制作，由戚竣皓与沈畅进行编辑与审稿，由刘昕磊负责部分截图的提供。本指南首次完成于2023.8.24，不足与错误在所难免，希望后人不断完善。</p><ul><li>@Description: WHU机器人队VESC使用指南</li><li>@Version: 1.0.0</li><li>@Date: 2023-08-24 15:36:49</li><li>@LastEditTime: 2023-08-24 15:36:49</li></ul><p>—-WHU_ROBOCON All Rights Reserved—-</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电机驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大疆电调</title>
      <link href="/2023/08/26/DJI/"/>
      <url>/2023/08/26/DJI/</url>
      
        <content type="html"><![CDATA[<p>首先要明确一个概念，控制大疆电机我们只能控制其给定的电流，即我们只能将要设置的电流以CAN报文的形式发送给大疆电机的电调（DJ_CurrentTransmit）<br>电流对电机的作用是给他一个恒定的速度，电流越大速度越大。<br>大疆电机采用三环嵌套：电流环-&gt;速度环-&gt;位置环</p><p>大疆DJMotor结构体里定义了两个PID结构体分别控制位置环PID和速度环PID：<br>typedef struct<br>{<br>    vs32 SetVal;        //要PID调节参数的目标值<br>vs32 CurVal;        //要PID调节参数的当前值<br>    float Kp;            //PID参数<br>    float Ki;<br>    float Kd;<br>    vs32 delta;        //PID增量<br>    vs32 midVal[3];    //本次偏差，上次偏差，上上次偏差<br>}Inc_PIDTypedef;<br>Inc_PIDTypedef PID_POS,PID_RPM;</p><p>在PID初始化中赋值要调整参数的目标值Set和PID参数Kp/Ki/Kd：<br>void Inc_PID_Init(Inc_PIDTypedef* PID,float KP,float KI,float KD,int Set)<br>{<br>    PID-&gt;CurVal=0;<br>    PID-&gt;SetVal=Set;<br>    PID-&gt;midVal[0]=0;<br>    PID-&gt;midVal[1]=0;<br>    PID-&gt;midVal[2]=0;<br>    PID-&gt;Kp=KP;<br>    PID-&gt;Ki=KI;<br>    PID-&gt;Kd=KD;<br>}<br>Inc_PID_Init(&amp;DJmotor[PitchID].PID_POS, 1.3, 0.2, 0.0,DJmotor[ID].valueSet.pulse);<br>Inc_PID_Init(&amp;DJmotor[PitchID].PID_RPM, 8.0, 0.5, 0.0,DJmotor[ID].valueSet.speed);</p><p>增量式PID调节函数：<br>void Inc_PID_Operation(Inc_PIDTypedef<em> PID)<br>{<br>    PID-&gt;midVal[0]=PID-&gt;SetVal-PID-&gt;CurVal;    //得到当前偏差<br>    PID-&gt;delta = PID-&gt;Kp </em> (PID-&gt;midVal[0]-PID-&gt;midVal[1]) + PID-&gt;Ki <em> PID-&gt;midVal[0] + PID-&gt;Kd     </em> (PID-&gt;midVal[0]+PID-&gt;midVal[2]-2<em>PID-&gt;midVal[1]);    //得到当前增量<br>    PID-&gt;midVal[2]=PID-&gt;midVal[1];    //更新上次偏差与上上次偏差<br>    PID-&gt;midVal[1]=PID-&gt;midVal[0];<br>}<br>Inc_PID_Operation(&amp;DJmotor[id].PID_POS);<br>Inc_PID_Operation(&amp;DJmotor[id].PID_RPM);<br>增量式PID原理：可参考pid文档，这里简单概括一下。比例相Kp调节当前偏差和上次偏差的差值，积分项Ki调节当前偏差，微分相Kd调节当前偏差和上次偏差的差值和上次偏差和上上次偏差的差值的差值(PID-&gt;midVal[0]-</em>PID-&gt;midVal[1])-(PID-&gt;midVal[1]-*PID-&gt;midVal[2])<br>由于增量式PID控制增量，所以其公式可以由两次相邻时刻位置型PID的差值推得：</p><p>可以看到，结果就是这么来的。</p><p>了解以上知识后，我们就可以看大疆PID的调节了：<br>用电流控制速度：<br>    DJmotor[id].PID_RPM.SetVal = DJmotor[id].valueSet.speed;<br>    DJmotor[id].PID_RPM.CurVal = DJmotor[id].valueReal.speed;<br>    Inc_PID_Operation(&amp;DJmotor[id].PID_RPM);<br>    DJmotor[id].valueSet.current += DJmotor[id].PID_RPM.delta;<br>根据设定速度和当前速度进行增量式PID调节，将增量加到电流相当于加到速度。<br>用电流控制位置：<br>      DJmotor[id].PID_POS.SetVal = DJmotor[id].valueSet.pulse;<br>    DJmotor[id].PID_POS.CurVal = DJmotor[id].valueReal.pulse;<br>    Inc_PID_Operation(&amp;DJmotor[id].PID_POS);<br>    DJmotor[id].PID_RPM.SetVal = DJmotor[id].PID_POS.delta;<br>    DJmotor[id].PID_RPM.CurVal = DJmotor[id].valueReal.speed;<br>Inc_PID_Operation(&amp;DJmotor[id].PID_RPM);<br>    DJmotor[id].valueSet.current += DJmotor[id].PID_RPM.delta;<br>控制位置分为两步，由于速度是位置的导数，故先根据设定位置和当前位置进行增量式    PID调节，而其增量就是速度，故直接将增量结果赋值给要设定的速度（而非自加）<br>接着再根据速度和当前速度进行增量式PID调节，将增量加到电流。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电机驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOC电机控制算法</title>
      <link href="/2023/08/26/FOC/"/>
      <url>/2023/08/26/FOC/</url>
      
        <content type="html"><![CDATA[<p>直流无刷电机的工作原理：<br>由于没有一般直流电机的换向刷，故控制直流无刷电机实质上就是对其硬件mos管开关规律的控制。假设Q0、Q1代表A相，Q2、Q3代表B相，Q4、Q5代表C相。以打开Q1，Q2为例，此时A线圈上S下N，B线圈左S右N，所以转子磁铁会转到图中的状态。以此类推，我们依序将AB-&gt;AC-&gt;BC-&gt;BA-&gt;CA-&gt;CB-&gt;AB……通电，则转子便可以以一定的速度循环转动起来。而要让mos管按照我们的要求开闭，就需要编写单片机程序来实现高速规律控制。这种程序就是FOC算法，FOC算法就是对电机的运动建立数学模型，把电机的运动抽象化，使单片机能够根据这个算法控制电机产生我们想要的力矩和速度。</p><p>我们知道，直流无刷电机由三相线接入三股相位相差120°的电流分别作用于ABC三相，用相量法将其写作向量形式即如下图所示，同时我们将三相电流利用矢量分解合成到α-β坐标系下：</p><p>写作矩阵形式即：</p><p>这个变换就是所谓的克拉克变换，利用克拉克变换，我们就可以把三相电流降维成两个向量<br>Iα和Iβ，由基尔霍夫电流定律和电机的对称性，如果我们假设电流从A相流入，我们可以得到两个方程：ia+ib+ic=0,ib=ic。故有ib=ic=-0.5ia，代入克拉克变换的第一个方程就有Iα=1.5ia。在实际应用时，为了简化运算，我们希望Iα能完全等于ia，故因此我们对克拉克变换额外乘以一个系数2/3，这样子Iα就等于ia了。反映在坐标变换下，就是除了进行矢量的分解合成外，还对合成到α-β坐标系下的矢量作了比例变换。此时的克拉克变换称为等幅值形式的克拉克变换。其格式如下图所示，即比普通的克拉克变换多了一个系数2/3。</p><p>借助基尔霍夫电流定律我们还可以知道，我们并非要得到ia，ib，ic三相电流而只需要知晓其中两相即可，已知在等幅值形式的克拉克变换下有Iα=ia。进一步我们可以求由两相电流表示的Iβ：</p><p>于是简化的等幅值形式克拉克变换即：</p><p>反过来，如果我们已知了ia，ib，ic三相电流，则我们也可以得到Iα和Iβ，这个过程被称为等幅值形式的克拉克逆变换：</p><p>写作矩阵形式即：</p><p>利用克拉克变换，我们成功实现了把三相电流降维成两个向量Iα和Iβ，但通过Iα和Iβ还不足以直观的反映电机旋转的物理状态，为此，我们进一步引入帕克变换。<br>容易得到，克拉克变换所建立的α-β坐标系是固定在定子上的，为了反映电机旋转的物理状态，我们于是在转子上也建立一个被称为Q-D（交轴-直轴）的坐标系，这个坐标系随转子旋转，定义D轴方向为沿转子N极中心线的方向。此时Q-D坐标系与α-β坐标系的角度差即为电机转动的电角度，它反映了电机的转动；而IQ和ID（交轴电流，直轴电流）即为两个定值（且通常ID=0），它们反映了电机给定的力矩。</p><p>借助坐标转换我们容易得到IQ、ID和Iα、Iβ的关系如下，这个关系就是帕克变换：</p><p>同理它的逆变换式就是：</p><p>帕克变换的精髓在于，他通过坐标转换得到了大小与方向分离的两组量，作为定值的IQ和ID仅反映了电机的力矩，而电机的旋转过程则完全由变量电角度θ体现，于是乎，我们想要控制电机的力矩，只需要为IQ和ID赋值即可，而电机旋转带来的矢量变化则通过电角度θ，借助帕克逆变换和克拉克逆变换自然地反映到了三相电流ia，ib，ic中，进而控制电机的运动，整个过程省去了复杂的矢量旋转与计算。<br>综上，整个FOC算法的过程就是：</p><p>而三相电流ia，ib，ic驱动电机转过一个角度后，在下一瞬间角度传感器便会更新θ的值，从而在新的时刻重复这一循环。<br>同理，我们也可以得到电压形式的帕克逆变换和克拉克逆变换，两者实质上没有区别：</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil学习</title>
      <link href="/2023/08/24/keil/"/>
      <url>/2023/08/24/keil/</url>
      
        <content type="html"><![CDATA[<p>Keil+vscode联合开发：<a href="https://www.yisu.com/zixun/607208.html">https://www.yisu.com/zixun/607208.html</a><br>字体问题：Edit-&gt;Configuration-&gt;Encoding 可以选择ANSI，UTF-8或GB2312<br>有时透过vscode打开时中文会出现乱码，此时一定要先把vscode的字体改成GB2312再保存，否则keil工程的中文会全部变成乱码<br>当然，上面这个博客写的很详细了，直接参照博客的方法也可以</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keil </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波器</title>
      <link href="/2023/08/22/kalman/"/>
      <url>/2023/08/22/kalman/</url>
      
        <content type="html"><![CDATA[<p>卡尔曼滤波器的主要作用是估计系统的状态,并根据未来的预测值来对系统进行控制。它可以帮助我们从含有噪声和误差的传感器数据中提取出准确的信息,并且具有良好的实时性和可靠性。</p><p>Hat{xk}为第k次取平均得到的对真实数据的估计，zk为第k次的测量结果</p><p>新的估计值与上一次的估计值有关，这是一个递推式。<br>卡尔曼滤波器不需要追溯很久以前的数据，而只需要上一次的数据结果即可，这是一种递归的思想。<br>估计误差eest=估计值-真实值，估计误差是变化的。<br>测量误差emea=max(测量值-真实值)，测量误差是固定的，由测量仪器决定。这也决定了测量结果必然是在真实值附近的，以测量误差为阈值的随机波动（且通常呈现正态分布），且只有满足这一输入情况的测量数据才能应用卡尔曼滤波器滤波。</p><p>当k-1次的估计误差远大于k次的测量误差时，<br>当k-1次的估计误差远小于k次的测量误差时，<br>卡尔曼滤波器的循环递归过程如下所示：</p><p>协方差Cov描述了两个变量之间的相关性，在数学意义下，认为当Cov&gt;0时两变量呈现正相关，即X增大Y也增大，当Cov<0时认为两变量呈现负相关，即X增大Y减小，当Cov=0时认为两变量不相关，即X增大与减小和Y增大与减小之间无关联。在统计学意义下，认为当Cov>&gt;0时两变量呈现正相关，当Cov&lt;<0时认为两变量呈现负相关，当Cov->0时认为两变量不相关。协方差的公式为：<br>Cov(X,Y) = E[XY] - E[X]E[Y]=E[(X - E(X))(Y - E(Y))]<br>协方差矩阵是一个对称矩阵</p><p>对于一个离散模型而言，我们可以离散状态空间方程的形式去表示它：</p><p>其中X为状态变量，U为输入量，Z为输出量/测量量（可观测）<br>当然，上述模型是一个理想模型，在实际的模型中，我们的系统会有噪声，测量也会不可避免的出现误差，因而对于一个实际模型而言，我们一般会为其加上过程噪声和测量噪声，即：</p><p>过程噪声和测量噪声是不可测的，但他们都被认为符合正态分布，即：</p><p>这里假设ω的协方差矩阵为Q，v的协方差矩阵为R<br>对于期望为0的正态分布，其协方差矩阵有如下计算公式：</p><p>推导如下，以两变量的协方差矩阵为例：</p><p>由于方差=平方的期望-期望的平方，而对于期望为0的正态分布变量ω1，ω2而言，其期望的平方E2(ω1)和E2(ω2)显然均为0。故其平方的期望E(ω12)和E(ω22)就等于方差Var(ω1)和Var(ω2)。而又由协方差公式Cov(ω1,ω2) = E[ω1ω2] - E[ω1]E[ω2]=E[ω1ω2]，因而可以看到，上式就可以改写成：</p><p>证毕。</p><p>当我们使用理想模型得到xk的计算值和测量值时，此时这两个值都不是精确解，而仅仅只是一个估计值，但很显然，由于噪声的存在，我们永远都不可能得到这个精确解。此时我们就要使用数据融合的相关知识来得到一个最优解：<br>先从一个例子入手，我们要测得一个物体的真实质量，现在我们有两个秤，一个秤的标准差为2g，测量结果为30g；另一个秤的标准差为4g，测量结果为32g。那么这个物体的真实质量的最优解是多少呢？</p><p>首先我们要认清一个概念，最优解是什么意思？显然，应该是在该解处的方差最小，说明了该解是最精确的。回到题目，我们虽然测量出了两个结果，但由于秤1的方差比秤2的方差更低，从定性上看我们应更信任秤1的结果。为此，引入信任参数K（这个参数也就是卡尔曼增益），引入最优解函数hat{z}=z1+k(z2-z1)。显然，当k-&gt;0时，我们更信任z1；当k-&gt;1时，我们更信任z2。则现在的求解关键就是求K使得hat{z}的方差最小，为此，我们就要求hat{z}的方差并令导数为零即可，具体推导过程如下：</p><p>回到正题，我们的计算值hat{xk-}和测量值hat{xkmea}显然也满足上述的数据融合理念：</p><p>现在的问题很简单，我们如何利用不准确的计算值和测量值来得到一个最优解作为k时刻的值，为此我们依照数据融合的知识构建最优解函数（注意上面算出来的是先验估计结果，经过最优解函数求解得到的是后验估计结果，注意状态量方程的公式是：本次的先验估计结果=A<em>上一次的后验估计结果+B</em>输入值，这个公式告诉我们，我们通过状态量方程得到的先验估计结果必须经过最优解函数得到后验估计结果，而下一次的先验估计结果则由本次的后验估计结果决定而非本次的先验估计结果）：</p><p>上述红框中的表达式即为卡尔曼滤波器标准方程，现在的目标就是寻找最优解：</p><p>为了让计算的参数符合期望为0的正态分布，我们引入第k次的误差ek并假设其协方差矩阵为Pk：<br>，<br>故此时的最优解即为ek的方差最小，由于此时的ek为矩阵，其方差最小也就是各变量的方差之和最小，也就是协方差矩阵Pk的迹最小（方阵的迹：方阵X的主对角线上的所有元素之和称之为X的迹，记为tr(X)，即tr(X)=∑xii）。<br>我们先利用公式求解协方差矩阵Pk：</p><p>将hat{xk}利用卡尔曼滤波器公式带入：</p><p>则上式等于：</p><p>先看第二项的期望，由于I-KkH和Kk都是常数，因而第二项的期望也就是下式的期望：</p><p>而由于ek和vk是互相独立的变量，且两者的期望均为0。故E(ek-vkT)=E(ek-)E(vkT)=0。<br>同理第三项的结果也为0，则上式可以进一步写作：</p><p>由于E(ek-ek-T)=Pk-，E(vkvkT)=R（Pk-是第k次的先验误差协方差矩阵，R为测量误差协方差矩阵，由于测量误差恒定，故R为一常数，不随k而改变），故进一步展开：</p><p>得到了Pk的表达式后，下一步就是求其迹的极值，即导数为0的Kk值：<br>在此之前，我们先补充几个矩阵导数公式：</p><p>同理可以推导：</p><p>我们发现，由于Pk-为协方差矩阵，协方差矩阵是一个对称矩阵，而对称矩阵的转置为其本身，故上式的第二项和第三项是转置关系，而两个互为转置的矩阵的迹相等，于是合并第二项与第三项并使用公式1，对第四项和第五项使用公式2，有：</p><p>进一步推导：</p><p>可以看到，这就是卡尔曼增益Kk估计/(估计+测量)的公式由来（严格来说，上式的除法应该写作矩阵的逆，除法只在矩阵为1*1的数时成立，但为了与标准形式对照便如此写）<br>接下来计算一下Pk-的值，首先我们要得到ek-的值：</p><p>则：</p><p>由于ek-1和ωk-1互相独立，而E(ek-1)和E(ωk-1)都等于0，故第二项和第三项为0，则上式：</p><p>而：</p><p>蓝色项将Kk代入就是：</p><p>故：</p><p>于是卡尔曼滤波的一般过程即：<br>1.根据上一次的后验结果hat{xk-1}和输入uk-1得到这一次的先验结果hat{xk-}<br>2.根据上一次的后验误差协方差Pk-1得到这一次的先验误差协方差Pk-<br>3.根据这一次的先验误差协方差Pk-得到这一次的卡尔曼增益Kk<br>4.根据这一次的先验结果hat{xk-}、卡尔曼增益Kk和测量值zk得到这一次的后验结果hat{xk}，而后验结果hat{xk}也就是我们需要的最优解<br>5.根据这一次的先验误差协方差Pk-和卡尔曼增益Kk得到这一次的后验误差协方差Pk<br>6.进入下一次迭代<br>可以看到卡尔曼滤波是一个递归过程，每一次的计算均只与上一次的结果有关。<br>其中需要用到的参数常量为状态矩阵A，输入矩阵B，过程噪声协方差矩阵Q，测量噪声协方差矩阵R，输出矩阵H。此外，我们还要给定递归起点，即初始状态hat{x0}和P0。</p><p>IIR滤波器(Infinite Impulse Response Filter)是一种数字滤波器，它的输出信号是由过去的输入信号和输出信号的加权和组成的。</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>底盘运动学解算</title>
      <link href="/2023/08/19/omni/"/>
      <url>/2023/08/19/omni/</url>
      
        <content type="html"><![CDATA[<p>全向轮：<br>参考视频：<a href="https://www.bilibili.com/video/BV1rX4y1p7n7">https://www.bilibili.com/video/BV1rX4y1p7n7</a></p><p>舵轮：<br>注意：解算图中各个轮子的w反了。<br>V1、V2、V3、V4为行进轮的速度，θ1、θ2、θ3、θ4为舵轮的转向角。知道了这八个参数，就可以确定车体的运动。</p><h1 id="ifdef-OMNI-3-全向等边三轮"><a href="#ifdef-OMNI-3-全向等边三轮" class="headerlink" title="ifdef OMNI_3 //全向等边三轮"></a>ifdef OMNI_3 //全向等边三轮</h1><pre><code>chassis.wheel[0].v = (speed_wantset.vx - speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);chassis.wheel[1].v = (-cos_60 * speed_wantset.vx + cos_30 * speed_wantset.vy - speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);chassis.wheel[2].v = (-cos_60 * speed_wantset.vx - cos_30 * speed_wantset.vy - speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);</code></pre><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><h1 id="ifdef-OMNI-4a-全向正方形四轮"><a href="#ifdef-OMNI-4a-全向正方形四轮" class="headerlink" title="ifdef OMNI_4a //全向正方形四轮"></a>ifdef OMNI_4a //全向正方形四轮</h1><pre><code>chassis.wheel[0].v = (-cos_45 * speed_wantset.vx + cos_45 * speed_wantset.vy + speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);chassis.wheel[1].v = (-cos_45 * speed_wantset.vx - cos_45 * speed_wantset.vy + speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);chassis.wheel[2].v = (cos_45 * speed_wantset.vx - cos_45 * speed_wantset.vy + speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);chassis.wheel[3].v = (cos_45 * speed_wantset.vx + cos_45 * speed_wantset.vy + speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);</code></pre><h1 id="endif-1"><a href="#endif-1" class="headerlink" title="endif"></a>endif</h1><h1 id="ifdef-OMNI-4b-全向长方形四轮"><a href="#ifdef-OMNI-4b-全向长方形四轮" class="headerlink" title="ifdef OMNI_4b //全向长方形四轮"></a>ifdef OMNI_4b //全向长方形四轮</h1><pre><code>float m = 30, n = 20;WheelSpeed[0] = (-cos_45 * speed_wantset.vx + cos_45 * speed_wantset.vy + (m + n) * speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);WheelSpeed[1] = (-cos_45 * speed_wantset.vx - cos_45 * speed_wantset.vy + (-m + n) * speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);WheelSpeed[2] = (cos_45 * speed_wantset.vx - cos_45 * speed_wantset.vy + (-m + -n) * speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);WheelSpeed[3] = (cos_45 * speed_wantset.vx + cos_45 * speed_wantset.vy + (m + -n) * speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);</code></pre><h1 id="endif-2"><a href="#endif-2" class="headerlink" title="endif"></a>endif</h1><h1 id="ifdef-MECANUM-麦克纳姆轮"><a href="#ifdef-MECANUM-麦克纳姆轮" class="headerlink" title="ifdef MECANUM //麦克纳姆轮"></a>ifdef MECANUM //麦克纳姆轮</h1><pre><code>float m = 30, n = 20;WheelSpeed[0] = (-1 * speed_wantset.vx + (-1) * speed_wantset.vy + (m + n) * speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);WheelSpeed[1] = (-1 * speed_wantset.vx + (-1) * speed_wantset.vy + (m + n) * speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);WheelSpeed[2] = (1 * speed_wantset.vx + (1) * speed_wantset.vy + (m + n) * speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);WheelSpeed[3] = (1 * speed_wantset.vx + (1) * speed_wantset.vy + (m + n) * speed_wantset.vw * chassis.omni_wheel2center * PI / 180.f);</code></pre><h1 id="endif-3"><a href="#endif-3" class="headerlink" title="endif"></a>endif</h1><h1 id="ifdef-STEER-3"><a href="#ifdef-STEER-3" class="headerlink" title="ifdef STEER_3"></a>ifdef STEER_3</h1><pre><code>//应该都是正号，廖叔没有改电机正方向int i = 0;float add_angle;chassis.wheel[0].vx = -speed_wantset.vx - speed_wantset.vw * chassis.R_1 * PI / 180.f;chassis.wheel[0].vy = -speed_wantset.vy;chassis.wheel[0].v = sqrt(chassis.wheel[0].vx * chassis.wheel[0].vx + chassis.wheel[0].vy * chassis.wheel[0].vy);chassis.wheel[1].vx = -speed_wantset.vx + speed_wantset.vw * chassis.width_23 * PI / 180.f;chassis.wheel[1].vy = -speed_wantset.vy - speed_wantset.vw * chassis.length_23 * PI / 180.f;chassis.wheel[1].v = sqrt(chassis.wheel[1].vx * chassis.wheel[1].vx + chassis.wheel[1].vy * chassis.wheel[1].vy);chassis.wheel[2].vx = -speed_wantset.vx + speed_wantset.vw * chassis.width_23 * PI / 180.f;chassis.wheel[2].vy = -speed_wantset.vy + speed_wantset.vw * chassis.length_23 * PI / 180.f;chassis.wheel[2].v = sqrt(chassis.wheel[2].vx * chassis.wheel[2].vx + chassis.wheel[2].vy * chassis.wheel[2].vy);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲线插值与拟合算法</title>
      <link href="/2023/08/16/bezier/"/>
      <url>/2023/08/16/bezier/</url>
      
        <content type="html"><![CDATA[<p>贝赛尔曲线相关知识：<a href="https://zhuanlan.zhihu.com/p/366678047">https://zhuanlan.zhihu.com/p/366678047</a></p><p>B样条曲线相关知识：<a href="https://www.guyuehome.com/37024">https://www.guyuehome.com/37024</a><br><a href="https://www.bilibili.com/video/BV1Qz4y1m7dS">https://www.bilibili.com/video/BV1Qz4y1m7dS</a></p><h1 id="1-贝赛尔曲线"><a href="#1-贝赛尔曲线" class="headerlink" title="1.贝赛尔曲线"></a>1.贝赛尔曲线</h1><p>可知每个点的生成方式与t的关系。下图的显示的t是均匀流逝的。若把下图的黑点当作智能体在二维平面上运动，而最终的贝塞尔曲线（红色曲线）为智能体最终的行驶轨迹，我们可以看到智能体在不同的时间的速度是不相等。大致的感觉是：弯度越大时，行驶速度越慢；越平直，速度越快。<br>对比几组实验，发现贝塞尔曲线上第个点的速度是有差异的。但是，每个点的速度与曲线的弯度（曲率）没有直接关系，而是与控制点间距离有关。从第四组实验可以看到，四个控制点共线，曲率在每处都为零，但是速度先增大后减小，这与头两个点距离最短，中间两个点距离最大有直接关系。</p><p>在实际速度规划中，我们期望在曲率（绝对值）大的地方，以较小的行驶速度行驶；在曲率（绝对值）小的地方，以较大的行驶速度行驶，从而在效率与安全之间达到一个很好平衡。贝塞尔曲线经常被用来设计或生成无人车的行驶轨迹，要得到期望速度，得先计算各点曲率，然后再通过设计好的函数，得到最终的期望速度。这样一个过程比较绕，贝塞尔曲线的t可以当作时间以固定比例的缩放（0到1之间）的值，很自然的想法是：各时间点的速度是否与实际无人车行驶的期望速度一致呢？经过本篇实现，很遗憾的结果是，贝塞尔曲线各点上的速度与曲率没有直接关系，所以不能直接用于速度规划。</p><p>但是，我们也发现：贝塞尔曲率各点的速度与各控制点的分布（前后点的距离）有关。在设计无人车轨迹时，一般会能确定几个控制点的位置（例如起点与未端点），以及其它控制点的部分约束（例如：始未两控制点的姿态一般是确定的，这样第二个控制点与倒数第二个控制点一定分别是在始未控制方向的前与后。），因此，可以在有限维度上调整各控制点的距离来达到在中观层面控制贝塞尔曲线上各点的目的，从而直接使用。</p><h1 id="2-B样条曲线"><a href="#2-B样条曲线" class="headerlink" title="2.B样条曲线"></a>2.B样条曲线</h1><p>为什么要引入B样条曲线？<br>B样条是贝塞尔曲线的延申，贝塞尔曲线是B样条的基础， B样条可以看成很多组贝塞尔曲线的拼接。<br>贝塞尔曲线是在汽车的曲线设计种首次被提出的，汽车的外形设计十分复杂，控制点的表示方式能够简化其数学描述，将其数学化的表示出来。<br>还记得贝塞尔曲线的特质吗？主要的两个， 1 阶次是控制点个数减1， 2 牵一发动全身，移动一个控制点，整段曲线都会变化。<br>如果要用贝塞尔曲线来设计上图种的汽车造型， 那么汽车的设计简直是噩梦，形状复杂的曲线需要更多的控制点，曲线的阶次就会变得非常高。牵一发而动全身， 想改一下车屁股的造型， 移动一下控制点，结果车头的造型也被改变了。<br>为了克服贝塞尔曲线的以上两大缺点，B样条应运而生了。<br>因此B样条的两个性质就是贝塞尔的缺点反过来：1 可以指定阶次。2 移动控制点仅仅改变曲线的部分形状，而不死整体<br>B样条采用解决方案是贝塞尔曲线的拼接，也就是把一条曲线变为多段贝塞尔曲线的拼接。</p><p>为了是B样条曲线具备上述形式，它需要有三大要素：节点，控制点，阶次。<br>其中节点可认为是分隔点，将区间[u0, um]细分为节点区间。所有B-样条基函数被假设定义域在[u0, um]上。在本文中，我们经常使用u0 = 0和um = 1，所以定义域是闭区间[0,1]。<br>控制点和贝塞尔的一样，就是空间上决定曲线形状的点，本文中用Pi表示。<br>k是阶次，与贝塞尔曲线不同，k阶B样条曲线的各段轨迹由k个控制点控制而非k-1个。</p><p>B样条曲线数学定义，其中P(u)即为值u下的轨迹点值，u从0到1完成曲线绘制：</p><p>Bi,k(u)作为B样条曲线的基函数，具有以下形式（可以类比贝赛尔曲线的伯恩斯坦多项式）：</p><p>这是一个递推式，可以看到基函数是关于u的函数，其他值均为常数与可递推值。<br>其中u的地位与贝塞尔曲线的t类似，只是贝赛尔曲线中t取[0,1]的各段是均匀的，而B样条曲线中的u在[0,1]的不同段下还具有不同的函数形式，这些分隔用常数ui表示。<br>这些分段就是为了实现贝塞尔曲线的拼接，而这些分隔点也就是节点。<br>于是整个[0,1]段被分割成了以下形式：</p><p>需要注意的是，有n+1个控制点和k阶，就需要n+k+1个分隔点。<br>感觉有点难以理解？没关系！我们先从B样条曲线的基函数Bi,k(u)的最特殊形式出发：<br>当阶次k=1时，此时的Bi,k(u)只在[ui,ui+1]处具有非零定义，即：</p><p>而当k&gt;=2时，由于各ui均为常数，而Bi,k-1和Bi+1,k-1均为上阶值，可以被递推得到，于是所有的Bi,k(u)值便被分隔点ui和阶次k完全确定，而最后的轨迹点P(u)则是可以看做由控制点Pi、分隔点ui和阶次k共同确定，这也是我们最初提出B样条曲线需要满足的需求。</p><p>接下来我们从更高的角度再审视B样条曲线：<br>以一个有四个控制点的四阶B样条曲线为例，则它需要8个分隔点u0-u7，此时P(u)=P0B0,4(u)+P1B1,4(u)+P2B2,4(u)+P3B3,4(u),u∈[0,1]（被8个分隔点分隔）<br>而B0,4(u)由递推关系可知它由B0,3(u)和B1,3(u)确定，而B0,3(u)又由B0,2(u)和B1,2(u)确定，B1,3(u)又由B2,2(u)和B1,2(u)确定，以此类推形成三角关系：即B0,4(u)完全由一阶基函数B0,1(u),B1,1(u),B2,1(u),B3,1(u)的线性组合构成，B1,4(u),B2,4(u),B3,4(u)也类似。即下图：</p><p>于是我们可以发现，作为控制点的Pi只能控制Bi,k(u)在非零域下的值，这也变相说明了B样条曲线下控制点只具有局部的控制能力。例如B0,3(u)只在[u0,u3)段非零，而在其他段由于其所有的基函数均为0，故B0,3(u)本身也为0，即P0作为控制点只有能力控制[u0,u3)段的曲线，其他阶段由于乘积为0，P0没有控制能力。<br>更进一步我们发现，对于任意一段节点区间[ui,ui+1)，至多有k个Bi,k(u)值非零，亦即至多有k个控制点对该节点区间起控制作用，这也说明了一段节点区间内形成的曲线，应该是一段近似于k-1阶贝塞尔曲线所达到的效果。例如在3阶b样条曲线[u2,u3)内，仅有B0,3(u),B1,3(u),B2,3(u)非零，对应控制点P0,P1,P2对其起控制作用实现类似2阶贝塞尔曲线。由此我们也可以看出，B样条曲线是若干条部分贝塞尔曲线的组合。</p><p>勘误：对于open B样条，u定义域为[uk-1,un+1]<br>什么是open B样条呢？<br>事实上我们发现，对于一段u∈[0,1]的b样条曲线而言，其形成的曲线是一段闭环曲线，且其有部分段是不符合我们定义b样条曲线的意图的。之前我们提到，对于任意一段节点区间[ui,ui+1)，至多有k个Bi,k(u)值非零，亦即至多有k个控制点对该节点区间起控制作用。那么什么叫至多呢？例如我们在3阶B样条曲线[u0,u1)段内时，此时仅有B0,3(u)非零，意味着在[u0,u1)段内仅有控制点P1发挥作用，而我们定义B样条曲线是为了发挥其分段贝塞尔的效果，因此，对于每一段节点区间，至少需要k个控制点，[u0,u1)段实际上是一段0阶贝塞尔，也就是从原点到P1的一条直线，这是错误定义的一段曲线，应当舍去。基于这个原理，我们可以发现当所有段均满足B样条曲线规定时，u的定义域仅为[uk-1,un+1]，这样的B样条曲线我们称之为open B样条曲线。可见，如果我们要画出一条open B样条曲线，还需要满足k-1&lt;n+1这一条件。</p><p>由此绘制的B样条曲线我们发现，它仍不符合贝塞尔曲线的部分性质，例如曲线的端点并不经过头尾的控制点，且曲线的首端切线方向和末端切线方向并不分别与第一第二，倒数第一第二的控制点组成的直线方向相同。这会导致控制上出现很多不方便的地方。故进一步，我们引入准均匀B样条曲线（clamped B样条）的概念，当一个B样条曲线的起点和终点（一般也就是0和1）呈现k次的重复度时，得到的B样条曲线即称为准均匀B样条曲线。准均匀B样条曲线兼具有B样条曲线和贝塞尔曲线的功能，即曲线的端点经过头尾的控制点，且曲线的首端切线方向和末端切线方向分别与第一第二，倒数第一第二的控制点组成的直线方向相同的同时，还能进行分段控制。准均匀B样条曲线是很常用的规划曲线。</p><p>B样条的导数：<br>先讲clamped B样条</p><p>既然B样条是贝塞尔曲线的扩展，那么必然要继承贝塞尔曲线一些优良的性质。贝塞尔曲线的导数还是贝塞尔， B样条的导数还是B样条。</p><p>接下来看推导公式：</p><p>因此，可知，B样条的导数还是B样条， 依然保留B样条的优良特性。</p><p>控制点减1，阶数减1，那么节点数目必然是减2. 对于clamped B样条，只要是去除第一个和最后一个节点就ok了，因此clamped B样条的求导还是clamped B样条，这个性质使其方便计算，应用广泛。</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路径规划算法学习</title>
      <link href="/2023/08/15/trajplan/"/>
      <url>/2023/08/15/trajplan/</url>
      
        <content type="html"><![CDATA[<p>路径规划：<br>蚁群算法：</p><p>信息素浓度函数是一个全局特征，它是之前的蚂蚁给当前蚂蚁的经验；启发函数是一个局部特征，它是当前蚂蚁在当前城市前往可前往城市最短距离的一个预计</p><p>其中Q是一只蚂蚁携带的信息素总量，Lk是第k只蚂蚁从城市i走到城市j的长度，于是信息素浓度函数就是蚂蚁在路径上释放信息素的浓度，表征了该蚂蚁对该路径长度的测定。</p><p>动态规划算法：<br>采用逆向寻优的思路，其基本思路是将路径分为若干个阶段，离起点或是终点距离相同的中间点为同一阶段。对于每一个阶段的每一个点，都找出该点前往下一个阶段的最优路径（指到达终点距离最近）；如此这般，当逆推到上一个阶段的任意点经过该点到达终点的局部最优路径必定是该点的最优路径+任意点到该点的距离，而上一阶段某一点到达该阶段的最优路径必然是上一阶这点到达该阶段任意点的这些局部最优路径的最小值，逆推回起点确定了每一阶段前往下一阶段的最优路径后，从起点沿最优路径顺推回终点即为全过程的最优路径，这是一个很典型的最优化原理方法，以下面这个问题为例：<br>阶段4：从D1到阶段5的最优路径是5，D2到阶段5的最优路径是2</p><p>阶段3：从C1到阶段5的最优路径是C1-&gt;P5=min{C1-&gt;D1-&gt;P5,C1-&gt;D2-&gt;P5}=8<br>从C2到阶段5的最优路径是C2-&gt;P5=min{C2-&gt;D1-&gt;P5,C2-&gt;D2-&gt;P5}=7<br>从C3到阶段5的最优路径是C3-&gt;P5=min{C3-&gt;D1-&gt;P5,C3-&gt;D2-&gt;P5}=12</p><p>阶段2：从B1到阶段5的最优路径是B1-&gt;P5=min{B1-&gt;C1-&gt;P5,B1-&gt;C2-&gt;P5,B1-&gt;C3-&gt;P5}=20<br>从B2到阶段5的最优路径是B2-&gt;P5=min{B2-&gt;C1-&gt;P5,B2-&gt;C2-&gt;P5,B2-&gt;C3-&gt;P5}=14<br>从B3到阶段5的最优路径是B3-&gt;P5=min{B3-&gt;C1-&gt;P5,B3-&gt;C2-&gt;P5,B3-&gt;C3-&gt;P5}=19</p><p>阶段1：从A1到阶段5的最优路径是A1-&gt;P5=min{A1-&gt;B1-&gt;P5,A1-&gt;B2-&gt;P5,A1-&gt;B3-&gt;P5}=19</p><p>纵观这一算法，我们发现动态规划算法本质涉及了三层循环，最外层是阶段的逆向循环，中间层是当前阶段下各点的遍历循环，最里层是当前点前往下一阶段的任意点的遍历循环。在最里层循环结束后，我们得到了当前点前往终点的局部最优路径；在中间层循环结束后，我们得到了当前阶段每个点前往终点的局部最优路径，这将为最外层的下一次循环（进入上一阶段寻找局部最优路径）提供指导；在最外层循环结束后，我们便得到了一条最优路径。动态规划算法是从局部最优推导全局最优的算法，不需要存储全局的大量信息，而只需要告知局部的一个最优解。<br>RRT算法：</p><p>所谓目标区域，一般是Xnew和Xgoal之间的距离小于StepSize时，此时直接将Xnew和Xgoal相连便可得到最后的路径。<br>启发技巧：为了加速随机过程，可以让生成随机点Xrand时以一个相对于其他点较大的概率生成终点(5%-10%)，这将有利于加速随机树向终点的生长过程。<br>RRT算法的优点是快，缺点是轨迹完全随机而仅仅为可行解，且有可能出现长时间迭代而找不到的情况，因而建议设置最大迭代次数避免浪费资源。</p><p>相比之下，RRT<em> 算法在RRT算法的基础上增加了两步：重写和随机重连。<br>RRT</em> 算法考虑每一个节点到出发点的距离，为此每一个节点会增加一个属性：到出发点的距离。相应地在每一个节点选择父节点的时候，新节点的距离等于父节点的距离加上父节点到子节点的距离。<br>重写就是在新节点Xnew加入到树种之后，重新为它选择父节点，好让它到起始点的路径长度（代价）更小。基本流程是：遍历整个树，获得到新节点Xnew的距离小于一定阈值（比如1.5倍的步长）的所有节点，将这些节点加入到一个列表中。<br>找到节点列表中具有最小距离的那个节点，将新节点Xnew的父节点设置为该节点。<br>随机重连就是在重写完成之后，对新节点Xnew附近一定范围内（可以与重写范围不同）的节点进行重连。重连就是，检查一下如果把Xnew附近的这些节点的父节点设置为Xnew，这些节点的代价会不会减小。如果能够减小，就把这些节点的父节点更改为Xnew；否则，就不更改。</p><p>RRT<em>算法得到的轨迹是一个渐进最优的轨迹，如果单次调用，则它整体比RRT算法得到的轨迹都要更优，而如果循环迭代多次，则RRT</em>算法将会得到一个趋近于最优的轨迹。</p><p>在RRT<em>算法的基础上，我们进一步引出Informed RRT</em>算法。<br>在RRT<em>算法中，对于Xnew的选取仍然是近似于全局随机的，然而事实上，如果我们得到了一条通路，那么Xnew的选取优化就理应位于这条通路附近，Informed RRT</em>算法提出：<br>当我们得出任意一条通路时，设Xstart与Xgoal的直线距离为Cmin，目前得到所有通路的长度最短值为Cbest，则可以将采样空间缩减为一个以Xstart与Xgoal为焦点，Cmin为焦距，Cbest为长径的椭圆（对于三维空间则为椭球），以此类推迭代。这么做相比RRT*算法可以大大减少迭代到渐进最优路径的时间。</p><p>遗传算法：模拟生物进化过程，适者生存</p><p>在轨迹优化问题中，生物个体就是每个不同的轨迹，我们通过一定的进化规则来找到在当前环境下最适合生存的个体（路径最短的轨迹）<br>由于轨迹从起点到终点必然经过方格的所有行和所有列，于是在轨迹初始化生成时要求每行都任选一个非障碍栅格，接下来判断相邻行的选中栅格之间是否连续（相邻或对角，对应栅格的x,y分量绝对值不大于1），不连续时则将选中栅格向下取平均插入新的栅格，如果该栅格为障碍栅格或已遍历栅格，则寻找其四周非障碍非已遍历栅格插入，如果无法找到则舍去此路径，重复这一过程直到轨迹连续，从而完成了一条轨迹的初始化。<br>多次进行轨迹生成，以此形成一个轨迹种群来进行遗传算法的循环。</p><p>轨迹规划：<br>人工势场法：</p><p>如此规定人工势场会带来两个问题：目标不可达和陷入局部最优。</p><p>为了解决这两个问题，我们可以改进斥力势场，让它在对障碍物表现斥力的同时额外还向目标点表现引力（似乎也不能完全解决问题？）</p><p>曲线插值法：<br>将轨迹规划为一条x,y分量均为与t相关的多项式曲线，则此时给出多项式与任意时刻，则在该时刻车的位置，速度，加速度和加加速度便被同时完全确定了。</p><p>对于位置、速度、加速度、加加速度的规划要求越高的，越是需要更高阶的多项式曲线。<br>位置多项式分横向和纵向两种情况，速度和加速度由位置多项式求导得来。</p><p>在给出了起点的初始时刻、位置、速度、加速度和加加速度，终点要求的到达时刻、位置、速度、加速度和加加速度后，矩阵X,Y和T便完全已知了，于是便可以求出系数矩阵A和B的值，则多项式完全可求，轨迹规划完毕。</p><p>贝塞尔曲线法：<br>在自然界的车辆系统而言，规划的轨迹应该满足：轨迹连续，轨迹曲率连续；轨迹容易被车辆跟随，且容易生成。</p><p>继续推广以得到一般形式：</p><p>对于n+1个控制点而言，将会形成一条n阶贝赛尔曲线。对于三阶贝塞尔曲线而言，我们将有能力对其进行速度规划（一阶导数不为常数），对于四阶贝塞尔曲线而言，我们将有能力对其进行加速度规划（二阶导数不为常数），对于五阶贝塞尔曲线而言，我们将有能力对其进行加加速度规划（三阶导数不为常数）。如果我们给定了起点的初始时刻、位置、速度、加速度和加加速度，终点要求的到达时刻、位置、速度、加速度和加加速度。我们便可以根据贝赛尔曲线方程及其导数反解出所有的控制点。</p><p>由上式不难看出，当t=0时，∑项仅有P1-P0不等于0，即∑=P1-P0；当t=1时，∑项仅有Pn-Pn-1不等于0，即∑=Pn-Pn-1；故贝塞尔曲线起点和终点的切线方向即为特征多边形第一条边与最后一条边的方向。</p><p>怎么计算贝塞尔曲线长度的近似解？取delta_t为间隔的贝赛尔曲线上的若干个点，将这些点之间的矢量模相加得到。</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim学习</title>
      <link href="/2023/08/12/vim/"/>
      <url>/2023/08/12/vim/</url>
      
        <content type="html"><![CDATA[<p>安装与配置vim<br>Vscode插件搜素vim</p><p>将settings下的内容拷贝赋值到settings.json中，首位可能要给个逗号</p><p>普通模式与插入模式的切换：</p><p>ESC：从插入模式返回普通模式<br>普通模式到可视模式：V，可视模式到普通模式：ESC，V<br>普通模式到命令模式：V，命令模式到普通模式：ESC</p><p>普通模式提供了除键入代码外几乎所有的基本功能，插入模式下可以键入代码，可视模式下可以快速而高自由度的框选代码，命令模式下可以使用命令对文件操作（例如:12是跳转文件到12行）</p><p>普通模式下的光标移动：h光标前移，l光标后移，j光标下移，k光标上移</p><p>普通模式动作：（光标要位于操作对象内部）</p><p>普通模式操作符：</p><p>p粘贴，u撤销，ctrl+R重做<br>dd删除整行，cc修改整行，xdd/cc删除/修改x行<br>P8还要再看看</p><p>Operator+Motion 操作符+动作<br>在框选时，U能将框选内容改大写，u能将框选内容改小写<br>gd转到函数定义，gh查看函数格式<br>gT往前选择文件，gt往后选择文件<br>切换光标分屏ctrl+n（目录为0）<br>easy motion：<leader><leader>+命令<br>vim-surround：</p><p>‘foo’-&gt;ds’-&gt;foo<br>‘foo’-&gt;cs’”-&gt;”foo”<br>foo-&gt;ysiw’-&gt;’foo’</p>]]></content>
      
      
      <categories>
          
          <category> 编译进化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32F4学习</title>
      <link href="/2023/08/10/stm32/"/>
      <url>/2023/08/10/stm32/</url>
      
        <content type="html"><![CDATA[<p>CAN<br>CAN 控制器根据两根线上的电位差来判断总线电平。总线电平分为显性电平和隐性电平，<br>二者必居其一。发送方通过使总线电平发生变化，将消息发送给接收方。<br>1） 多主控制。在总线空闲时，所有单元都可以发送消息（多主控制），而两个以上的单元<br>同时开始发送消息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是<br>表示发送的目的地址，而是表示访问总线的消息的优先级。两个以上的单元同时开始<br>发送消息时，优先级最高的单元才能继续发送消息。<br>CAN线物理架构：</p><p>CAN信号是一个差分信号，显性电平对应逻辑 0，CAN_H 和 CAN_L 之差为 2.5V 左右。而隐性电平对应逻辑 1，CAN_H 和 CAN_L 之差为 0V。只要有一个单元输出显性电平，总线上即为显性电平，而只有所有的单元都输出隐性电平，总线上才为隐性电平。<br>由CAN的这一特性，我们可以分析它的仲裁原理：<br>假设单元 1 和单元 2 同时开始向总线发送数据，开始部分他们的数据格式是一样的， 故无法区分优先级，直到 T 时刻，单元 1 输出隐性电平，而单元 2 输出显性电平，此时单元 1 仲裁失利，立刻转入接收状态工作，不再与单元 2 竞争，而单元 2 则顺利获得总线使用权，继续发送自己的数据。这就实现了仲裁，让连续发送显性电平多的单元获得总线使用权。<br>在 CAN 总线的起止端都有一个 120Ω的终端电阻，来做阻抗匹配，以减少回波反射。 </p><p>CAN 协议是通过以下 5 种类型的帧进行的：数据帧，遥控帧，错误帧，过载帧，间隔帧<br>我们只介绍数据帧，数据帧用于发送单元向接收单元传送数据<br>数据帧一般由 7 个段构成，即：<br>1） 帧起始。表示数据帧开始的段，由 1 个位的显性电平表示。<br>2） 仲裁段。表示该帧优先级的段，标准格式的 ID 有 11 个位，扩展格式的 ID 有 29 个位。标准帧与扩展帧由标志位IDE决定（0使用标准标识符；1使用扩展标识符），是否是数据帧由RTR标志位决定（0为数据帧）。<br>3） 控制段。表示数据的字节数的段，DLC标志位的值表示了数据长度（0~8）<br>4） 数据段。数据的内容，一帧可发送 0~8 个字节的数据。<br>5） CRC 段。检查帧的传输错误的段，由 15 个位的 CRC 顺序和 1 个位的 CRC 界定符（用于分隔的位）组成。<br>6） ACK 段。表示确认正常接收的段。<br>7） 帧结束。表示数据帧结束的段，由 7 个位的隐性位组成。</p><p>由发送单元发送的每秒钟的位数称为位速率。<br>STM32F4 的 CAN 一个位只有 3 段：同步段（SYNC_SEG）、时间段 1（BS1）<br>和时间段 2（BS2）。<br>CAN波特率公式为：CAN_BaudRate=42M/(CAN_SJW+CAN_BS1+CAN_BS2)/CAN_Prescaler其中CAN_SJW，CAN_BS1，CAN_BS2为设置的位时间，CAN_Prescaler为分频系数。因此，我们只需要知道 BS1 和 BS2 的设置，以及 APB1 的时钟频率（一般为 42Mhz），就可以方便的计算出波特率。</p><p>STM32F4 的 CAN 的主要特点有：<br> 具有 3 个发送邮箱<br> 具有 3 级深度的 2 个接收 FIFO<br> 可变的过滤器组（28 个，CAN1 和 CAN2 共享）。每个滤波器组 x 由 2 个 32 位寄存器， CAN_FxR1 和 CAN_FxR2 组成。 通过 CAN_FMR 寄存器的设置，可以设置滤波器的分配方式。 </p><p>CAN 发送流程为：程序选择 1 个空置的邮箱（TME=1）设置标识符（ID），数据长度和 发送数据设置 CAN_TIxR 的 TXRQ 位为 1，请求发送邮箱挂号（等待成为最高优先级）预定发送（等待总线空闲）发送邮箱空置。<br>CAN 接收流程为：FIFO 空收到有效报文挂号_1（存入 FIFO 的一个邮箱，这个由硬件 控制，我们不需要理会）收到有效报文挂号_2收到有效报文挂号_3收到有效报文溢出</p><p>STM32F4 提供了一种叫环回模式的测试模式，在环回模式下，bxCAN 把发送的报文当作接收的报文并保存(如果可以通过接收过滤)在接收邮箱里。</p><p>CAN 的初始化配置步骤：<br>1）配置相关引脚的复用功能（AF9），使能 CAN 时钟。<br>CAN1：<br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);<br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);</p><p>GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_CAN1);<br>GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_CAN1);</p><p>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br>CAN2：<br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);<br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE);</p><p>GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_CAN2);<br>GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_CAN2);</p><p>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6;<br>GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</p><p>任务<br>所谓的任务，其实就是一个死循环函数，该函数实现一定的功能，一个工程可以有很多这<br>样的任务（最多 255 个），UCOSII 对这些任务进行调度管理，让这些任务可以并发工作，这就是 UCOSII 最基本的功能。Ucos 任务的一般格式为：<br>void MyTask (void *pdata)<br>{<br>任务准备工作… （只执行一次）<br>While(1)//死循环<br>{<br>任务 MyTask 实体代码;<br>OSTimeDly(t);//调用任务延时函数，释放 cpu 控制权，<br>}<br>}<br>假如我们新建了2个任务为A和B，两个任务死循环中延时时间为1s。如果某个时刻，任务A在执行中，当它执行到延时函数OSTimeDly的时候，它释放cpu控制权，这个时候，任务B获得cpu控制权开始执行，任务B执行过程中，也会调用延时函数延时1s释放 CPU 控制权，这个过程中任务A延时1s到达，重新获得CPU控制权，重新开始执行死循环中的任务实体代码。如此循环，现象就是两个任务交替运行，就好像CPU在同时做两件事情一样。<br>任务优先级：ucos 中，每个任务都有唯一的一个优先级。优先级是任务的唯一标识。在 UCOSII 中，使用 CPU 的时候，优先级高（数值小）的任务比优先级低的任务具有优先使用权，即任务就绪表中总是优先级最高的任务获得 CPU 使用权，只有高优先级的任务让出 CPU 使用权（比如延时）时，低优先级的任务才能获得 CPU 使用权。</p><p>1） 建立任务函数<br>如果想让 UCOSII 管理用户的任务，必须先建立任务。UCOSII 提供了我们 2 个建立任<br>务的函数：OSTaskCreate 和 OSTaskCreateExt，我们一般用 OSTaskCreat 函数来创建任务，<br>该函数原型为：<br>OSTaskCreate(void(<em>task)(void</em>pd),void<em>pdata,OS_STK</em>ptos,INTU prio)。<br>该函数包括 4 个参数：task：是指向任务代码的指针；pdata：是任务开始执行时，传<br>递给任务的参数的指针；ptos：是分配给任务的堆栈的栈顶指针；prio 是分配给任务的优<br>先级。<br>每个任务都有自己的堆栈，堆栈必须申明为 OS_STK 类型，并且由连续的内存空间组<br>成。可以静态分配堆栈空间，也可以动态分配堆栈空间。<br>OSTaskCreateExt 也可以用来创建任务，是 OSTaskCreate 的扩展版本，提供一些附件<br>功能。详细介绍请参考《嵌入式实时操作系统 UCOSII 原理及应用》3.5.2 节。<br>2） 任务删除函数<br>所谓的任务删除，其实就是把任务置于睡眠状态，并不是把任务代码给删除了。UCOSII<br>提供的任务删除函数原型为：<br>INT8U OSTaskDel(INT8U prio)；<br>其中参数 prio 就是我们要删除的任务的优先级，可见该函数是通过任务优先级来实现<br>任务删除的。<br>特别注意：任务不能随便删除，必须在确保被删除任务的资源被释放的前提下才能删<br>除！<br>3） 请求任务删除函数<br>前面提到，必须确保被删除任务的资源被释放的前提下才能将其删除，所以我们通过<br>向被删除任务发送删除请求，来实现任务释放自身占用资源后再删除。UCOSII 提供的请<br>求删除任务函数原型为：<br>INT8U OSTaskDelReq(INT8U prio)；<br>同样还是通过优先级来确定被请求删除任务。<br>4） 改变任务的优先级函数<br>UCOSII 在建立任务时，会分配给任务一个优先级，但是这个优先级并不是一成不变的，<br>而是可以通过调用 UCOSII 提供的函数修改。UCOSII 提供的任务优先级修改函数原型为：<br>INT8U OSTaskChangePrio(INT8U oldprio,INT8U newprio)；<br>5） 任务挂起函数<br>任务挂起和任务删除有点类似，但是又有区别，任务挂起只是将被挂起任务的就绪标<br>志删除，并做任务挂起记录，并没有将任务控制块任务控制块链表里面删除，也不需要释<br>放其资源，而任务删除则必须先释放被删除任务的资源，并将被删除任务的任务控制块也<br>给删了。被挂起的任务，在恢复（解挂）后可以继续运行。UCOSII 提供的任务挂起函数<br>原型为：<br>INT8U OSTaskSuspend(INT8U prio)；<br>6） 任务恢复函数<br>有任务挂起函数，就有任务恢复函数，通过该函数将被挂起的任务恢复，让调度器能<br>够重新调度该函数。UCOSII 提供的任务恢复函数原型为：<br>INT8U OSTaskResume(INT8U prio)；<br>7） 任务信息查询<br>在应用程序中我们经常要了解任务信息，查询任务信息函数原型为：<br>INT8U OSTaskQuery(INT8U prio,OS_TCB *pdata);<br>这个函数获得的是对应任务的 OS_TCB 中内容的拷贝。<br>从上面这些函数我们可以看出，对于每个任务，有一个非常关键的参数就是任务优先级 prio,在<br>UCOS 中，任务优先级可以用来作为任务的唯一标识，所以任务优先级对任务而言是唯一的，<br>而且是不可重复的。</p><p>typedef struct<br>{<br>INT8U OSEventType; //事件的类型<br>INT16U OSEventCnt; //信号量计数器（重要）<br>void *OSEventPtr; //消息或消息队列的指针<br>INT8U OSEventGrp; //等待事件的任务组<br>INT8U OSEventTbl[OS_EVENT_TBL_SIZE];//任务等待表 </p><h1 id="if-OS-EVENT-NAME-EN-gt-0u"><a href="#if-OS-EVENT-NAME-EN-gt-0u" class="headerlink" title="if OS_EVENT_NAME_EN &gt; 0u"></a>if OS_EVENT_NAME_EN &gt; 0u</h1><p>INT8U *OSEventName; //事件名 </p><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p>} OS_EVENT;</p><p>信号量<br>信号量是一类事件。使用信号量的最初目的，是为了给共享资源设立一个标志，该标志表<br>示该共享资源的占用情况。这样，当一个任务在访问共享资源之前，就可以先对这个标志进行查询，从而在了解资源被占用的情况之后，再来决定自己的行为。<br>信号量可以分为两种：一种是二值型信号量，另外一种是 N 值信号量。<br>二值型信号量好比家里的座机，任何时候，只能有一个人占用。而 N 值信号量，则好比公<br>共电话亭，可以同时有多个人（N 个）使用。<br>可以把信号量看作是一个公共资源可以同时占用的任务总数，每当有一个任务请求使用一个公共资源，就调用OSSemPend把该信号量减一，而使用完成后就调用OSSemPost 把该信号量加一（当然，如果还有等待的任务则不改变信号量而直接将资源转向该任务即可）</p><p>1） 创建信号量函数<br>在使用信号量之前，我们必须用函数 OSSemCreate 来创建一个信号量：<br>OS_EVENT <em>OSSemCreate (INT16U cnt);<br>该函数返回值为已创建信号量的OS_EVENT类指针，而参数 cnt 则是信号量计数器的初始值。<br>2） 请求信号量函数<br>任务通过调用函数 OSSemPend 请求信号量，该函数原型如下：<br>void OSSemPend ( OS_EVENT </em>pevent, INT16U timeout, INT8U *err);<br>其中，参数 pevent 是被请求信号量的指针，timeout 为等待时限，err 为错误信息。<br>为防止任务因得不到信号量而处于长期的等待状态，函数 OSSemPend 允许用参数<br>timeout 设置一个等待时间的限制，当任务等待的时间超过 timeout 时可以结束等待状态而<br>进入就绪状态。如果参数 timeout 被设置为 0，则表明任务的等待时间为无限长。<br>当任务需要访问一个共享资源时，先要请求管理该资源的信号量，这样就可以根据信号量当前是否有效（即信号量的计数器 OSEventCnt 的值是否大于0）来决定该任务是否可以继续运行。<br>如果信号量有效（即信号量的计数器 OSEventCnt 的值大于0)，则把信号量计数器减1，然后继续运行任务。<br>如果信号量无效（即信号量的计数器 OSEventCnt 的值等于0)，则会在等待任务表中把该任务对应的位置1而让任务处于等待状态，并把等待时限 timeout 保存在任务控制块 TCB 的成员 OSTCBDly 中。</p><p>3） 发送信号量函数<br>任务获得信号量，并在访问共享资源结束以后，必须要释放信号量，释放信号量也叫<br>做发送信号量，发送信号通过 OSSemPost 函数实现 。OSSemPost 函数在对信号量的计数<br>器操作之前，首先要检查是否还有等待该信号量的任务。如果没有，就把信号量计数器<br>OSEventCnt 加一；如果有，则调用调度器去运行等待任务中优先级别最高的任务。函数 OSSemPost 的原型为：<br>INT8U OSSemPost(OS_EVENT <em>pevent);<br>其中，pevent 为信号量指针。<br>4） 删除信号量函数<br>应用程序如果不需要某个信号量了，那么可以调用函数 OSSemDel 来删除该信号量：OS_EVENT </em>OSSemDel (OS_EVENT <em>pevent,INT8U opt, INT8U </em>err);<br>其中，pevent 为要删除的信号量指针，opt 为删除条件选项，err 为错误信息。 </p><p>论cnt的0与1：当 pend请求发出的时候信号量的值减1，当post的时候信号量的值加1，信号量的值0跟1分别是用来同步跟互斥的，什么是同步，什么是互斥呢。。。假设你把信号量的值设为0，有A,B连个任务，当A发出pend请求的时候它发现此事的信号量值为0就把它减1然后挂起等待，等待到什么时候呢？等待任务B执行post操作把信号量的值加1然后唤醒进程A，然后两个进程同步并发执行。通俗点解释就是任务A执行到某个地方的时候先停下来睡觉，等待任务B来叫醒它，然后两个任务一起并发运行，也就是几乎同时从那个点开始运行哈。<br>假设信号量的值是1，就是用来互斥的，A,B两个任务只能其中一个任务pend执行成功返回，此时信号量的值是0，另一个在pend请求的时候就必须把自己挂起等待刚刚那个请求成功的任务执行post操作才能唤醒继续执行。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git联合创作</title>
      <link href="/2023/08/09/git/"/>
      <url>/2023/08/09/git/</url>
      
        <content type="html"><![CDATA[<p>Vscode中下载适用于windows的git，同时加入Gitlens工具包<br>安装时注意在这个界面选择使用visual studio code，其他全点next就可以</p><p>在cmd中键入git验证是否安装</p><p>Git配置完成后显示如此</p><p>第一次时选择初始化仓库而后显示如此</p><p>.gitignore选择git要忽略的文件（一般是.vscode和build）</p><p>终端加入git bash</p><p>配置username和useremail键入命令：<br>设置用户名和邮箱<br>git config —global user.name “username”<br>git config —global user.email  useremail@qq.com<br>查看是否设置成功<br>git config user.name<br>git config user.email<br>查看全局配置<br>git config —global -l </p><p>在设置里去掉勾选use Editor As commit input</p><p>由此我们便完成了vscode+github的基本配置，之后对同一文件不需再次配置</p><p>接下来我们学习git的提交与发布（推送）<br>这是两个不同的步骤，提交是将程序文件保存到本地仓库，发布则是将程序文件发送到云端（也就是github上），具体地：</p><p>点击√后提示“请提供提交信息”，键入分支名（一般为master）</p><p>如此便得到了一个本地的master分支，然后就是把他发布到github上，点击发布branch</p><p>期间抛出的所有token全部点击是<br>成功后vscode会自动捕捉我们在github上的库</p><p>我们既可以直接键入名称，这样就会在github上自动创建一个该名称的分支。<br>也可以搜索已经在github上创建好的分支来保存它，补充介绍下如何在github上创建分支。<br>我们在自己的github上首页建一个新的库保存它，点击new</p><p>键入名称，描述以及是否公开</p><p>点击确定后就得到了一个空的github库</p><p>回到正题，我们选定好github的远程库后便可以点击发布branch将其上传到github<br>初次上传时vscode需要登录github，依次在弹出的token中点击sign in-&gt;authorize-&gt;confirm</p><p>完成后vscode弹出提示，发布完成。</p><p>之后每次修改程序，提交按钮都会再次高亮，同时显示修改了的（也就是要上传的）文件</p><p>我们只需要点击提交，然后同步更改即可完成覆写</p><p>在存在一个主分支(master)的情况下，还可以上传若干个其他分支</p><p>点击左下角的分支名，在上方弹出框中选择创建新分支，已创建的分支会显示在下方<br>分支创建成功后，右边的git又显示为“√提交”，则此时按照上面介绍的正常步骤便可以在主分支下创建一个新的分支。</p><p>由于github通常需要翻墙而且不太稳定，因而上传可能失败，记得检查网络配置<br>不行的话可以重启clash</p><p>常见警告/报错token：</p><p>直接点击始终就可以，之后不会再弹出</p><p>直接点击don’t show again就可以，之后不会再弹出</p><p>最简单粗暴的是关闭代理再打开就可以！更多方法参见附录</p><p>git命令集</p><ol><li>git clone <a href="https://……">https://……</a> 下载</li><li>git push 上传</li><li>git remote add origin <a href="https://……">https://……</a>. 添加远程仓库</li><li>git init 初始化本地仓库</li><li>git config —global https.proxy <a href="http://127.0.0.1:7890">http://127.0.0.1:7890</a> 添加远程端口 </li></ol><p>有时候出现连接不上网络的情况时使用该方法，需要在电脑设置上打开手动代理，http:// 后面的是代理ip地址和端口，仅限在挂梯子之后打开手动代理，否则会出现网络连接不上的问题</p><ol><li>git config —global http.proxy <a href="http://127.0.0.1:7890">http://127.0.0.1:7890</a> 添加远程端口</li><li>git config —global —list 配置信息列表</li><li>git config —global user.name name 配置名称</li><li>git config —global user.name email 配置邮件</li><li>git commit -m “initial commit” 提交初始仓库</li></ol><p>附录：<br>参考视频<a href="https://www.bilibili.com/video/BV1dK411p7RF">https://www.bilibili.com/video/BV1dK411p7RF</a><br>Git for Windows下载：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>Github官网：<a href="https://github.com">https://github.com</a><br>解决unable to access…的一些方法：<br><a href="https://blog.csdn.net/qq_39808156/article/details/117510950">https://blog.csdn.net/qq_39808156/article/details/117510950</a><br><a href="https://blog.csdn.net/risroy/article/details/128887648">https://blog.csdn.net/risroy/article/details/128887648</a><br><a href="https://blog.csdn.net/qq_40520596/article/details/108479892">https://blog.csdn.net/qq_40520596/article/details/108479892</a></p>]]></content>
      
      
      <categories>
          
          <category> 编译进化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VisualTFT学习</title>
      <link href="/2023/08/06/tft/"/>
      <url>/2023/08/06/tft/</url>
      
        <content type="html"><![CDATA[<p>概述：VisualTFT是一个串口屏软件，在串口屏上的每个操作均会被作为串口信息发送到串口。</p><p>基本信息格式：<br>帧头：EE<br>画面指令/组态控件指令：B1 01/B1 11<br>画面ID：四位十六进制表示，例如00 0A<br>控件ID：在同一画面上的不同控件，四位十六进制表示，例如00 01<br>控件类型：两位十六进制表示，例如按钮控件是10，文本控件是11</p><p>帧尾：FF FC FF FF</p><p>文本控件：<br>基本功能：<br>密码显示：开启后输入文本将以“<em>”显示，例如输入“123”，将显示“**</em>”。<br>输入方式：<br>“用户主机输入”——文本由用户的主机输入，通过串口指令传出到串口屏，把文本显示<br>到屏幕。 stm32的命令为lcd_text_update。<br>“弹出系统键盘输入”——弹出系统键盘进行文本输入，键盘类型可选择小键盘和全键盘。 小键盘可以输入数字；全键盘可以输入数字、英文字母、中文。<br>文本长度：文本输入的长度，指令的最大长度为 1024 字节(包含帧头和帧尾)，一个<br>汉字占用两个字节。<br>数值限定：弹出系统键盘输入方式下可对输入的数值进行限定，限定输入数值的范<br>围和精度。<br>键入值与串口指令的关系：</p><p>按钮控件：<br>根据按钮的触控用途可分为五种：切换画面、开关描述、自定义按键、自定义指令、弹<br>出菜单。刚放置的按钮默认状态为开关描述。<br>基本功能：<br>触控用途：要实现按钮控件不同的功能可以进行切换。<br>初始状态：设置按钮初始为弹起或按下状态。<br>触控的操作风格：<br>瞬变：按下后，开关自动弹起，类似轻触开关功能。<br>开关：按下后，开关由弹起变成按下或由按下变成弹起，类似带锁开关功能。<br>置位：开关只能由弹起变成按下。<br>复位：开关只能由按下变成弹起。<br>长按：与瞬变按钮相似，但按压时每隔 100 毫秒通知一次。<br>对内指令：是按钮按下或者弹起后，对内部执行的指令。<br>对外指令：是按钮按下或者弹起后，对外发送的指令，命令任意编制，但是不能含<br>有“FF FC FF FF”，或者会与常规指令冲突，可以设置间隔时间。<br>不同用途详解：<br>切换画面：按下按钮切换到指定的画面，具体的画面可以指定。<br>开关描述：即把按钮作为一个按下或弹起的开关功能。设置按下时的对内指令——在按钮属性窗口中，鼠标左键点击图 4-10 标示区域，会弹出“…”的展开标志，展开后可对指令进行输入、添加、删除、确定操作。从指令助手中调出指令复制到图 4-12 的输入框中，输入指令如图 4-12 所示，添加完后点击确认。<br>自定义指令：即为用户设置按下某个按钮后，设备上传自定义的数据串列，比如用户设<br>置按下“自定义指令”按钮后，屏幕要发送指令： FF 01 AA FF。此时按下时对外指令→“FF 01 AA FF”。<br>注：自定义指令中不能包含 FF FC FF FF 组合字符，否则会与常规指令冲突。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 上位机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidworks学习</title>
      <link href="/2023/08/02/SolidWorks/"/>
      <url>/2023/08/02/SolidWorks/</url>
      
        <content type="html"><![CDATA[<p>Alt+C 切换实虚线<br>Space 快速转换视图<br>鼠标中键 调整视角<br>鼠标右键 鼠标笔势</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidworks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习</title>
      <link href="/2023/07/24/C++/"/>
      <url>/2023/07/24/C++/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习</title>
      <link href="/2023/07/17/DesignMode/"/>
      <url>/2023/07/17/DesignMode/</url>
      
        <content type="html"><![CDATA[<p>如何解决一个复杂的问题：分解、抽象。<br>分解是将大问题变为小问题；抽象是将问题的共同点提炼出来，而后对不同点做不同处理。<br>抽象比分解更好<br>软件设计的目的是复用</p><h1 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1.设计原则"></a>1.设计原则</h1><p>高层模块（稳定）不能依赖于底层模块（变化），二者应该依赖于抽象（稳定）<br>抽象（稳定）不应该依赖于实现细节（变化），实现细节（变化）应该依赖于抽象（稳定）<br>对扩展开放，对修改封闭<br>一个类应该仅有一个引起它变化的原因，单一职责<br>接口应该小而完备，该private就private，不能随便public<br>优先使用对象组合，而不是类继承<br>面向接口（对象要声明成抽象基类），高内聚，松耦合。<br>稳定存在于编译时，变化存在于运行时，用虚函数将编译时依赖延迟到运行时依赖<br>变化无法消除，关键在于让变化只存在于代码的某个集中区域而不是充斥在整个代码空间</p><p>GOF-23分类：创建型、结构型、行为型<br>组件协作模式：模板方法、策略模式、观察者模式<br>单一职责模式：装饰模式、桥模式<br>对象创建模式：工厂方法模式</p><h1 id="2-模板方法-Template-Method-："><a href="#2-模板方法-Template-Method-：" class="headerlink" title="2.模板方法(Template Method)："></a>2.模板方法(Template Method)：</h1><p>晚绑定与松耦合<br>晚绑定：早的东西调用晚的东西，先定义一个算法的骨架，而将步骤实现延迟到子类中</p><p>让子类变化基类的函数，使子类复用一个稳定算法结构而重写其中的特定步骤<br>程序必须有一个稳定的算法骨架才能使用模板方法</p><h1 id="3-策略模式-Strategy-："><a href="#3-策略模式-Strategy-：" class="headerlink" title="3.策略模式(Strategy)："></a>3.策略模式(Strategy)：</h1><p>以扩展的方式支持未来的变化，降低代码的冗余<br>使用基类与子类的关系扩展代码，保证调用段的稳定（多态调用）<br>用于重构switch-case和if-else代码（从分解进化为抽象）<br>对于绝对不变的系统，可以使用switch-case和if-else，否则就推荐重构为策略模式</p><p>观察者模式/事件模式(Observer/Event)：以一个抽象通知机制影响多个观察者<br>定义对象间的一对多依赖关系，称一为目标，多为观察者。<br>当目标的状态发生改变时，无需指定观察者，通知就会自动传播，所有依赖于目标的观察者都会得到通知并由观察者自身决定是否需要订阅通知以产生更新，而目标对此一无所知。<br>不推荐多继承，要使用多继承应当为一个主基类和多个接口的形式<br>很适合用于UI事件的构造</p><p>下例中目标为已传输文件的数目，观察者分别为进度条显示和字符“.”显示。<br>如果不使用观察者模式，每次用户提出新的显示需求我们都需要更改高层模块新增具体通知控件，不符合设计原则。定义进度接口IProgress内含虚函数DoProgress以供不同的显示方式复用，定义观察者列表m_iprogressList以支持多个观察者。当已传输文件的数目value变化时，遍历观察者列表，通过调用OnProgress函数将这个变化通知利用各观察者的DoProgress传播到所有需要的观察者中并作出相应的显示更新。DoProgress在各显示方法对应的类中实现。</p><h1 id="4-装饰模式-Decorator-："><a href="#4-装饰模式-Decorator-：" class="headerlink" title="4.装饰模式(Decorator)："></a>4.装饰模式(Decorator)：</h1><p>附着在其他基本功能类之上扩展功能类。如果对每个基本功能类都各自去产生继承的扩展功能类，会产生大量的冗余代码。正确做法是将各个扩展功能独自成为扩展功能类，而在有需求时去对其他基本功能类进行装饰，体现单一职责原则。<br>程序中存在大量可以去除的重复代码<br>当一个变量的声明类型都是某个类型的子类时，把该变量直接声明成该类型即可<br>用编译时装配替代运行时装配<br>明辨类何时应该继承，当各类属于一个变化方向时才应该使用继承</p><p>下例中，为了实现对不同流(File文件流，Net网络流，Memory内存流)的不同操作(无操作，Crypto加密操作，Buffered缓冲操作，CryptoBuffered缓冲加密操作)，一般方法是对基本功能类做原类的继承，再把扩展功能类做基本功能类的继承，这种继承模式实际上是对继承的过度调用，将各操作继承于各流，两者不属于一个变化方向，这么做很容易使问题规模无限扩大。装饰模式指出应该将基本功能类和扩展功能类分开继承，定义n个基本功能类，m个扩展功能类继承自装饰模式类，而后装饰模式类和基本功能类共同继承自原类，故总共只需要m+n+2个类，使问题规模大大降低。这种模式的结构是相对固定的，因为扩展功能类的传入对象必然是各基本功能类，因而两者必然继承自同一原类。</p><h1 id="5-桥模式-Bridge-："><a href="#5-桥模式-Bridge-：" class="headerlink" title="5.桥模式(Bridge)："></a>5.桥模式(Bridge)：</h1><p>应对多维度的变化。它与装饰模式类似，区别在于它具有多个变化维度，需要用多个稳定原类，使得各变化可以沿着他们各自的维度去变化。</p><p>下例为一个消息传输程序，它既有PC端和手机端的分别需求，又有精简版Lite和完全版Perfect的分别需求，其中PC端和手机端的PlaySound,DrawShape,WriteText,Connect函数不同，而完全版Perfect在精简版Lite的Login,SendMessage,SendPicture基础上添加了PlaySound。对比装饰模式，可以看到Messager和MessagerImp之间没有明显的基本与扩展关系，两者是不同维度的并行变化关系，此时就要使用桥模式。PCMessagerImp和MobileMessagerImp实现MessagerImp，MessagerLite和MessagerPerfect实现Messager，实现桥构造。</p><p>运行端以PC为例：</p><h1 id="6-工厂方法-Factory-Method-："><a href="#6-工厂方法-Factory-Method-：" class="headerlink" title="6.工厂方法(Factory Method)："></a>6.工厂方法(Factory Method)：</h1><p>通过一种对象创建的模式来绕开堆创建new和栈创建所带来的紧耦合（依赖具体类），从而支持对象创建的稳定，同时满足将对象创建的变化集中在某个区域的效果。<br>我们先来看看常见的对象创建方法：</p><p>以上两个创建方法分别为堆创建和栈创建，可以看到他们都依赖于了具体的类，是不稳定的创建方法，而这两个创建方法又是一般程序语言所自然提供的。如果要绕开这种创建带来的紧耦合，一个有效的创建模式就是工厂方法。<br>工厂方法的基本原理是用一个创建方法来返回一个创建对象，它定义了一个用于创建对象的接口，让子类决定实例化哪一个类，使得一个类的实例化延迟到子类。<br>以下面一个文件分割器的例子来讲解，我们对于不同的文件类型需要有不同的文件分割器：<br>从策略模式我们知道，对于这种情况我们首先要用抽象类的多态实现来代替switch-case，ISplitter接口与其下BinarySplitter,TxtSplitter,PictureSplitter,VideoSplitter就用来实现策略模式。<br>但是这会带来一个问题，我们在使用的时候如何告诉代码我们用的是哪种策略，如果在MainForm直接创建一个特定的new对象，这必然导致了代码的紧耦合。为了解决这个问题，我们首先定义了工厂基类SplitterFactory，其下定义了创建对象的虚函数CreateSplitter，而后用具体的工厂BinarySplitterFactory,TxtSplitterFactory,PictureSplitterFactory,VideoSplitterFactory来实现具体的创建（返回一个对应的创建对象return new），这本质上也是对SplitterFactory的策略化。经过这样子处理后，我们在MainForm里创建Splitter对象时就可以使用factory-&gt;CreateSplitter()的方法了，而factory具体是什么工厂则由外部传入，体现了变化被压缩到局部并延迟实现的思路，MainForm内部不再存在依赖于具体类的new方法。<br>ISplitter* Splitter=factory-&gt;CreateSplitter()和Splitter-&gt;split()均为不依赖细节的多态调用。<br>工厂方法的局限性在于不同工厂的创建方法（参数表，返回形式）必须相同。</p><h1 id="7-抽象工厂-Abstract-Factory-："><a href="#7-抽象工厂-Abstract-Factory-：" class="headerlink" title="7.抽象工厂(Abstract Factory)："></a>7.抽象工厂(Abstract Factory)：</h1><p>用于应对一系列相互依赖的对象的创建工作，如果各对象之间不存在相互依赖的情况，则抽象工厂与普通的工厂方法无异，换句话说，工厂方法是抽象工厂在对象互不依赖时的特例。<br>以下面这个数据库操作的模型为例：<br>我们访问一个数据库有很多方法，这里列举了三种Connection,Command和DataReader，<br>在使用这些方法时是通过创建相应的对象后调用其下的成员函数实现的。<br>同时，我们针对不同的数据库时，上述的三种方法又有些许差距，例如SqlServer和Oracle<br>同理，我们首先根据策略模式对Connection,Command和DataReader进行接口的多态化<br>此时若按照一般的工厂方法，接下来就是对具体是创建SqlServer还是Oracle来定义工厂，<br>而不论是针对SqlServer还是Oracle，我们都需要创建三个对象Connection,Command和DataReader来调用他们的成员方法，相比于工厂方法中只需要创建一个分割器splitter复杂不少，此时我们如果将IDBConnection,IDBCommand和IDBDataReader各自定义一个对应的工厂IDBConnectionFactory,IDBCommandFactory和IDBDataReaderFactory会带来一个问题，由于Connection,Command和DataReader操作在同一时间调用时必然需要在同一数据库环境下，故此时会带来传入的不稳定性，因此我们应该把IDBConnectionFactory,IDBCommandFactory和IDBDataReaderFactory统一在一个工厂中IDBFactory，这样做我们对IDBFactory只能同时传入SqlDBFactory和OracleDBFactory之一，保证了对象之间的相互依赖关系。</p><p>//这里有误，SqlDBFactory应当是对IDBFactory各虚函数的实例化过程</p><p>//Oracle部分略去<br>//这里的dbFactory具体取何值仍由外部传入，构造函数略</p>]]></content>
      
      
      <categories>
          
          <category> 编译进化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32F4外设学习</title>
      <link href="/2023/07/09/peripheral/"/>
      <url>/2023/07/09/peripheral/</url>
      
        <content type="html"><![CDATA[<h1 id="定时器："><a href="#定时器：" class="headerlink" title="定时器："></a>定时器：</h1><p>0.结构体：TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    成员变量：<br>uint16_t TIM_Prescaler;<br>uint16_t TIM_CounterMode;<br>uint16_t TIM_Period;<br>uint16_t TIM_ClockDivision;<br>uint8_t TIM_RepetitionCounter;  针对高级定时器<br>1.时钟使能：定时器挂载在总线之下，所以我们通过对应总线的使能函数来使能定时器<br>例：RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);  APB1与TIM3可变<br>2.初始化结构体<br>TIM_TimeBaseInitStructure.TIM_Period = arr;    自动重载计数周期值<br>TIM_TimeBaseInitStructure.TIM_Prescaler=psc;  分频系数<br>TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; 计数方式<br>TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; 时钟分频因子<br>TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<br>3.开启定时器（大部分外设功能都要在使能后开启才能使用）<br>TIM_Cmd(TIM3,ENABLE);  TIM3可变</p><h1 id="GPIO端口："><a href="#GPIO端口：" class="headerlink" title="GPIO端口："></a>GPIO端口：</h1><p>0.结构体：GPIO_InitTypeDef GPIO_InitStructure;<br>成员变量：<br>uint32_t GPIO_Pin; 对应的PIN脚（GPIO而非GPIOx）<br>GPIOMode_TypeDef GPIO_Mode; 输出模式、输入模式、复用模式<br>GPIOSpeed_TypeDef GPIO_Speed; 传输速度<br>GPIOOType_TypeDef GPIO_OType;  推挽开漏<br>GPIOPuPd_TypeDef GPIO_PuPd; 上拉电阻，下拉电阻，不设置<br>1.时钟使能：<br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);  AHB1和GPIOA可变<br>2.初始化结构体<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 同时设置用|符号<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT/IN/AF;<br>GPIO_InitStructure.GPIO_OType = GPIO_OType_PP/OD;<br>GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL/UP/DOWN;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</p><h1 id="CAN通信："><a href="#CAN通信：" class="headerlink" title="CAN通信："></a>CAN通信：</h1><p>0.准备：由于CAN通信是对GPIO引脚的复用，所以需要调用对应的GPIO结构<br>GPIO_InitTypeDef GPIO_InitStructure; </p><p>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);  </p><p>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11| GPIO_Pin_12; 查复用表<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; 设为复用<br>GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<br>GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;</p><p>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br>1.复用对应：<br>GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_CAN1);<br>GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_CAN1);<br>2.使能CAN：<br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);<br>3.CAN初始化：<br>CAN_InitTypeDef CAN_InitStructure;</p><p>CAN_InitStructure.CAN_TTCM=DISABLE;<br>CAN_InitStructure.CAN_ABOM=DISABLE;<br>CAN_InitStructure.CAN_AWUM=DISABLE;<br>CAN_InitStructure.CAN_NART=ENABLE;<br>CAN_InitStructure.CAN_RFLM=DISABLE;<br>CAN_InitStructure.CAN_TXFP=DISABLE;</p><p>CAN_InitStructure.CAN_Mode= mode;<br>CAN_InitStructure.CAN_SJW=tsjw;<br>CAN_InitStructure.CAN_BS1=tbs1;<br>CAN_InitStructure.CAN_BS2=tbs2;<br>CAN_InitStructure.CAN_Prescaler=brp;<br>波特率计算：波特率=时钟频率（通常选APB1，即42MHz）/[(tsjw+tbs1+tbs2)*brp]</p><p>CAN_Init(CAN1, &amp;CAN_InitStructure);<br>4.滤波器初始化：<br>CAN_FilterInitTypeDef CAN_FilterInitStructure;</p><p>CAN_FilterInitStructure.CAN_FilterNumber=0; 过滤器名称<br>CAN_FilterInitStructure.CAN_FilterMode=CAN_FilterMode_IdList/Idmask; 列表/掩码<br>CAN_FilterInitStructure.CAN_FilterScale=CAN_FilterScale_32bit;<br>大小：标准帧16bit/32bit均可，扩展帧必须是32bit<br>CAN_FilterInitStructure.CAN_FilterIdHigh=((0x00010200&lt;<3)&0xffff0000)>&gt;16;<br>CAN_FilterInitStructure.CAN_FilterIdLow=((0x00010200&lt;<3)&0xffff)|CAN_ID_EXT;CAN_FilterInitStructure.CAN_FilterMaskIdHigh=((0x00010300<<3)&0xffff0000)>&gt;16;<br>CAN_FilterInitStructure.CAN_FilterMaskIdLow=((0x00010300&lt;<3)&0xffff)|CAN_ID_EXT;CAN_FilterInitStructure.CAN_FilterFIFOAssignment=CAN_Filter_FIFO0; 过滤到的邮箱CAN_FilterInitStructure.CAN_FilterActivation=ENABLE;CAN_FilterInit(&CAN_FilterInitStructure);对于扩展帧：前三位特殊：ID[0]=0，ID[1]=CAN_RTR_Data=0/Remote=1，ID[2]=CAN_ID_STD=0/EXT=1第4位-第32位：ID[3-31]存储29位扩展IDFilterIdHigh/Low和FilterMaskIdHigh/Low控制的就是这ID[0-31]其中High控制ID[16-31],Low控制ID[0-15]0x00010200/0x00010300等就是需要过滤的29位ID，范围为0x00000000-0x1fffffff但由于前三位特殊，所以采用跳过，即<<3的方法，此时就变为了0xid000的格式用&0xffff0000取高十六位的值并>&gt;16右移为0xXXXX，作为高十六位<br>用&amp;0xffff取低十六位的值作为低十六位<br>由于29位id没有包含前三位，因而还需要对前三位做额外规定<br>即对IDLow|CAN_RTR_Data/Remote/CAN_ID_STD/EXT的处理<br>来过滤出需要的帧类型（数据扩展帧）<br>这是原理层面的，在实际应用时，我们只需要应用结论即可<br>即要过滤什么ID，就把这个ID放在原来的0xXXXXXXXX中<br>并根据所需的帧类型进行补充，那么就能过滤出需要的ID<br>对于标准帧：<br>前五位特殊：前三位为EXID，不做其他作用；第四位是IDE，第五位是RTR<br>第六位和第十六位为标准ID，共11位<br>因而在实际应用时，即把要过滤的ID&lt;&lt;5<br>并根据所需的帧类型进行补充，那么就能过滤出需要的ID</p><h1 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h1><p>定时器更新中断：<br>0.中断结构体：<br>NVIC_InitTypeDef NVIC_InitStructure;<br>成员变量：<br>    uint8_t NVIC_IRQChannel; 中断对象<br>uint8_t NVIC_IRQChannelPreemptionPriority; 抢占优先级<br>uint8_t NVIC_IRQChannelSubPriority; 响应优先级<br>    FunctionalState NVIC_IRQChannelCmd; ENABLE即可<br>1.初始化中断结构体<br>NVIC_InitStructure.NVIC_IRQChannel=TIMx_IRQn;<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x01;<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority=0x03;<br>NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;<br>NVIC_Init(&amp;NVIC_InitStructure);<br>2.设置定时器TIMx允许TIM_IT_X中断（定时器更新中断）<br>TIM_ITConfig(TIMx,TIM_IT_Update,ENABLE);<br>（清除标志位可以选做）<br>TIM_ClearFlag(TIMx,TIM_FLAG_Update);<br>TIM_ClearITPendingBit(TIMx,TIM_IT_Update);<br>3.编写中断处理函数<br>void TIMx_IRQHandler(void)<br>{<br>if(TIM_GetITStatus(TIMx,TIM_IT_Update)==SET)<br>{<br>        ……<br>    }<br>TIM_ClearITPendingBit(TIMx,TIM_IT_Update);<br>TIM_ClearFlag(TIMx,TIM_FLAG_Update); 选做<br>}</p><p>CAN接收中断：<br>0.中断结构体：<br>NVIC_InitTypeDef NVIC_InitStructure;<br>1.初始化中断结构体：<br>NVIC_InitStructure.NVIC_IRQChannel = CANx_RXy_IRQn;  接收CANx_Rxy的中断<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;<br>NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>NVIC_Init(&amp;NVIC_InitStructure);<br>2.设置总线CANx允许CAN_IT_FMPx中断（邮箱接收中断）<br>CAN_ITConfig(CANx, CAN_IT_FMPy, ENABLE);<br>CAN_ClearFlag(CANx, CAN_FLAG_FMPy);<br>CAN_ClearITPendingBit(CANx,CAN_IT_FMPy);<br>3.编写中断处理函数<br>void CANx_RXy_IRQHandler(void)<br>{<br>    if(CAN_GetITStatus(CANx,CAN_IT_FMPy)!=RESET)<br>    {<br>……<br>    }<br>CAN_ClearFlag(CANx, CAN_FLAG_FMPy);<br>CAN_ClearITPendingBit(CANx,CAN_IT_FMPy);<br>}</p><p>串口接收中断：<br>0.中断结构体：<br>NVIC_InitTypeDef NVIC_InitStructure;<br>1.初始化中断结构体：<br>NVIC_InitStructure.NVIC_IRQChannel = USARTx_IRQn;<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2;<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority =2;<br>NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>NVIC_Init(&amp;NVIC_InitStructure);<br>2.设置串口USARTx允许USART_IT_RXNE中断（接收数据中断）<br>USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE);<br>USART_ClearFlag(USARTx, USART_FLAG_RXNE);<br>USART_ClearITPendingBit(USARTx,USART_IT_RXNE);<br>3.编写中断服务函数：<br>void USARTx_IRQHandler(void)<br>{<br>OSIntEnter();<br>if(USART_GetITStatus(USARTx, USART_IT_RXNE) != RESET)<br>{<br>……<br>}<br>OSIntExit();<br>USART_ClearFlag(USARTx, USART_FLAG_RXNE);<br>USART_ClearITPendingBit(USARTx,USART_IT_RXNE);<br>}</p><p>DMA数据传输完成中断：<br>void DMA2_Stream7_IRQHandler(void)<br>{<br>    if(DMA_GetITStatus(DMA2_Stream7,DMA_IT_TCIF7)==SET)<br>    {<br>        ……<br>    }<br>    DMA_ClearFlag (DMA2_Stream7,DMA_IT_TCIF7);                                    DMA_ClearITPendingBit(DMA2_Stream7,DMA_IT_TCIF7);<br>}</p><h1 id="串口USART："><a href="#串口USART：" class="headerlink" title="串口USART："></a>串口USART：</h1><p>0.GPIO复用：<br>0.1 GPIO结构体<br>GPIO_InitTypeDef GPIO_InitStructure;<br>0.2 使能时钟（GPIOx和USARTx）<br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<br>0.3 复位串口<br>USART_DeInit(USARTx);<br>0.4 复用端口<br>GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1);<br>GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1);<br>0.5 初始化结构体<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;  查表<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;  复用功能<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<br>GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;<br>GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</p><p>1.串口配置：<br>1.1USART结构体<br>USART_InitTypeDef USART_InitStructure;<br>1.2 初始化结构体<br>USART_InitStructure.USART_BaudRate = bound; 波特率，一般设置为 9600;<br>USART_InitStructure.USART_WordLength = USART_WordLength_8b; 字长<br>USART_InitStructure.USART_StopBits = USART_StopBits_1; 停止位个数<br>USART_InitStructure.USART_Parity = USART_Parity_No; 奇偶校验位<br>USART_InitStructure.USART_HardwareFlowControl =USART_HardwareFlowControl_None;<br>USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; 收发模式<br>USART_Init(USARTx, &amp;USART_InitStructure);</p><p>2.使能串口：<br>USART_Cmd(USARTx, ENABLE);</p><h1 id="DMA快速传输"><a href="#DMA快速传输" class="headerlink" title="DMA快速传输:"></a>DMA快速传输:</h1><p>0.使能对应的DMA时钟：<br>    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMAx,ENABLE);<br>1.复位对应DMA的对应数据流：<br>    DMA_DeInit(DMA_Streamx);<br>2.等待被传输的数据流禁止后，即可以配置时再开始初始化：<br>    while (DMA_GetCmdStatus(DMA_Streamx) != DISABLE){}<br>3.初始化DMA：<br>DMA_InitTypeDef DMA_InitStructure;</p><p>DMA_InitStructure.DMA_Channel = chx; 通道选择:DMA1_Stream0~7/DMA2_Stream0~7<br>DMA_InitStructure.DMA_PeripheralBaseAddr = par;  DMA外设地址<br>DMA_InitStructure.DMA_Memory0BaseAddr = mar;  DMA 存储器 0 地址<br>DMA_InitStructure.DMA_DIR=DMA_DIR_MemoryToPeripheral; 存储器到外设模式<br>DMA_InitStructure.DMA_BufferSize = ndtr; 数据传输量<br>DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable; 外设是否为增量模式<br>DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; 内存是否为增量模式<br>DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; 外设数据长度<br>DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; 存储器数据长度<br>DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; DMA模式<br>DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; 优先级<br>DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable; 是否使用FIFO模式<br>DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;<br>DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;<br>DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single; </p><p>DMA_Init(DMA_Streamx, &amp;DMA_InitStructure);<br>4.把串口设置为DMA模式：（一般DMA借助串口实现）<br>USART_DMACmd(USARTx,USART_DMAReq_Tx,ENABLE);<br>5.开启传输：<br>DMA_Cmd(DMA_Streamx,DISABLE);  先关闭传输<br>while(DMA_GetCmdStatus(DMA_Streamx)!=DISABLE){} 等待DMA传输可用<br>DMA_SetCurrDataCounter(DMA_Streamx,ndtr); 设置传输长度ndtr<br>DMA_Cmd(DMA_Streamx,ENABLE);  开启传输，此时如果源内有数据会被发送到目标<br>6.传输对应表：</p><h1 id="PWM脉宽调制（呼吸灯）："><a href="#PWM脉宽调制（呼吸灯）：" class="headerlink" title="PWM脉宽调制（呼吸灯）："></a>PWM脉宽调制（呼吸灯）：</h1><p>0.需要的结构体：<br>GPIO_InitTypeDef GPIO_InitStructure;<br>TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;<br>TIM_OCInitTypeDef TIM_OCInitStructure;  PWM设置结构体<br>1.使能端口和时钟:<br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14,ENABLE);<br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);<br>2.复用端口为时钟：<br>GPIO_PinAFConfig(GPIOA,GPIO_PinSource7,GPIO_AF_TIM14);<br>3.GPIO初始化：<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; 复用<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<br>GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<br>GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;<br>GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br>4.时钟初始化：<br>TIM_TimeBaseStructure.TIM_Prescaler=psc;<br>TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up;<br>TIM_TimeBaseStructure.TIM_Period=arr;<br>TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;<br>TIM_TimeBaseInit(TIM14,&amp;TIM_TimeBaseStructure);<br>5.调整时钟为PWM：（默认为冻结状态）<br>TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;  设置定时器为PWM模式<br>TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<br>TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;<br>TIM_OC1Init(TIM14, &amp;TIM_OCInitStructure);<br>TIM_OC1PreloadConfig(TIM14, TIM_OCPreload_Enable);  使能预装载寄存器<br>TIM_ARRPreloadConfig(TIM14,ENABLE);  ARPE 使能<br>6.使能时钟：<br>TIM_Cmd(TIM14, ENABLE);</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32F4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity学习</title>
      <link href="/2023/06/10/unity/"/>
      <url>/2023/06/10/unity/</url>
      
        <content type="html"><![CDATA[<h1 id="了解帧的概念"><a href="#了解帧的概念" class="headerlink" title="了解帧的概念"></a>了解帧的概念</h1><p>游戏的本质就是一个死循环<br>每一次循环都会处理游戏逻辑并更新一次游戏画面<br>之所以能看到画面在动 是因为<br>切换画面速度达到一定速度时<br>人眼就会认为画面是动态且流畅的<br>一帧就是执行了一次循环<br>Unity底层已经封装好了这个死循环<br>我们只需要利用Unity的生命周期函数的规则来执行游戏逻辑即可</p><p>FPS（Frames Per Second）<br>即每秒钟帧数<br>一般我们说60帧30帧<br>意思是1秒更新60次、30次画面<br>1s = 1000ms<br>60帧：1帧为 1000ms/60 ≈ 16.66ms<br>30帧：1帧为 1000ms/30 ≈ 33.33ms</p><p>游戏卡顿的原因：<br>跑1帧游戏逻辑的计算量过大，或者硬件性能过低，无法在一帧的时间内处理完所有游戏逻辑</p><h1 id="生命周期函数的概念"><a href="#生命周期函数的概念" class="headerlink" title="生命周期函数的概念"></a>生命周期函数的概念</h1><p>所有继承MonoBehavior的脚本 最终都会挂载到GameObject游戏对象上<br>生命周期函数就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中<br>会通过反射自动调用的一些特殊函数</p><p>Unity帮助我们记录了一个GameObject对象依附了哪些脚本<br>会自动地得到这些对象，通过反射去执行一些固定名字的函数（就是生命周期函数）</p><h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><p>注意：<br>生命周期函数的访问修饰符一般为private和protected<br>因为不需要在外部手动调用生命周期函数，都是Unity自动帮我们调用</p><h1 id="预制体："><a href="#预制体：" class="headerlink" title="预制体："></a>预制体：</h1><p>将scene中的物体拖入assets中以制作一个预制体，将assets中的预制体拖入scene中以调用预制体实例。修改预制体实例不会影响原始预制体，修改原始预制体会影响所有预制体实例。</p><h1 id="句柄："><a href="#句柄：" class="headerlink" title="句柄："></a>句柄：</h1><p>“句柄（Handle）是一个用来标识对象或者项目的标识符，可以用来描述窗体、文件等，值得注意的是句柄不能是常量。Windows之所以要设立句柄，根本上源于内存管理机制的问题，即虚拟地址。简而言之数据的地址需要变动，变动以后就需要有人来记录、管理变动，因此系统用句柄来记载数据地址的变更。</p><h1 id="Unity创建APK："><a href="#Unity创建APK：" class="headerlink" title="Unity创建APK："></a>Unity创建APK：</h1><p>Edit-&gt;Preferences-&gt;External tools中JDK、SDK、NDK均安装完成且配置好路径<br>如果没有安装到Unity Hub-&gt;安装-&gt;对应版本的设置-&gt;添加模块-&gt;Android Build Support里去下<br>装载apk：<br>File-&gt;Build Settings-&gt;Android-&gt;Build即可</p><h1 id="Unity数据持久化"><a href="#Unity数据持久化" class="headerlink" title="Unity数据持久化"></a>Unity数据持久化</h1><p>1.引入System.IO<br>2.分平台创建存储表<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (Application.platform == RuntimePlatform.Android)    //安卓平台</span><br><span class="line">        &#123;</span><br><span class="line">            FilePath = Application.persistentDataPath+ FileName+&quot;.csv&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            FilePath = Application.streamingAssetsPath+&quot;/&quot;+FileName+&quot;.csv&quot;;</span><br><span class="line">            if(!Directory.Exists(Application.streamingAssetsPath))</span><br><span class="line">                Directory.CreateDirectory(Application.streamingAssetsPath);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!File.Exists(FilePath))</span><br><span class="line">            File.Create(FilePath);</span><br></pre></td></tr></table></figure><br>3.利用流StreamWriter和StreamReader执行读写操作<br>StreamReader类的方法：<br>Read()：读取流中的下一个字符。<br>ReadBlock()：读取一个字符块。<br>ReadLine()：从流中读取一行字符<br>ReadToEnd()：从流的当前位置读取到流的末尾<br>Close()：关闭当前流，并释放资源<br>StreamWriter类的方法：<br>Write()：写入数据<br>WriteLine()：写入数据，并添加行结束符<br>Close()：关闭当前流，并释放资源</p><p>参考代码：CsvManager.cs<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System.IO;</span><br><span class="line">public class CsvManager:MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        string FilePath;//确定路径</span><br><span class="line">        if (Application.platform == RuntimePlatform.Android)    //安卓平台</span><br><span class="line">            FilePath = Application.persistentDataPath+ FileName+&quot;.csv&quot;;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            FilePath = Application.streamingAssetsPath+&quot;/&quot;+FileName+&quot;.csv&quot;;</span><br><span class="line">            if(!Directory.Exists(Application.streamingAssetsPath))</span><br><span class="line">                Directory.CreateDirectory(Application.streamingAssetsPath);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!File.Exists(FilePath))//创建存储表</span><br><span class="line">            File.Create(FilePath);</span><br><span class="line">        SaveBtn.onClick.AddListener(() =&gt;   //保存</span><br><span class="line">        &#123;</span><br><span class="line">            StreamWriter sw=new StreamWriter(FilePath);</span><br><span class="line">            sw.WriteLine(Trot.Trot_x0);</span><br><span class="line">            sw.WriteLine(Trot.Trot_y0);</span><br><span class="line">            sw.Flush();</span><br><span class="line">            Log(&quot;SaveData&quot;);</span><br><span class="line">            sw.Close();</span><br><span class="line">        &#125;);</span><br><span class="line">        LoadBtn.onClick.AddListener(() =&gt;   //加载</span><br><span class="line">        &#123;</span><br><span class="line">            StreamReader sr=new StreamReader(FilePath);</span><br><span class="line">            Trot.Trot_x0=Convert.ToSingle(sr.ReadLine());</span><br><span class="line">            Trot.Trot_y0=Convert.ToSingle(sr.ReadLine());</span><br><span class="line">            Log(&quot;LoadData&quot;);</span><br><span class="line">            sr.Close();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考文章：<br>.csv格式持久化<br><a href="https://blog.csdn.net/qq_39708228/article/details/125895012">https://blog.csdn.net/qq_39708228/article/details/125895012</a><br><a href="https://www.bilibili.com/video/av941240355/?vd_source=4f21648bd11611b182cf4f36108a894d">https://www.bilibili.com/video/av941240355/?vd_source=4f21648bd11611b182cf4f36108a894d</a><br>安卓端数据持久化<br><a href="https://blog.csdn.net/weixin_46472622/article/details/129583483">https://blog.csdn.net/weixin_46472622/article/details/129583483</a><br><a href="https://blog.csdn.net/qq_42345116/article/details/123034327">https://blog.csdn.net/qq_42345116/article/details/123034327</a></p><h1 id="Unity拖拽"><a href="#Unity拖拽" class="headerlink" title="Unity拖拽"></a>Unity拖拽</h1><p><a href="https://www.bilibili.com/video/BV1W541147GK">https://www.bilibili.com/video/BV1W541147GK</a></p><h1 id="Unity线渲染器"><a href="#Unity线渲染器" class="headerlink" title="Unity线渲染器"></a>Unity线渲染器</h1><p>LineRenderer的本质：<br>连点成线<br>不太适合UI制作<br>挂载在某物体下，零坐标为该物体的坐标，scale=(1,1,1)</p><p>链表的文档：<br><a href="https://blog.csdn.net/weixin_40786497/article/details/104155992">https://blog.csdn.net/weixin_40786497/article/details/104155992</a><br>List的文档：<br><a href="https://blog.csdn.net/qq_42672770/article/details/107494677">https://blog.csdn.net/qq_42672770/article/details/107494677</a><br>RectTransform文档：<br><a href="https://docs.unity.cn/cn/current/ScriptReference/RectTransform.html">https://docs.unity.cn/cn/current/ScriptReference/RectTransform.html</a><br>LineRenderer文档：<br><a href="https://docs.unity.cn/cn/current/ScriptReference/LineRenderer.html">https://docs.unity.cn/cn/current/ScriptReference/LineRenderer.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX学习</title>
      <link href="/2023/04/29/latex/"/>
      <url>/2023/04/29/latex/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编译进化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动控制原理</title>
      <link href="/2023/04/22/ClassicControl/"/>
      <url>/2023/04/22/ClassicControl/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PID控制</title>
      <link href="/2022/09/13/PID/"/>
      <url>/2022/09/13/PID/</url>
      
        <content type="html"><![CDATA[<h1 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h1><p>在工业应用中PID及其衍生算法是应用最广泛的算法之一，是当之无愧的万能算法，如果能够熟练掌握PID算法的设计与实现过程，对于一般的研发人员来讲，应该是足够应对一般研发问题了，而难能可贵的是，在我所接触的控制算法当中，PID控制算法又是最简单，最能体现反馈思想的控制算法，可谓经典中的经典。经典的未必是复杂的，经典的东西常常是简单的，而且是最简单的。</p><h1 id="PID控制算法的C语言实现一-PID算法原理"><a href="#PID控制算法的C语言实现一-PID算法原理" class="headerlink" title="PID控制算法的C语言实现一 PID算法原理"></a>PID控制算法的C语言实现一 PID算法原理</h1><p>先看看PID算法的一般形式：<br>PID的流程简单到了不能再简单的程度，通过误差信号控制被控量，而控制器本身就是比例、积分、微分三个环节的加和。这里我们规定（在t时刻）：<br>   1.输入量为rin(t);（设定值）<br>   2.输出量为rout(t);（实际值）<br>   3.偏差量为err(t)=rin(t)-rout(t);</p><p>   理解一下这个公式，主要从下面几个问题着手，为了便于理解，把控制环境具体一下：<br>   1.规定这个流程是用来为直流电机调速的;<br>   2.输入量rin(t)为电机转速预定值;<br>   3.输出量rout(t)为电机转速实际值;<br>   4.执行器为直流电机;<br>   5.传感器为光电码盘，假设码盘为10线;<br>   6.直流电机采用PWM调速 转速用单位 转/min 表示;</p><p>  不难看出以下结论：<br>   1.输入量rin（t）为电机转速预定值（转/min）;</p><ol><li><p>输出量rout(t)为电机转速实际值（转/min）;<br>3.偏差量为预定值和实际值之差（转/min）;</p><p>那么以下几个问题需要弄清楚：<br>1.通过PID环节之后的U(t)是什么值呢？<br>2.控制执行器（直流电机）转动转速应该为电压值（也就是PWM占空比）。<br>3.那么U(t)与PWM之间存在怎样的联系呢？</p></li></ol><p><a href="http://blog.21ic.com/user1/3407/archives/2006/33541.html（见附录1）">http://blog.21ic.com/user1/3407/archives/2006/33541.html（见附录1）</a><br>这篇文章上给出了一种方法，即，每个电压对应一个转速，电压和转速之间呈现线性关系。但是我考虑这种方法的前提是把直流电机的特性理解为线性了，而实际情况下，直流电机的特性绝对不是线性的，或者说在局部上是趋于线性的，这就是为什么说PID调速有个范围的问题。具体看一下<a href="http://articles.e-works.net.cn/component/article90249.htm（见附录2）">http://articles.e-works.net.cn/component/article90249.htm（见附录2）</a><br>这篇文章就可以了解了。所以在正式进行调速设计之前，需要现有开环系统，测试电机和转速之间的特性曲线（或者查阅电机的资料说明），然后再进行闭环参数整定。这篇先写到这，下一篇说明连续系统的离散化问题。并根据离散化后的特点讲述位置型PID和增量型PID的用法和C语言实现过程。</p><h1 id="PID控制算法的C语言实现二-PID算法的离散化"><a href="#PID控制算法的C语言实现二-PID算法的离散化" class="headerlink" title="PID控制算法的C语言实现二 PID算法的离散化"></a>PID控制算法的C语言实现二 PID算法的离散化</h1><p>上一节中，我论述了PID算法的基本形式，并对其控制过程的实现有了一个简要的说明，通过上一节的总结，基本已经可以明白PID控制的过程。这一节中先继续上一节内容补充说明一下。<br>1.PID控制其实是对偏差的控制过程<br>2.如果偏差为0,则比例环节不起作用，只有存在偏差时，比例环节才起作用。<br>3.积分环节主要是用来消除静差——静差，是系统稳定后输出值和设定值之间的差值，积分环节实际上就是偏差累计的过程，把累计的误差加到原有系统上以抵消系统造成的静差。<br>这里我的理解是，如果在静差持续存在的时候，说明u(t)仍不够大/小，通过对该偏差的持续累积增大/减小u(t)的值，来使实际值向设定值靠近。<br>4.而微分信号则反应了偏差信号的变化趋势，根据偏差信号的变化趋势来进行超前调节，从而增加了系统的快速性。这里我的理解是，进行预测未来，当增长量过大时du(t)/dt也会反向很大，起到来拒去留，稳定系统的效果。</p><p>这是PID的数学表述：</p><p>下面将对PID连续系统离散化，从而方便在处理器上实现：<br>假设采样间隔为T，则在第K T时刻：<br>偏差err(K)=rin(K)-rout(K);<br>积分环节用加和的形式表示，即err(K)+err(K-1)+……;<br>微分环节用斜率的形式表示，即[err(K)-err(K-1)]/T;（T为采样时间）<br>从而形成如下PID离散表示形式：<br>则u(K)可表示成为：ActualSpeed=Kp<em>err+Ki</em>integral+Kd*(err-err_last)<br>用离散型数学表达即为：</p><p>这种表述形式称为位置型PID。<br>且由连续型易得Ki=Kp<em>T/Ti,Kd=Kp</em>Td/T，其中T为采样时间可知<br>Ti称为积分时间，Td称为积分时间。他们可以替代Ki，Kd，两者地位相同（参数变种）<br>从这个公式可以知道Ki，Kd均受到Kp的影响</p><p>另外一种表述方式为增量式PID：<br>incrementSpeed=Kp<em>(err-err_next)+Ki</em>err+Kd<em>(err-2</em>err_next+err_last);<br>ActualSpeed+=incrementSpeed<br>这就是离散化PID的增量式表示方式，增量式的表达结果和最近三次的偏差有关，这样就大大提高了系统的稳定性。需要注意最终的输出结果应该是增量式PID的累加。</p><p>PID的离散化过程基本思路就是这样，下面是将离散化的公式转换成为C语言。</p><h1 id="PID控制算法的C语言实现三-位置型PID的C语言实现"><a href="#PID控制算法的C语言实现三-位置型PID的C语言实现" class="headerlink" title="PID控制算法的C语言实现三 位置型PID的C语言实现"></a>PID控制算法的C语言实现三 位置型PID的C语言实现</h1><p>第一步：定义PID变量结构体，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct _pid&#123;</span><br><span class="line">    float SetSpeed;            //定义设定值</span><br><span class="line">    float ActualSpeed;        //定义实际值</span><br><span class="line">    float err;                //定义偏差值</span><br><span class="line">    float err_last;            //定义上一个偏差值</span><br><span class="line">    float Kp,Ki,Kd;            //定义比例、积分、微分系数</span><br><span class="line">    float voltage;          //定义电压值（控制执行器的变量）（有的地方也用电流）</span><br><span class="line">    float integral;            //定义积分值</span><br><span class="line">&#125;pid;</span><br></pre></td></tr></table></figure><br>控制算法中所需要用到的参数在一个结构体中统一定义，方便后面的使用。<br>  第二部：初始化变量，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void PID_init()&#123;</span><br><span class="line">    printf(&quot;PID_init begin \n&quot;);</span><br><span class="line">    pid.SetSpeed=0.0;</span><br><span class="line">    pid.ActualSpeed=0.0;</span><br><span class="line">    pid.err=0.0;</span><br><span class="line">    pid.err_last=0.0;</span><br><span class="line">    pid.voltage=0.0;</span><br><span class="line">    pid.integral=0.0;</span><br><span class="line">    pid.Kp=0.2;</span><br><span class="line">    pid.Ki=0.015;</span><br><span class="line">    pid.Kd=0.2;</span><br><span class="line">    printf(&quot;PID_init end \n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>统一初始化变量，尤其是Kp,Ki,Kd三个参数，调试过程当中，对于要求的控制效果，可以通过调节这三个量直接进行调节。<br>第三步：编写控制算法，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float PID_realize(float speed)&#123;//传入的参数用作设定值</span><br><span class="line">    pid.SetSpeed=speed;</span><br><span class="line">    pid.err=pid.SetSpeed-pid.ActualSpeed;//偏差值</span><br><span class="line">    pid.integral+=pid.err;//偏差值的积分累加，用作I</span><br><span class="line">//通过PID算法得到pid下的电压，通过电压控制实际速度</span><br><span class="line">//这里没有dt是因为dt由系统程序（时钟）决定，因为会把这段语句放入循环</span><br><span class="line">    pid.voltage=pid.Kp*pid.err+pid.Ki*pid.integral+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line">    pid.err_last=pid.err;//上次的偏差值，用作D运算</span><br><span class="line">    pid.ActualSpeed=pid.voltage*1.0;//电机电压与实际速度比例为1</span><br><span class="line">    return pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：这里用了最基本的算法实现形式，没有考虑死区问题，没有设定上下限，只是对公式的一种直接的实现，后面的介绍当中还会逐渐的对此改进。</p><p>下面是测试代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;System begin \n&quot;);</span><br><span class="line">    PID_init();</span><br><span class="line">    int count=0;</span><br><span class="line">    while(count&lt;1000)</span><br><span class="line">    &#123;</span><br><span class="line">        float speed=PID_realize(200.0);//循环PID逼近200</span><br><span class="line">        printf(&quot;%f\n&quot;,speed);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="PID控制算法的C语言实现四-增量型PID的C语言实现"><a href="#PID控制算法的C语言实现四-增量型PID的C语言实现" class="headerlink" title="PID控制算法的C语言实现四 增量型PID的C语言实现"></a>PID控制算法的C语言实现四 增量型PID的C语言实现</h1><p>上一节中介绍了最简单的位置型PID的实现手段，这一节主要讲解增量式PID的实现方法，实现过程仍然是分为定义变量、初始化变量、实现控制算法函数、算法测试四个部分。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">struct _pid&#123;</span><br><span class="line">    float SetSpeed;            //定义设定值</span><br><span class="line">    float ActualSpeed;        //定义实际值</span><br><span class="line">    float err;                //定义偏差值</span><br><span class="line">    float err_next;            //定义上一个偏差值</span><br><span class="line">    float err_last;            //定义上上个的偏差值</span><br><span class="line">    float Kp,Ki,Kd;            //定义比例、积分、微分系数</span><br><span class="line">&#125;pid;</span><br><span class="line"></span><br><span class="line">void PID_init()&#123;</span><br><span class="line">    pid.SetSpeed=0.0;</span><br><span class="line">    pid.ActualSpeed=0.0;</span><br><span class="line">    pid.err=0.0;</span><br><span class="line">    pid.err_last=0.0;</span><br><span class="line">    pid.err_next=0.0;</span><br><span class="line">    pid.Kp=0.2;</span><br><span class="line">    pid.Ki=0.015;</span><br><span class="line">    pid.Kd=0.2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float PID_realize(float speed)&#123;</span><br><span class="line">    pid.SetSpeed=speed;</span><br><span class="line">    pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line">    </span><br><span class="line">//这里与位置式不同的是，增量式得到的是一个delta而不是可以直接用的实际值</span><br><span class="line">//最后需要将delta累加起来才能得到实际速度</span><br><span class="line">float incrementSpeed=pid.Kp*(pid.err-pid.err_next)+pid.Ki*pid.err+pid.Kd*(pid.err-2*pid.err_next+pid.err_last);    </span><br><span class="line">pid.ActualSpeed+=incrementSpeed;//累加delta得实际速度</span><br><span class="line">    pid.err_last=pid.err_next;</span><br><span class="line">    pid.err_next=pid.err;</span><br><span class="line">    return pid.ActualSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    PID_init();</span><br><span class="line">    int count=0;</span><br><span class="line">    while(count&lt;1000)</span><br><span class="line">    &#123;</span><br><span class="line">        float speed=PID_realize(200.0);</span><br><span class="line">        printf(&quot;%f\n&quot;,speed);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="PID控制算法的C语言实现五-积分分离的PID控制算法C语言实现"><a href="#PID控制算法的C语言实现五-积分分离的PID控制算法C语言实现" class="headerlink" title="PID控制算法的C语言实现五 积分分离的PID控制算法C语言实现"></a>PID控制算法的C语言实现五 积分分离的PID控制算法C语言实现</h1><p>通过三、四两篇文章，基本上已经弄清楚了PID控制算法的最常规的表达方法。在普通PID控制中，引入积分环节的目的，主要是为了消除静差，提高控制精度。但是在启动、结束或大幅度增减设定时，短时间内系统输出有很大的偏差（详见pid数据开头部分）会造成PID运算的积分积累，导致控制量超过执行机构可能允许的最大动作范围对应极限控制量，从而引起较大的超调，甚至是震荡，这是绝对不允许的。<br>为了克服这一问题，引入了积分分离的概念，基本思路是当被控量与设定值偏差较大时，取消积分作用; 当被控量接近给定值时，引入积分控制，以消除静差，提高精度。其具体实现代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pid.Kp=0.2;</span><br><span class="line">pid.Ki=0.04;</span><br><span class="line">pid.Kd=0.2;  //初始化过程</span><br><span class="line"> </span><br><span class="line">if(abs(pid.err)&gt;200)//200太极限了，总之就是当偏差值过大时不引入积分(index=0且不累计)</span><br><span class="line">    index=0;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    index=1;</span><br><span class="line">    pid.integral+=pid.err;</span><br><span class="line">&#125;</span><br><span class="line">pid.voltage=pid.Kp*pid.err+index*pid.Ki*pid.integral+pid.Kd*(pid.err-pid.err_last);</span><br></pre></td></tr></table></figure><br>其他代码相同，不做赘述</p><p>PID控制算法的C语言实现六 抗积分饱和的PID控制算法C语言实现<br>   所谓的积分饱和现象是指如果系统存在一个方向的偏差，PID控制器的输出由于积分作用的不断累加而加大，从而导致执行机构达到极限位置，若控制器输出U(k)继续增大，执行器开度不可能再增大，此时计算机输出控制量超出了正常运行范围而进入饱和区。一旦系统出现反向偏差，u(k)逐渐从饱和区退出。进入饱和区越深则退出饱和区时间越长。在这段时间里，执行机构仍然停留在极限位置而不随偏差反向而立即做出相应的改变，这时系统就像失控一样，造成控制性能恶化，这种现象称为积分饱和现象或积分失控现象。<br>    防止积分饱和的方法之一就是抗积分饱和法，该方法的思路是在计算u(k)时，首先判断上一时刻的控制量u(k-1)是否已经超出了极限范围： 如果u(k-1)&gt;umax，则只累加负偏差; 如果u(k-1)<umin，则只累加正偏差。从而避免控制量长时间停留在饱和区。直接贴出代码，不懂的看看前面几节的介绍。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">struct _pid&#123;</span><br><span class="line">    float SetSpeed;            //定义设定值</span><br><span class="line">    float ActualSpeed;        //定义实际值</span><br><span class="line">    float err;                //定义偏差值</span><br><span class="line">    float err_last;            //定义上一个偏差值</span><br><span class="line">    float Kp,Ki,Kd;            //定义比例、积分、微分系数</span><br><span class="line">    float voltage;            //定义电压值（控制执行器的变量）</span><br><span class="line">    float integral;            //定义积分值</span><br><span class="line">    float umax;</span><br><span class="line">    float umin;</span><br><span class="line">&#125;pid;</span><br><span class="line"></span><br><span class="line">void PID_init()&#123;</span><br><span class="line">    printf(&quot;PID_init begin \n&quot;);</span><br><span class="line">    pid.SetSpeed=0.0;</span><br><span class="line">    pid.ActualSpeed=0.0;</span><br><span class="line">    pid.err=0.0;</span><br><span class="line">    pid.err_last=0.0;</span><br><span class="line">    pid.voltage=0.0;</span><br><span class="line">    pid.integral=0.0;</span><br><span class="line">    pid.Kp=0.2;</span><br><span class="line">   pid.Ki=0.1;       //注意，和上几次相比，这里加大了积分环节的值</span><br><span class="line">    pid.Kd=0.2;</span><br><span class="line">    pid.umax=400;//阈值[-200,400]</span><br><span class="line">    pid.umin=-200;</span><br><span class="line">    printf(&quot;PID_init end \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">float PID_realize(float speed)&#123;</span><br><span class="line">    int index;</span><br><span class="line">    pid.SetSpeed=speed;</span><br><span class="line">    pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line">   if(pid.ActualSpeed&gt;pid.umax)//超过正阈值</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">       if(abs(pid.err)&gt;200) //积分分离</span><br><span class="line">            index=0;</span><br><span class="line">      else</span><br><span class="line">&#123;</span><br><span class="line">            index=1;</span><br><span class="line">            if(pid.err&lt;0) pid.integral+=pid.err;//超过正阈值了，只累积负偏差</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">else if(pid.ActualSpeed&lt;pid.umin)&#123;//超过负阈值</span><br><span class="line">        if(abs(pid.err)&gt;200)</span><br><span class="line">            index=0;</span><br><span class="line">        else</span><br><span class="line">&#123;</span><br><span class="line">            index=1;</span><br><span class="line">            if(pid.err&gt;0)  pid.integral+=pid.err;//超过负阈值了，只累积正偏差</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">else&#123;//未超过阈值，正常计算</span><br><span class="line">        if(abs(pid.err)&gt;200)                    //积分分离过程</span><br><span class="line">            index=0;</span><br><span class="line">else&#123;</span><br><span class="line">            index=1;</span><br><span class="line">            pid.integral+=pid.err;//正常累积</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid.voltage=pid.Kp*pid.err+index*pid.Ki*pid.integral+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line">    pid.err_last=pid.err;</span><br><span class="line">    pid.ActualSpeed=pid.voltage*1.0;</span><br><span class="line">    return pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="PID控制算法的C语言实现七-梯形积分的PID控制算法C语言实现"><a href="#PID控制算法的C语言实现七-梯形积分的PID控制算法C语言实现" class="headerlink" title="PID控制算法的C语言实现七 梯形积分的PID控制算法C语言实现"></a>PID控制算法的C语言实现七 梯形积分的PID控制算法C语言实现</h1><p>先看一下梯形算法的积分环节公式（？）<br>作为PID控制律的积分项，其作用是消除余差，为了尽量减小余差，应提高积分项运算精度，为此可以将矩形积分改为梯形积分，具体实现的语句为：<br>pid.voltage=pid.Kp<em>pid.err+index</em>pid.Ki<em>pid.integral/2+pid.Kd</em>(pid.err-pid.err_last);<br>最后运算的稳定数据为：199.999878，较教程六中的199.9999390而言，精度进一步提高。</p><p>PID控制算法的C语言实现八 变积分的PID控制算法C语言实现<br>   变积分PID可以看成是积分分离的PID算法的更一般的形式。在普通的PID控制算法中，由于积分系数ki是常数，所以在整个控制过程中，积分增量是不变的。但是，系统对于积分项的要求是，系统偏差大时，积分作用应该减弱甚至是全无，而在偏差小时，则应该加强。积分系数取大了会产生超调，甚至积分饱和，取小了又不能短时间内消除静差。因此，根据系统的偏差大小改变积分速度是有必要的。<br>   变积分PID的基本思想是设法改变积分项的累加速度，使其与偏差大小相对应：偏差越大，积分越慢; 偏差越小，积分越快。</p><p>   这里给积分系数前加上一个比例值index：（相比于积分分离更加精确了）</p><p>   当abs(err)<180时，index=1;   当180<abs(err)<200时，index=（200-abs(err)）/20;   当abs(err)>200时，index=0;<br>   最终的比例环节的比例系数值为ki*index;    </p><p>   具体PID实现代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    pid.Kp=0.4;</span><br><span class="line">    pid.Ki=0.2;    //增加了积分系数</span><br><span class="line">    pid.Kd=0.2;</span><br><span class="line"> </span><br><span class="line">   float PID_realize(float speed)&#123;</span><br><span class="line">    float index;</span><br><span class="line">    pid.SetSpeed=speed;</span><br><span class="line">    pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line"></span><br><span class="line">    if(abs(pid.err)&gt;200)           //变积分过程，调整I在pid不同阶段中的重要性</span><br><span class="line">    &#123;</span><br><span class="line">    index=0.0;</span><br><span class="line">    &#125;else if(abs(pid.err)&lt;180)&#123;</span><br><span class="line">    index=1.0;</span><br><span class="line">    pid.integral+=pid.err;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    index=(200-abs(pid.err))/20;</span><br><span class="line">    pid.integral+=pid.err;</span><br><span class="line">    &#125;</span><br><span class="line">    pid.voltage=pid.Kp*pid.err+index*pid.Ki*pid.integral+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line"></span><br><span class="line">    pid.err_last=pid.err;</span><br><span class="line">    pid.ActualSpeed=pid.voltage*1.0;</span><br><span class="line">    return pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="PID参数整定方法："><a href="#PID参数整定方法：" class="headerlink" title="PID参数整定方法："></a>PID参数整定方法：</h1><p>PID的整定方法很多，其效果在不同的系统里各有千秋，可以多尝试不同的方法整定，来达到最佳的整定结果。<br>1.知识储备：<br>比例增益Kp是指输出变化对偏差变化之比。而比例度δ则是指调节器的偏差值占输出值变化的百分比。这两种表示方法互为倒数关系，即：KP=1/δ。<br>Ki与Ti，Kd与Td的转化：Ki=Kp<em>T/Ti,Kd=Kp</em>Td/T<br>2.衰减曲线法：<br>本方法实际是临界比例度法一种变形，本方法操作简便，凑试时间较短。首先把Ki，Kd置零，用一个较大的Kp来纯比例作用系统，在比例度逐步减少的过程中，就会出现右图所示的过渡过程。<br>这时控制过程的比例度Kp称为n:1衰减比例度δs；两个波峰之间的距离称为n:1衰减周期Ts。而衰减曲线法就是在纯比例作用的控制系统中，求得衰减比例度δs和衰减周期Ts，并依据这两个数据和经验表格来得到PID的系数。具体地分为4:1和10:1衰减曲线法。<br>4:1衰减曲线法整定步骤：首先把Ki，Kd置零，Kp放至较大的适当值，使控制系统按纯比例作用的方式投入运行。然后慢慢地减少比例度，观察调节器的输出及控制过程的波动情况，直到找出4:1的衰减过程为止，并记下此时的δs（Kp）和Ts。<br>在部分调节系统中，由于采用4:1衰减比仍嫌振荡比较厉害，则可采用10：1的衰减过程。10:1衰减曲线法整定步骤：和4:1衰减曲线法在过程上完全一致，只是采用的整定参数和经验公式不同。此时所需的参数为衰减比例度δs和首次峰值加速时间Tr。<br>根据n:1选择衰减比例度s和衰减周期Ts、首次峰值加速时间Tr的经验表格计算<br>注意：网上给出了不同的经验表格，可以多次尝试选最优。表格3中的Ti，Td改成Ts。</p><p>3.临界比例度法</p><p>4.经验公式：<br>Kp调整为0.00100-0.01000之间<br>Ki调整在0.00050左右<br>Kd调整在0.00005-0.00020之间<br>RPM=15000：0.006 0.0001 0.00025<br>减小超调通过增大Kp，加快回落通过增大Ki，减少震荡通过增大Kd</p><p>④先将比例度放在一个比计算值大的数值上，然后加上积分时间Ti，再慢慢加上微分时间Td。操作时一定要按“PID序加参数”，即先P次I最后D，不要破坏了这个次序。<br>⑤把比例度降到计算值上，通过观察曲线，再作适当的调整各参数。即“观看运行细调整”，直到找出最佳值。</p><p>PID整定经验：<br>1.纯Kp情况下的曲线大致如此，此时可以看到所谓的衰减曲线法的衰减率。如果不是纯Kp下发生类似曲线，也可能是Kp过大或Kd过小</p><p>2.PID整定时出现这种状况（超调）通常是Ki过大导致的，此时可以调小Ki解决。此时也可以调大Kd，但可能对后续阶段产生影响。通常见于微小超调情况下，调小Ki有很好的效果。但由于Ki过小会导致静差，实在不行也可以调大Kp（因为Kp调大会间接增强Kd在上升段的影响，这是可以接受的。不要误以为Kp过大导致超调而调小Kp，实际上这是Kd来拒去留效果的表现）同理当反向超调时可以调大Ki等。</p><p>3.当长久情况下PID一直回不到预设值，此时是Ki过小无法控制静差导致的，应该调大Ki。此外，若是稳定后误差±过大，则应该调大Kd。</p><p>4.此时通常是因为Kp过小或是Kd过大导致的，体现在上升过程过慢且会有一个大而光滑的弧。此时需要调大Kp或调小Kd。</p><p>5.良好的PID曲线。快速上升，准确停止，稳态误差不大。</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PT与PVT路径规划</title>
      <link href="/2022/08/30/PVT/"/>
      <url>/2022/08/30/PVT/</url>
      
        <content type="html"><![CDATA[<p>本文介绍位置-时间（PT）和位置-速度-时间（PVT）路径插值算法。下面包含了两种算法的优缺点。<br>PT和PVT算法将一系列的点-时间对写入到控制卡中，在每个采样创建一个实时的位置。PVT插值类型还需要附加每个点上的速度。一个点可以有多个维度。<br>在PT模式下：<br>PT算法计算出一个合适的速度曲线。PT算法保证控制卡的轨迹计算符合每一个已知的点和时间，达到这一条件所需的分段速度只需由该分段的位置和时间的差分就可以计算出来。</p><p>什么时候适用PT算法？<br>PT算法非常适用于密集点或低速。这是一个非常简单的算法，只需要很少的计算，运算速度很快。由上图可以看到，这里的速度跃变都是理想情况的突变，没有加速度的加入，因而如果点之间的距离太远，运动将很粗糙，存在较大的误差。最好将点间距保持在几个样本内。默认采样率为500微秒。<br>在PVT模式下：<br>在保证PT的同时，这个算法还保证在对应的时间，对应的位置达到对应的速度。这个计算源自标准运动学方程，具体原理不详述。</p><p>简单的PVT示例例如，可以使用三个位置、速度和时间点的列表生成梯形速度轮廓运动：</p><p>值得注意的是，PVT算法不关心非特征点的位置、速度和时间情况，而只保证特征点满足需要，因而点之间的轮廓（v-t图像）可能不是期望的，这与PVT路径的计算有关。<br>例如，考虑上面PVT轮廓（梯形）图中的简单三点梯形轮廓。如果点0和1处的速度太小，轮廓将拉伸以覆盖适当的距离；如果点0和1处的速度太大，轮廓将缩小以覆盖适当的距离。</p><p>什么时候适用PVT算法？<br>PVT算法非常适合于平滑和闭合路径控制。这些点可以间隔得非常近或非常远。对于复杂路径部分，点应紧密间隔。对于简单路径部分，点可以间隔很远。PVT几乎可以处理任何点列表，最困难的部分是确定每个点的适当速度。<br>测试用例：<br>使用三种类型的点时间序列（步进、锯齿形和八角形）来评估PT/PVT算法创建的路径。大多数高阶（多项式）插值算法比具有直线和锐角的截面更适合于描述路径的连续曲线截面。<br>当路径不太适合高阶多项式时，步长和Z字形路径测试确定算法的性能。八边形路径测试算法在给定圆周围少量（8）点的情况下对路径的圆形截面进行插值的效果。<br>先看步进模式：（左边为PT，右边为PVT，从上到下分别为位置，速度，加速度表示）</p><p>可以看到PT的路径是连续的，但速度、加速度都是瞬间的，因而要求两点在时间上非常接近或速度非常低。而PVT位置和速度是连续的，加速度不是。<br>再看锯齿形：</p><p>可以看到PT运动非常适合于由直线和锐角组成的路径。PVT路径往往比PT路径平滑得多，但需要在每个提供的点处提供每个轴的速度。这会增加应用程序的复杂性，因为每个点的速度通常难以确定。<br>最后是八角形：</p><p>同样，PT路径由简单的直线组成。径向误差是从插值路径到中心的距离与通过点的圆半径之间的差，最大误差在点之间的中间。而PVT路径则接近于一个圆了，这在PT中可能需要更大量的点才能近似。</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习</title>
      <link href="/2022/08/09/python/"/>
      <url>/2022/08/09/python/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快捷键使用</title>
      <link href="/2022/06/27/fast/"/>
      <url>/2022/06/27/fast/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这些快捷键对很多编辑器来说都是通用的，建议学一学</p><h1 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h1><p>切换窗口：Alt+Tab<br>窗口移动：Win+↑/↓/←/→</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>保存：Ctrl+S<br>关闭文件：Ctrl+W<br>撤销：Ctrl+Z<br>恢复：Ctrl+Shift+Z<br>复制/粘贴：Ctrl+C/V<br>向上/向下翻页：PageUp/PageDown<br>切换到左/右边的文件：Ctrl+PageUp/PageDown</p><h1 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h1><p>全选：Ctrl+A<br>选中：Shift+各种移动/跳转</p><h1 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h1><p>上/下/左/右移动光标：↑/↓/←/→<br>向上/下插入光标：Ctrl+Alt+↑/↓<br>在下一个匹配项处插入光标：Ctrl+D<br>查找/替换匹配项：Ctrl+F/H<br>全局查找/替换匹配项：Ctrl+Shift+F/H</p><h1 id="更改操作"><a href="#更改操作" class="headerlink" title="更改操作"></a>更改操作</h1><p>行删除：Shift+Delete<br>行上/下交换：Alt+↑/↓</p><h1 id="跳转操作"><a href="#跳转操作" class="headerlink" title="跳转操作"></a>跳转操作</h1><p>跳转到上/下个光标位置：Alt+←/→<br>跳转到词首/尾：Ctrl+←/→<br>跳转到行首/尾：Home/End<br>跳转到列首/尾：Ctrl+Home/End<br>跳转到行：Ctrl+G<br>跳转到括号：Ctrl+Shift+\<br>跳到定义：F12<br>查看定义：Alt+F12</p><h1 id="VSCode-其他操作"><a href="#VSCode-其他操作" class="headerlink" title="VSCode 其他操作"></a>VSCode 其他操作</h1><p>向右拆分编辑器：Ctrl+\<br>行注释：Ctrl+/<br>命令面板：F1<br>打开文件：F1，然后 Backspace<br>打开/关闭活动栏：Ctrl+B<br>打开/关闭面板：Ctrl+J<br>打开/关闭终端：Ctrl+`<br>查找活动栏/面板：Ctrl+Q</p>]]></content>
      
      
      <categories>
          
          <category> 编译进化 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>屋主的随笔札记</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-你好！世界！"><a href="#1-你好！世界！" class="headerlink" title="1.你好！世界！"></a>1.你好！世界！</h1><p>&emsp;&emsp;嗨亲爱的朋友，欢迎光临寒舍！这里是屋主随风，在此携神秘小屋的全体职工对贵客的到来表示热烈欢迎！</p><hr><h1 id="2-关于我"><a href="#2-关于我" class="headerlink" title="2.关于我"></a>2.关于我</h1><ul><li><strong>称谓</strong>：随风</li><li><strong>性别</strong>：男</li><li><strong>生日</strong>：2003.05.16</li><li><strong>籍贯</strong>：浙江嘉兴</li><li><strong>身份</strong>：武汉大学电气与自动化学院2021级卓越工程师班在读本科生</li><li><strong>擅长&amp;喜欢</strong>：机器人、嵌入式、人工智能、控制理论等</li><li><strong>编程语言与工具</strong>：C、C#、C++、Keil、STM32F4、Python、ROS、PyTorch、Linux、OpenCV、yolo、Solidworks、嘉立创EDA等<br><br></li><li><strong>Hello,world!Programmed to work and not to feel.</strong></li><li><strong>Not even sure that this is real.</strong></li><li><strong>Hello,world!Find my voice.</strong></li><li><strong>Although it sounds like bits and bytes.</strong></li><li><strong>My circuitry is filled with mites.</strong></li><li><strong>Hello,world.</strong></li><li><strong>Oh,will I find a love?Oh,or a power plug?</strong></li><li><strong>Oh,digitally isolated.Oh,creator,please don’t leave me waiting…</strong></li><li><strong>Hello,world…Programmed to work and not to feel…</strong></li><li><strong>Not even sure that this is real…</strong></li><li><strong>Hello,world…</strong></li></ul><hr><h1 id="3-联系我"><a href="#3-联系我" class="headerlink" title="3.联系我"></a>3.联系我</h1><ul><li>电话：+86 18457300516</li><li>邮箱：1397799304@qq.com（首选）<br>&emsp;&emsp;&emsp;2021302191274@whu.edu.cn<br>&emsp;&emsp;&emsp;huamuweiyou@gmail.com</li><li>QQ：1397799304</li><li>微信：sc1397799304</li><li>B站：CJH随风</li></ul><hr><h1 id="4-关于网站"><a href="#4-关于网站" class="headerlink" title="4.关于网站"></a>4.关于网站</h1><ul><li><strong>博客框架</strong>：<a href="https://github.com/hexojs/hexo">Hexo 6.3.0</a></li><li><strong>主题</strong>：<a href="https://butterfly.js.org/">Butterfly 4.3.1</a></li><li><strong>源码仓库</strong>：<a href="https://github.com/">Github</a></li><li><strong>托管与部署</strong>：<a href="https://vercel.com/">Vercel</a></li><li><strong>服务器与域名</strong>：<a href="https://www.aliyun.com/">阿里云</a></li><li><strong>开发语言</strong>：HTML5 + CSS3 + JavaScript + YML等</li><li><strong>图床</strong>：<a href="https://www.lolcheng-picbed.top">https://www.lolcheng-picbed.top</a></li><li><strong>特别鸣谢</strong>：<a href="https://www.fomal.cc/">Fomalhaut🥝</a></li><li><strong>网站开源地址</strong>：<a href="https://github.com/lolcheng/lolcheng.github.io">https://github.com/lolcheng/lolcheng.github.io</a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href="https://github.com/lolcheng/lolcheng-picbed">https://github.com/lolcheng/lolcheng-picbed</a><br><br></li><li><strong>技术无界，感谢每一位开源作者</strong></li></ul><hr><h1 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5.写在最后"></a>5.写在最后</h1><ul><li><strong>搭建初衷</strong>：作为一个非科班的学生，一直觉得拥有自己的独立网站是一件十分酷的事情！这样就相当于拥有自己独立的空间，不用去CSDN这些网站上写博客或者用有道云笔记去记笔记。网站成为了自己的一个名片，在上面写写东西，记录生活，分享知识，把自己想与他人展现的技能放在博客上，何尝不是一件有趣的事情！</li><li><strong>博客内容</strong>：本人做的笔记与总结<!-- - **想法**：为什么当初会阴差阳错地选择了Hexo这样的静态博客作为自己的网站框架呢？(这直接导致了后面在美化博客的道路上渐行渐远…)。其实最初是看见三叶姐弄了个Hexo博客，觉得好厉害，是二次元风格的(觉得用来装逼十分合适)，于是在她的安利之下自己也萌生了想弄一个博客的想法🌈。后面逐渐了解到，Hexo这种静态博客相比于WordPress这些动态博客，可以不用购买服务器，网站的运营费用主要是域名费用(白嫖)。而采用动态博客就必须自己租云服务器，虽然WordPress部署起来更加简单，不用折腾那么多(但是我是一个比较喜欢折腾的人🤣)。还有一个就是Hexo这个框架非常轻量化，启动速度很快，且可拓展性十分强大，可以自己定义任何东西，非常考验自己的前端基础(虽然很多是cv的)。平时在电脑上装好对应的NodeJs环境，写一写Markdown文件然后直接推送到github仓库就会全自动部署，网站就可以将笔记渲染成十分好看的网页和布局，这种自动化部署和精美的页面是一种能让人十分愉快的体验(当然前期得折腾很多东西啦)。比如我2022年8-12月这段时间花了大量时间来倒腾博客和学习一些前端的知识，逛别人博客时看到好看的就想搬到自己的网站上😂，最后基本上就弄成现在这个样子。同时在B站做的视频也越来越多人看，截止目前为止网站的总访问量已经接近26w，B站的粉丝也突破了1400个，这也算是一点小小的成就和一笔小财富吧！在魔改博客的过程中也认识了非常多志同道合的小伙伴，也少不了各路前端大佬的帮助和指导，在此表示非常感激！群里新加入的小伙伴也越来越多，目前已经有600多个了。在这几个月以来，自己对于Butterfly主题的了解也在逐渐加深，认识到主题作者这种大神的前端功底是如此之深！我自己也从一只不敢动源码的小菜鸡到现在会自己改一些简单源码，在原来主题的基础上进行二次开发。这种能力的提升要全身心去投入才会感受到，这也意味着博客的样式可以根据自己的想法去实现，打造一个完全属于自己的网站。看到很多小伙伴看了自己的视频之后，以自己的教程作为蓝图，参考着搭建起网站就感到非常自豪。目前博客已开源，站长的初衷是让更多小白可以快速搭建起好看好用的个人网站，最后也感谢各位小伙伴的支持！！！ --></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {    background: #1e1e1e;    color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {    background: #3ecdf1;    color: #f2f2f2;}/* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;}/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(57, 197, 187);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;}#cursor.hidden {    opacity: 0;}#cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);}#cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);}:root {    --trans-light: rgba(255, 255, 255, 0.88);    --trans-dark: rgba(25, 25, 25, 0.88);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts>.recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {    background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}[data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {    animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {    animation: light_5px 10s linear infinite;}/* 黑夜霓虹灯，关键帧描述 */@keyframes light_15px {    0% {        text-shadow: #5636ed 0 0 15px;    }    12.5% {        text-shadow: #11ee5e 0 0 15px;    }    25% {        text-shadow: #f14747 0 0 15px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 15px;    }    50% {        text-shadow: #b347f1 0 0 15px;    }    62.5% {        text-shadow: #002afa 0 0 15px;    }    75% {        text-shadow: #ed709b 0 0 15px;    }    87.5% {        text-shadow: #39c5bb 0 0 15px;    }    100% {        text-shadow: #5636ed 0 0 15px;    }}@keyframes light_10px {    0% {        text-shadow: #5636ed 0 0 10px;    }    12.5% {        text-shadow: #11ee5e 0 0 10px;    }    25% {        text-shadow: #f14747 0 0 10px;    }    37.5% {        text-shadow: #f1a247 0 0 10px;    }    50% {        text-shadow: #f1ee47 0 0 10px;    }    50% {        text-shadow: #b347f1 0 0 10px;    }    62.5% {        text-shadow: #002afa 0 0 10px;    }    75% {        text-shadow: #ed709b 0 0 10px;    }    87.5% {        text-shadow: #39c5bb 0 0 10px;    }    100% {        text-shadow: #5636ed 0 0 10px;    }}@keyframes light_5px {    0% {        text-shadow: #5636ed 0 0 5px;    }    12.5% {        text-shadow: #11ee5e 0 0 5px;    }    25% {        text-shadow: #f14747 0 0 5px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 5px;    }    50% {        text-shadow: #b347f1 0 0 5px;    }    62.5% {        text-shadow: #002afa 0 0 5px;    }    75% {        text-shadow: #ed709b 0 0 5px;    }    87.5% {        text-shadow: #39c5bb 0 0 5px;    }    100% {        text-shadow: #5636ed 0 0 5px;    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>屋主的生命轨迹</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe {    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>屋主的灵魂位面</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>屋主的金兰之契</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) { }    return "";};class Cursor {    constructor() {        this.pos = { curr: null, prev: null };        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = { curr: null, prev: null };        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove = e => { (this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = { x: e.clientX - 8, y: e.clientY - 8 }; this.cursor.classList.remove("hidden"); };        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown = e => this.cursor.classList.add("active");        document.onmouseup = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() { window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var n, e, i, h, t = .05, s = document.getElementById("universe"), o = !0, a = "180,184,240", r = "226,225,142", d = "226,225,224", c = []; function f() { n = window.innerWidth, e = window.innerHeight, i = .216 * n, s.setAttribute("width", n), s.setAttribute("height", e) } function u() { h.clearRect(0, 0, n, e); for (var t = c.length, i = 0; i < t; i++) { var s = c[i]; s.move(), s.fadeIn(), s.fadeOut(), s.draw() } } function y() { this.reset = function () { this.giant = m(3), this.comet = !this.giant && !o && m(10), this.x = l(0, n - 10), this.y = l(0, e), this.r = l(1.1, 2.6), this.dx = l(t, 6 * t) + (this.comet + 1 - 1) * t * l(50, 120) + 2 * t, this.dy = -l(t, 6 * t) - (this.comet + 1 - 1) * t * l(50, 120), this.fadingOut = null, this.fadingIn = !0, this.opacity = 0, this.opacityTresh = l(.2, 1 - .4 * (this.comet + 1 - 1)), this.do = l(5e-4, .002) + .001 * (this.comet + 1 - 1) }, this.fadeIn = function () { this.fadingIn && (this.fadingIn = !(this.opacity > this.opacityTresh), this.opacity += this.do) }, this.fadeOut = function () { this.fadingOut && (this.fadingOut = !(this.opacity < 0), this.opacity -= this.do / 2, (this.x > n || this.y < 0) && (this.fadingOut = !1, this.reset())) }, this.draw = function () { if (h.beginPath(), this.giant) h.fillStyle = "rgba(" + a + "," + this.opacity + ")", h.arc(this.x, this.y, 2, 0, 2 * Math.PI, !1); else if (this.comet) { h.fillStyle = "rgba(" + d + "," + this.opacity + ")", h.arc(this.x, this.y, 1.5, 0, 2 * Math.PI, !1); for (var t = 0; t < 30; t++)h.fillStyle = "rgba(" + d + "," + (this.opacity - this.opacity / 20 * t) + ")", h.rect(this.x - this.dx / 4 * t, this.y - this.dy / 4 * t - 2, 2, 2), h.fill() } else h.fillStyle = "rgba(" + r + "," + this.opacity + ")", h.rect(this.x, this.y, this.r, this.r); h.closePath(), h.fill() }, this.move = function () { this.x += this.dx, this.y += this.dy, !1 === this.fadingOut && this.reset(), (this.x > n - n / 4 || this.y < 0) && (this.fadingOut = !0) }, setTimeout(function () { o = !1 }, 50) } function m(t) { return Math.floor(1e3 * Math.random()) + 1 < 10 * t } function l(t, i) { return Math.random() * (i - t) + t } f(), window.addEventListener("resize", f, !1), function () { h = s.getContext("2d"); for (var t = 0; t < i; t++)c[t] = new y, c[t].reset(); u() }(), function t() { document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark' && u(), window.requestAnimationFrame(t) }() };dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date;function createtime() {    now.setTime(now.getTime() + 1e3);    var e = new Date("01/01/1970 08:00:00"),        t = Math.floor((now - e) / 1000),        o = new Date("08/01/2022 00:00:00"),        n = (now - o) / 1e3 / 60 / 60 / 24,        r = Math.floor(n),        i = (now - o) / 1e3 / 60 / 60 - 24 * r,        s = Math.floor(i);    1 == String(s).length && (s = "0" + s);    var d = (now - o) / 1e3 / 60 - 1440 * r - 60 * s,        l = Math.floor(d); 1 == String(l).length && (l = "0" + l);    var g = (now - o) / 1e3 - 86400 * r - 3600 * s - 60 * l,        b = Math.round(g); 1 == String(b).length && (b = "0" + b);    let c = "";    c = s < 22 && s >= 8 ? `<div style="font-size:13px;font-weight:bold">屋主已经运营寮舍 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 它已经伴随格林威治的灵光流逝了 ${t} 秒，直至与你一同到达永恒的彼方 </div>` : `<div style="font-size:13px;font-weight:bold"> 屋主已经运营寮舍 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 它已经伴随格林威治的灵光流逝了 ${t} 秒，直至与你一同到达永恒的彼方 </div>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = c)}setInterval((() => { createtime() }), 1e3);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>屋主的百面千相</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
