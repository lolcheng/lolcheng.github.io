<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ROS学习 | 随风的神秘小屋</title><meta name="author" content="沈畅"><meta name="copyright" content="沈畅"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="有关于ROS方面的相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="ROS学习">
<meta property="og:url" content="https://www.lolcheng.top/2023/12/05/ROS/index.html">
<meta property="og:site_name" content="随风的神秘小屋">
<meta property="og:description" content="有关于ROS方面的相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lolcheng-picbed.top/img/ROS.png">
<meta property="article:published_time" content="2023-12-05T14:12:00.000Z">
<meta property="article:modified_time" content="2023-12-05T14:12:00.000Z">
<meta property="article:author" content="沈畅">
<meta property="article:tag" content="ROS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lolcheng-picbed.top/img/ROS.png"><link rel="shortcut icon" href="https://www.lolcheng-picbed.top/img/favicon.png"><link rel="canonical" href="https://www.lolcheng.top/2023/12/05/ROS/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ROS学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-05 22:12:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 致来者</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.lolcheng-picbed.top/img/ROS.png')"><nav id="nav"><span id="blog-info"><a href="/" title="随风的神秘小屋"><span class="site-name">随风的神秘小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 致来者</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ROS学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-05T14:12:00.000Z" title="发表于 2023-12-05 22:12:00">2023-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-05T14:12:00.000Z" title="更新于 2023-12-05 22:12:00">2023-12-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/">机器人</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>88分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ROS学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="使用vscode创建并应用一个ros项目："><a href="#使用vscode创建并应用一个ros项目：" class="headerlink" title="使用vscode创建并应用一个ros项目："></a>使用vscode创建并应用一个ros项目：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">	1.使用命令行创建工作空间：</span><br><span class="line">		mkdir -p 工作空间名称/src(必须得有 src)</span><br><span class="line">		cd 工作空间名称</span><br><span class="line">		catkin_make（编译）</span><br><span class="line">	2.进入工作空间，启动vscode：</span><br><span class="line">		cd 工作空间名称</span><br><span class="line">		code .</span><br><span class="line">	3.vscode中编译ros：</span><br><span class="line">		ctrl + shift + B 调用编译，选择:catkin_make:build，并点击右侧齿轮自动创建tasks.json文件，修改.vscode/tasks.json 文件如下：</span><br><span class="line">		&#123;</span><br><span class="line">		// 有关 tasks.json 格式的文档，请参见</span><br><span class="line">		    // https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">		    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">		    &quot;tasks&quot;: [</span><br><span class="line">			&#123;</span><br><span class="line">			    &quot;label&quot;: &quot;catkin_make:debug&quot;, //代表提示的描述性信息</span><br><span class="line">			    &quot;type&quot;: &quot;shell&quot;,  //可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行</span><br><span class="line">			    &quot;command&quot;: &quot;catkin_make&quot;,//这个是我们需要运行的命令</span><br><span class="line">			    &quot;args&quot;: [],//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2”</span><br><span class="line">			    &quot;group&quot;: &#123;&quot;kind&quot;:&quot;build&quot;,&quot;isDefault&quot;:true&#125;,</span><br><span class="line">			    &quot;presentation&quot;: &#123;</span><br><span class="line">				&quot;reveal&quot;: &quot;always&quot;//可选always或者silence，代表是否输出信息</span><br><span class="line">			    &#125;,</span><br><span class="line">			    &quot;problemMatcher&quot;: &quot;$msCompile&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		    ]</span><br><span class="line">		&#125;</span><br><span class="line">	4.创建ros运行包名及其依赖的工具包：</span><br><span class="line">		选择大src后右击create catkin package键入包名（Package name）和依赖包名（Dependencies:roscpp rospy std_msgs）</span><br><span class="line">		// 平替在终端中输入catkin_create_pkg 自定义ROS包名 依赖名(roscpp rospy std_msgs）的过程，会体现在package.xml中&lt;build_depend&gt;和&lt;exec_depend&gt;以及CMakeLists.txt L10 find_package中，如果再创建好后要增删依赖包，也只需要在上述文件的对应位置进行修改即可·</span><br><span class="line">	5.C++实现：</span><br><span class="line">		在小src下新建cpp文件</span><br><span class="line">		如果没有代码提示需要修改 .vscode/c_cpp_properties.json中的&quot;cppStandard&quot;为&quot;c++17&quot;</span><br><span class="line">		当ROS__INFO 终端输出有中文时，会出现乱码，此时要在在函数开头加入下面代码的任意一句：setlocale(LC_CTYPE, &quot;zh_CN.utf8&quot;)/setlocale(LC_ALL, &quot;&quot;)</span><br><span class="line">	6.Python实现：</span><br><span class="line">		在小src同级下新建scripts文件夹添加py文件和可执行权限chmod +x xxx.py（之后命令行语句都可以在vscode下新建终端，一种是点击终端加号，一种是选中文件夹右键点击集成终端）</span><br><span class="line">	7.编辑小src文件夹下的CMakeLists.txt文件：（取消注释）</span><br><span class="line">		C++ 配置:</span><br><span class="line">			L136:add_executable(节点名称 src/C++源文件名.cpp)</span><br><span class="line">L145:add_dependencies(节点名称 $&#123;PROJECT_NAME&#125;节点依赖)：节点依赖对于话题通信为_generate_messages_cpp，对于服务通信为_gencpp，	如果没有自定义文件格式则无需配置</span><br><span class="line">			L149:target_link_libraries(节点名称 $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">如果有多个cpp文件，就要对每个cpp文件都进行上述步骤</span><br><span class="line">		Python 配置:</span><br><span class="line">			L162:catkin_install_python(PROGRAMS scripts/自定义文件名.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)</span><br><span class="line">			//其实可以把python的文化名.py就认为是它的节点名</span><br><span class="line">	8.编写launch启动：</span><br><span class="line">		在小src同级下创建文件夹launch，在其中创建launch文件xxx.launch</span><br><span class="line">		一旦键入&lt;launch&gt;和&lt;/launch&gt;就意味着进行了roscore</span><br><span class="line">		创建一个节点就相当于进行一个rosrun，格式为&lt;node创建节点 pkg=&quot;包名&quot; type=&quot;节点名(c++)/文件名.py(python)&quot; name=&quot;标识名&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">	9.编译执行：（编译执行终端需架设在工作空间下）</span><br><span class="line">		每次重新修改好ros文件，除了ctrl+s之外还需要进行重新编译ctrl+shift+B和重新执行</span><br><span class="line">		重新执行的方法即在vscode终端下输入命令：source ./devel/setup.bash =&gt; roslaunch 包名 launch文件名</span><br><span class="line">//非launch启动时重新执行的命令为source ./devel/setup.bash</span><br><span class="line">		//roslaunch平替多开终端并进行roscore，rosrun 包名 C++节点名/文件名.py的过程</span><br></pre></td></tr></table></figure>
<h1 id="ros文件的基本架构："><a href="#ros文件的基本架构：" class="headerlink" title="ros文件的基本架构："></a>ros文件的基本架构：</h1><p>其中工作空间catkin workspace和大src由mkdir创建，build/devel由catkin_make创建，包名package由create catkin package创建，其下会自动创建inc，src文件夹用于存放c++文件，CMakeLists.txt用于编译c++和python文件，package.xml定义有关软件包的属性（依赖的包和构建工具），文件夹scripts由自己创建用于存放python文件，文件夹launch由自己创建用于存放launch文件用于多启动，文件夹msg由自己创建用于存放msg文件用于规定服务通信下的自定义通讯格式，文件夹srv由自己创建用于存放srv文件用于规定话题通信下的自定义通讯格式。</p>
<h1 id="话题通讯："><a href="#话题通讯：" class="headerlink" title="话题通讯："></a>话题通讯：</h1><p>基于发布订阅模式，一个节点发布消息，另一个节点订阅该消息。常用于不断更新的、少逻辑处理的数据传输场景，如激光雷达的数据采集。<br>话题通讯的理论模型如下：</p>
<p>话题通讯涉及到三个角色:ROS Master (管理者)，Talker (服务端)，Listener (客户端)<br>ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配话题相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Talker 可以发布消息，且发布的消息会被 Listener 订阅。注意事项如下：<br>1.Talker 与 Listener 的启动无先后顺序要求</p>
<ol>
<li>Talker 与 Listener 都可以有多个</li>
<li>Talker 与 Listener 连接建立后，不再需要 ROS Master。即便关闭ROS Master，Talker 与 Listener 照常通信。</li>
</ol>
<p>ROS官方提供的话题通讯基本格式如下：</p>
<p>当使用自定义通讯格式进行话题通讯时，需要进行以下操作：<br>1.定义msg文件：在小src同级下创建msg文件夹并创建xxx.msg文件，在其中以类似结构体的格式输入需要定义的自定义通讯格式构成，例如：<br>string name<br>uint16 age<br>float64 height<br>2.编辑package.xml：<br>这里简单介绍一下package文件的构成，package的核心代码如下：<br>①依赖的构建工具</p>
<p><buildtool_depend>catkin</buildtool_depend><br>②指定构建此软件包所需的软件包 （编译依赖）</p>
<p><build_depend>roscpp</build_depend></p>
<p><build_depend>rospy</build_depend></p>
<p><build_depend>std_msgs</build_depend><br>③指定根据这个包构建库所需要的包（编译外部依赖）</p>
<p><build_export_depend>roscpp</build_export_depend></p>
<p><build_export_depend>rospy</build_export_depend></p>
<p><build_export_depend>std_msgs</build_export_depend><br>④运行该程序包中的代码所需的程序包（执行依赖）</p>
<p><exec_depend>roscpp</exec_depend></p>
<p><exec_depend>rospy</exec_depend></p>
<p><exec_depend>std_msgs</exec_depend><br>我们要在编译依赖中添加<build_depend>message_generation</build_depend><br>在执行依赖中添加<exec_depend>message_runtime</exec_depend><br>3.编辑CMakeLists.txt：<br>L10：取消注释并修改编译依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L51：取消注释并配置msg源文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  xxx.msg</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L71：取消注释使自定义消息格式依赖于 std_msgs：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L108：取消注释并修改执行依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>4.编译：此时C++调用的中间文件位于(…/工作空间/devel/include/包名/xxx.h)<br>Python调用的中间文件位于(…/工作空间/devel/lib/python3/dist-packages/包名/msg/xxx.py)，之后要想使用这一自定义通讯格式就需要包含这个头文件。</p>
<p>代码实现C++话题通讯：<br><em>1.如果使用自定义格式，需要添加c_cpp_properties.json 的 includepath属性如下：<br> “/xxx/yyy工作空间/devel/include/*</em>“ //配置 head 文件的路径<br>2.包含通讯所需格式的头文件：<br>对于ROS官方提供的基本格式需要包含#include “std_msgs/xxx.h”<br>对于自定义的格式需要包含#include “包名/xxx.h”（即自定义格式经编译得到的头文件）<br>3.发布方实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Publisher”);<br>ros::NodeHandle nh;<br>②创建发布者对象：（发布者和订阅者的话题topic需要一致）<br>官方格式：ros::Publisher pub = nh.advertise<std_msgs::xxx>(“topic”, 10);<br>自定义格式：ros::Publisher pub = nh.advertise&lt;包名::xxx&gt;(“topic”, 10);<br>③编辑要发送的数据：<br>创建对象：std_msgs::xxx/包名::xxx msg;<br>4.订阅方实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Publisher”);<br>ros::NodeHandle nh;<br>②创建订阅者对象：<br>官方：ros::Subscriber sub = nh.subscribe<std_msgs::xxx>(“topic”,10,doMsg);<br>自定义：ros::Subscriber sub = nh.subscribe&lt;包名::xxx&gt;(“topic”,10,doMsg);<br>③循环调用回调函数：ros::spin();<br>④搭建回调函数doMsg：void doMsg(const 包名::xxx::ConstPtr &amp;msg){}</p>
<h1 id="服务通信："><a href="#服务通信：" class="headerlink" title="服务通信："></a>服务通信：</h1><p>基于请求响应模式，是一种应答机制，一个节点A向另一个节点B发送请求，B接收处理请求并产生响应结果返回给A，常用于偶然的、对时时性有要求、有一定逻辑处理需求的数据传输场景，例如摄像头数据的采集与访问。</p>
<p>服务通信的理论模型如下:<br>服务通信涉及到三个角色:ROS Master (管理者)，Talker (发布者)，Listener (订阅者)<br>ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配服务相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Client 发送请求信息，而Server 则返回响应信息。注意事项如下:<br>1.客户端请求被处理时，需要保证服务器已经启动（这点与话题通信不同）<br>2.服务端和客户端都可以存在多个<br>同理于话题通信，服务通信也存在自定义通信格式srv，当使用自定义通讯格式进行服务通讯时，需要进行以下操作：<br>1.定义srv文件：在小src同级下创建srv文件夹并创建xxx.srv文件，在其中以类似结构体的格式输入需要定义的自定义通讯格式构成。在 srv 文件中，数据分成请求与响应两部分，之间使用—-分割，例如:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int32 num1			# 客户端请求时发送的两个数字</span><br><span class="line">int32 num2</span><br><span class="line">---</span><br><span class="line">int32 sumCopy		# 服务器响应返回两个数据之和</span><br></pre></td></tr></table></figure><br>2.编辑package.xml：此处需要修改的与话题通信一致，即：<br>在编译依赖中添加<build_depend>message_generation</build_depend><br>在执行依赖中添加<exec_depend>message_runtime</exec_depend><br>3.编辑CMakeLists.txt：<br>L10：取消注释并修改编译依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L58：取消注释并配置srv源文件：（对应于话题通信的L51配置msg源文件）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(</span><br><span class="line">FILES</span><br><span class="line">xxx.srv</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L71：取消注释使自定义消息格式依赖于 std_msgs：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L108：取消注释并修改执行依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>4.编译：此时C++调用的中间文件位于(…/工作空间/devel/include/包名/xxx.h)<br>除了xxx.h外，由于服务通信包含请求方与响应方两部分，故还有xxxRequest.h和xxxResponse.h两个文件。<br>Python调用的中间文件位于(…/工作空间/devel/lib/python3/dist-packages/包名/msg/xxx.py)，之后要想使用这一自定义通讯格式就需要包含这个头文件。</p>
<h1 id="代码实现C-服务通讯："><a href="#代码实现C-服务通讯：" class="headerlink" title="代码实现C++服务通讯："></a>代码实现C++服务通讯：</h1><p><em>1.如果使用自定义格式，需要添加c_cpp_properties.json 的 includepath属性如下：<br> “/xxx/yyy工作空间/devel/include/**” //配置 head 文件的路径<br>2.包含通讯所需格式的头文件：<br>自定义格式需要包含#include “包名/xxx.h”（即自定义格式经编译得到的头文件）<br>3.服务端实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Server”);<br>ros::NodeHandle nh;<br>②创建服务端对象：（服务端和客户端的服务需要一致，服务端不需要泛型）<br>ros::ServiceServer server = nh.advertiseService(“xxx”, doReq);<br>③循环调用回调函数：ros::spin();<br>④搭建回调函数doReq：bool doReq(包名::xxx::Request &amp;request,包名::xxx::Response &amp;response){}用于处理请求并组织响应（Req和Res都有对应对象）<br>4.客户端实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Client”);<br>ros::NodeHandle nh;<br>②创建客户端对象：<br>ros::ServiceClient client = nh.serviceClient&lt;包名::xxx&gt;(“xxx”);<br>③组织请求并处理响应：<br>ServiceCommunication::xxx ai;<br>ai.request/response….<br>bool flag = client.call(ai);
</em>④挂起客户端等待服务端启动：<br>client.waitForExistence();或者ros::service::waitForService(“xxx”);</p>
<h1 id="参数服务器："><a href="#参数服务器：" class="headerlink" title="参数服务器："></a>参数服务器：</h1><p>用于设置、存储和获取静态的非二进制的简单数据，不是为高性能而设计的。<br>参数服务器的理论模型如下：</p>
<p>参数服务器涉及到三个角色:ROS Master (管理者)，Talker (设置者)，Listener (调用者)<br>ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数。<br>在 C++ 中实现参数服务器数据的增删改查，可以通过两套 API 实现:<br>①ros::NodeHandle<br>②ros::param<br>具体的实现方法可以参考代码相关部分<br>值得指出的是，参数服务器本身是随着roscore被一同创建出来的，因而它不需要任何显示的创建方式，且其本身会存储一部分系统创建的静态数据。<br>创建参数的另一种方法是在运行节点命令后加_参数键:=值，例如：<br>rosrun 包名 节点名 _length:=2即创建了一个值为2的参数length</p>
<h1 id="常用的ROS命令行命令："><a href="#常用的ROS命令行命令：" class="headerlink" title="常用的ROS命令行命令："></a>常用的ROS命令行命令：</h1><p>1.文件操作命令：<br>文件操作命令是静态的，操作的是磁盘上的文件<br>roscore：开启ros内核，运行ros程序前必须先开启ros内核<br>rosrun：运行ros节点，格式为：rosrun 包名 C++节点名/文件名.py [传入参数列表]<br>roslaunch：运行launch文件，格式为：roslaunch 包名 launch文件名<br>2.动态运行命令：<br>在ROS程序启动后，动态运行命令可以动态的获取运行中的节点或参数的相关信息，在测试和运行中对程序调试与纠错有重要作用。<br>rosnode：操作ros节点，是用于获取节点信息的命令。<br>rosnode ping 节点名               测试到节点的连接状态<br>rosnode list                        列出活动节点<br>rosnode info 节点名              打印节点信息<br>rosnode machine 设备名        列出指定设备上节点<br>rosnode kill 节点名               杀死某个节点<br>rosnode cleanup                清除不可连接的节点<br>rostopic：操作话题，用于显示调试信息，包括发布者，订阅者，发布频率和ROS消息。<br>rostopic echo 话题名              获取指定话题当前发布的消息（扮演订阅方角色）<br>rostopic hz 话题名                显示话题的发布频率<br>rostopic info 话题名              显示话题信息(消息类型,发布者信息,订阅者信息)<br>rostopic list                       显示所有活动状态下的话题</p>
<p>rostopic pub                     将数据发布到话题（扮演发布方角色）<br>单次发布：rostopic pub /话题名称 消息类型 消息内容<br>连续发布：rostopic pub -r 发布频率 /话题名称 消息类型 消息内容<br>rostopic type 话题名               列出话题的消息类型<br>rosservice：操作ros服务<br>rosservice call服务名              使用提供的参数调用服务（扮演客户端的角色）<br>rosservice call AddInts tabtab<br>rosservice info服务名            打印有关服务的信息<br>rosservice list                    列出所有活动的服务<br>rosservice type服务名            打印服务使用的数据类型<br>rosmsg：操作msg消息，用于话题通信<br>rosmsg info消息名                显示消息信息（包含哪些类型）<br>rosmsg list                        列出所有可用的msg消息类型<br>rossrv：操作srv消息，用于服务通信，方法与rosmsg完全一致<br>rosparam：操作ros 参数，用于参数服务器<br>rosparam set 参数键 值            设置参数<br>rosparam get 参数键                获取参数<br>rosparam delete 参数键           删除参数<br>rosparam list                    列出所有参数<br>rosparam load xxx.yaml           从外部文件加载参数<br>rosparam dump xxx.yaml        将参数写出到外部文件</p>
<h1 id="用小海龟进行复习模拟："><a href="#用小海龟进行复习模拟：" class="headerlink" title="用小海龟进行复习模拟："></a>用小海龟进行复习模拟：</h1><p>启动ros内核：roscore<br>启动海龟图形化界面节点：rosrun turtlesim turtlesim_node<br>启动海龟键盘控制节点：rosrun turtlesim turtle_teleop_key<br>1.话题发布模拟：<br>通过计算图查看话题，启动计算图：rqt_graph（也可以使用rostopic list）</p>
<p>可以看到键盘控制节点和图形化界面节点通过话题/turtle1/cmd_vel通信，并使Publisher键盘控制节点的消息以图形化的形式反馈在Subscriber图形化界面节点的乌龟移动上。<br>此外，我们通过对话题/turtle1/cmd_vel进行信息查询rostopic info /turtle1/cmd_vel<br>可以得到通信双方的节点名称和通信的信息类型为geometry_msgs/Twist</p>
<p>利用rosmsg info geometry_msgs/Twist我们便可以得到该信息的格式如下</p>
<p>其中linear为线速度，angular为角速度，易得对于只能向头朝向移动的2D小海龟，只有linear-x和angular-z的值非零，可以使用rostopic echo /turtle1/cmd_vel验证。<br>如果我们要使海龟做圆周运动，其方法就是向话题发布我们想要的命令，以此替代键盘达到的控制效果，使用rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist “linear: x: 1.0 y: 0.0 z: 0.0    angular: x: 0.0 y: 0.0 z: 1.0” 并修改其值是一个方法。<br>如果用代码实现，则可以创建CirclePublisher.cpp并如下写制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/Twist.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;CirclePublisher&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;</span><br><span class="line">(&quot;/turtle1/cmd_vel&quot;, 10);</span><br><span class="line">ros::Rate rate(10);</span><br><span class="line">geometry_msgs::Twist twist;</span><br><span class="line">twist.linear.x = 1.0f;</span><br><span class="line">twist.linear.y = 0.0f;</span><br><span class="line">twist.linear.z = 0.0f;</span><br><span class="line">twist.angular.x = 0.0f;</span><br><span class="line">twist.angular.y = 0.0f;</span><br><span class="line">twist.angular.z = 1.0f;</span><br><span class="line"></span><br><span class="line">while (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">pub.publish(twist);</span><br><span class="line">rate.sleep();</span><br><span class="line">ros::spinOnce();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.话题订阅模拟：<br>海龟图形化界面节点turtlesim会实时发布当前海龟的位姿和速度<br>对应发布到的话题为/turtle1/pose，使用rostopic info /turtle1/pose可得：</p>
<p>可见通信的信息类型为turtlesim/Pose且其只有发布方而没有订阅方<br>利用rosmsg info turtlesim/Pose得到该信息的格式如下：</p>
<p>值得指出的是坐标的原点是屏幕的左下角，角度变化只在[-π,π]之间变化<br>如果我们要获取当前海龟的位姿和速度信息并打印在屏幕上，其方法就是订阅话题的消息。<br>直接使用ros命令rostopic echo /turtle1/pose订阅是一个方法<br>如果用代码实现，则可以创建PoseSubscriber.cpp并如下写制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;turtlesim/Pose.h&quot;</span><br><span class="line"></span><br><span class="line">void doPose(const turtlesim::Pose::ConstPtr &amp;pose)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;The turtle&#x27;s x=%.2f,y=%.2f,theta=%.2f,linear=%.2f,</span><br><span class="line">angular=%.2f&quot;,pose-&gt;x,pose-&gt;y,pose-&gt;theta,pose-&gt;linear_velocity, 	pose-&gt;angular_velocity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;PoseSubscriber&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::Subscriber sub = nh.subscribe&lt;turtlesim::Pose&gt;(&quot;/turtle1/pose&quot;, 100, 	doPose);</span><br><span class="line">ros::spin();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.服务调用模拟：<br>向turtlesim发送请求，在图形化界面指定位置生成一只新的海龟，这是一个服务请求操作。<br>同样，首要的问题也是找到对应服务的名称，可以使用rosservice list找到/spawn服务<br>使用rosservice info /spawn可得：</p>
<p>可见得到服务的信息分别为提供服务的节点、节点的资源路径、当前服务使用的消息类型和请求服务需要提供的字段（位姿和名字）<br>利用rossrv info turtlesim/Spawn得到该信息的格式如下：</p>
<p>可以看到在请求上述四个参数后服务会响应新海龟的名称<br>同样的，我们可以使用ros命令rosservice call /spawn tabtab进行简单实现。<br>如果用代码实现，则可以创建SpawnService.cpp并如下写制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;turtlesim/Spawn.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;SpawnService&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">ros::ServiceClient client = nh.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;);</span><br><span class="line">turtlesim::Spawn spawn;</span><br><span class="line">spawn.request.x = 1.0f;</span><br><span class="line">spawn.request.y = 4.0f;</span><br><span class="line">spawn.request.theta = 1.57f;</span><br><span class="line">spawn.request.name = &quot;turtle2&quot;;</span><br><span class="line"></span><br><span class="line">ros::service::waitForService(&quot;/spawn&quot;);</span><br><span class="line">bool flag = client.call(spawn);</span><br><span class="line">if (flag)</span><br><span class="line">ROS_INFO(&quot;Success!The new turtle&#x27;s name is %s&quot;, </span><br><span class="line">spawn.response.name.c_str());</span><br><span class="line">else</span><br><span class="line">ROS_INFO(&quot;Failed!&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>4.参数服务器模拟：<br>可以通过修改修改turtlesim的参数服务器中的背景rgb参数来改变海龟图形化界面的背景色，这是一个参数服务器操作。<br>通过rosparam list可以找到控制背景色的三个参数：/turtlesim/background_r/g/b<br>通过rosparam get /turtlesim/background_r/g/b可以得到其值分别为69/86/255<br>可以使用ros命令rosparam set /turtlesim/background_r/g/b 0-255进行修改。<br>值得注意的是，需要将图形化界面重新启动才能产生效果。<br>如果用代码实现，则可以创建SpawnService.cpp并如下写制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;ColorParam&quot;);</span><br><span class="line"></span><br><span class="line">ros::param::set(&quot;/turtlesim/background_b&quot;, 0);</span><br><span class="line">ros::param::set(&quot;/turtlesim/background_g&quot;, 0);</span><br><span class="line">ros::param::set(&quot;/turtlesim/background_r&quot;, 0);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此外，我们还可以在启动节点时直接设置参数，或者通过launch文件传参的方法实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;set_bg&quot; output=&quot;screen&quot;&gt;&lt;rosparam command=&quot;load&quot; file=&quot;$(find demo03_test_parameter)/cfg/color.yaml&quot; /&gt;&lt;/node&gt;</span><br></pre></td></tr></table></figure><br>综合上述内容，我们讲解了ROS中最基本的也是最核心的通信机制实现: 话题通信、服务通信、参数服务器。三种通信机制中，参数服务器是一种数据共享机制，可以在不同的节点之间共享数据，而话题通信与服务通信则可以在不同的节点之间传递数据。<br>对比话题通信与服务通信两者可以看到明显的异同点：<br>二者的实现流程是比较相似的，都是涉及到四个要素:<br>要素1: 消息的发布方/客户端(Publisher/Client)<br>要素2: 消息的订阅方/服务端(Subscriber/Server)<br>要素3: 话题名称(Topic/Service)<br>要素4: 数据载体(msg/srv)<br>可以概括为: 两个节点通过话题关联到一起，并使用某种类型的数据载体实现数据传输。<br>同时，二者的实现也是有本质差异的，具体比较如下:</p>
<p>不同通信机制有一定的互补性，都有各自适应的应用场景。尤其是话题与服务通信，需要结合具体的应用场景与二者的差异，选择合适的通信机制。<br>接下来我们讲一讲ROS常用的API，其中部分已在之前的代码里有体现：<br>1.初始化API：<br>ROS节点的初始化使用ros::init实现：<br>void ros::init(int &amp;argc,char **argv,const std::string&amp; name,uint32 options=0)<br>使用示例：ros::init(argc, argv, “CirclePublisher”);<br>参数列表：argc 传入参数个数<br>           argv 传入参数列表<br>name 节点名称，需要保证其唯一性，不允许包含命名空间<br>options 节点启动选项，ROS中当有同名的节点同时处于运行状态时，先启动      的节点将会被关闭，为了使同名节点也能同时处于运行状态，可以设置options      为ros::init_options::AnonymousName实现，此时同名节点后会产生不同值      的随机数，以此避免重名问题。<br>返回值：void无返回值<br>2.话题与服务API：<br>ROS话题和服务的相关对象使用ros::NodeHandle创建：<br>故首先就要创建节点句柄ros::NodeHandle nh<br>①发布端对象：<br>1&gt;创建发布端对象：调用节点句柄的advertise函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class M&gt;</span><br><span class="line">Publisher advertise(const std::string&amp; topic, uint32_t queue_size, bool latch = false)</span><br><span class="line">使用示例：</span><br><span class="line">ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;, 10);</span><br></pre></td></tr></table></figure><br>泛型：M 话题中发布消息的类型格式<br>参数列表：topic 发布消息使用的话题<br>queue_size 等待发送给订阅者的最大消息数量<br>latch如果为 true,该话题发布的最后一条消息将被保存，并且后期当有订阅者      连接时会将该消息发送给订阅者，适用于发布的一些静态消息，例如导航地图<br>返回值：调用成功时，会返回一个发布端对象ros::Publisher<br>2&gt;发布消息：调用发布端对象的publish函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename M&gt;void publish(const M&amp; message) const</span><br></pre></td></tr></table></figure><br>使用示例：pub.publish(twist);<br>泛型：M 发布的消息message的类型格式<br>参数列表：message 向话题发布的信息，需要与话题中发布消息的类型格式一致<br>返回值：void无返回值<br>②订阅端对象：<br>1&gt;创建订阅端对象：调用节点句柄的subscribe函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class M&gt;</span><br><span class="line">Subscriber subscribe(const std::string&amp; topic, uint32_t queue_size, void(*fp)</span><br><span class="line">(const boost::shared_ptr&lt;M const&gt;&amp;))</span><br></pre></td></tr></table></figure><br>使用示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub = nh.subscribe&lt;turtlesim::Pose&gt;(&quot;/turtle1/pose&quot;, 100, doMsg);</span><br></pre></td></tr></table></figure><br>void doMsg(const 包名::xxx::ConstPtr &amp;msg){}<br>泛型：M 话题中订阅消息的类型格式<br>参数列表：topic 订阅的话题<br>queue_size 消息队列长度，超出长度时，头部的消息将被弃用<br>          fp 当订阅到一条消息时，需要执行的回调函数<br>返回值：调用成功时，会返回一个订阅端对象ros::Subscriber<br>③服务端对象：<br>1&gt;创建服务端对象：调用节点句柄的advertiseService函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class MReq, class MRes&gt;</span><br><span class="line">ServiceServer advertiseService(const std::string&amp; service, bool(*srv_func)</span><br><span class="line">(MReq&amp;, MRes&amp;))</span><br></pre></td></tr></table></figure><br>使用示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros::ServiceServer server = nh.advertiseService(&quot;AddInts&quot;, doReq);</span><br><span class="line">bool doReq(ServiceCommunication::AddInts::Request &amp;request,</span><br><span class="line">ServiceCommunication::AddInts::Response &amp;response)&#123;&#125;</span><br></pre></td></tr></table></figure><br>泛型：MReq 接收客户端消息并做处理的回调函数请求<br>  MRes 接收客户端消息并做处理的回调函数响应<br>参数列表：service 服务的名称<br>srv_func 接收到请求时，需要处理请求的回调函数<br>返回值：调用成功时，会返回一个服务端对象ros::ServiceServer<br>④客户端对象：<br>1&gt;创建客户端对象：调用节点句柄的serviceClient函数实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Service&gt;</span><br><span class="line">ServiceClient serviceClient(const std::string&amp; service_name, bool persistent = false, const M_string&amp; header_values = M_string())</span><br></pre></td></tr></table></figure><br>使用示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::ServiceClient client = nh.serviceClient&lt;ServiceCommunication::</span><br><span class="line">AddInts&gt;(&quot;AddInts&quot;);</span><br></pre></td></tr></table></figure><br>泛型：Service 服务中消息的类型格式<br>参数列表：service_name 服务的名称<br>返回值：调用成功时，会返回一个客户端对象ros::ServiceClient<br>2&gt;调用服务：调用客户端对象的call函数实现<br>template<class Service>bool call(Service&amp; service)<br>使用示例：turtlesim::Spawn spawn;<br>bool flag = client.call(spawn);<br>泛型：Service 调用服务的消息service的类型格式<br>参数列表：service调用服务的消息，需要与服务中消息的类型格式一致<br>返回值：调用成功时返回True，否则返回False<br>3&gt;等待服务函数：使用ros::service或ros::ServiceClient<br>使用示例：ros::service::waitForService(“/spawn”);<br>client.waitForExistence();<br>3.回旋函数API：<br>ROS中使用了 ros::spin() 和 ros::spinOnce() 两个回旋函数用于处理回调函数。<br>回调函数是一个在特定事件或条件发生时被调用的函数。它的主要目的是允许软件组件之间进行异步通信，即一个组件可以在某个特定事件发生时通知另一个组件，<br>回调函数通常作为参数传递给另一个函数，以便在需要时被调用。这个被传递的函数通常被称为回调函数，而调用回调函数的函数则被称为调用方。回调函数的一个关键特点是它们通常在编写代码时被定义，但在稍后的某个时间点被调用。这种延迟调用的特性使得回调函数在异步编程和事件驱动编程中非常有用。<br>ros::spin() 和 ros::spinOnce()二者都用于处理回调函数，但ros::spin()会循环执行回调函数，而 ros::spinOnce() 只会执行一次回调函数，在 ros::spin() 后的语句不会执行到，而 ros::spinOnce() 后的语句可以执行。<br>4.时间API：<br>ROS中时间相关的API极其常用，比如获取当前时刻、持续时间的设置、执行频率、休眠、定时器等都与时间相关。<br>①初始化节点ros::init并创建句柄ros::NodeHandle：<br>调用时间API前必须初始化节点并创建句柄，否则时间无法初始化导致后续API调用失败<br>ros::init(argc,argv,”RosTime”);<br>ros::NodeHandle nh;<br>②得到时刻对象：ros::Time是时刻对象，其中封装了很多内容而不单单是一个时刻值，使用ros::Time::now()获取当前时刻的对象：ros::Time right_now = ros::Time::now();<br>或是使用初始化函数设置一个时刻对象，传入参数为要设置的时刻值，例如：<br>ros::Time someTime(100.3);<br>值得注意的是，当前时刻的表示为时间戳，即离1970.1.1 00:00:00的秒数<br>③获取时间间隔对象：ros::Duration是时间间隔对象，其中也封装了很多内容。<br>可以使用初始化函数设置一个时间间隔对象，传入参数为要设置的时间间隔值，例如：<br>ros::Duration du(10);<br>④获取当前的时刻值：使用ros::Time对象的toSec()方法，例如：<br>someTime.toSec()    //double类型，可以打印得到其值为100.3<br>⑤休眠相当于时间间隔对象值的时间：使用ros::Duration对象的sleep()方法，例如：<br>du.sleep();    //相当于使程序休眠10s再继续执行接下来的内容<br>⑥时间间隔对象和时刻对象可以进行相加减，其中两个时刻对象只能相减，其返回值仍为一时刻对象；而两个时间间隔对象可以任意相加减，其返回值仍为一时间间隔对象；值得注意的是，时间间隔对象和时刻对象之间也可以任意相加减，而其返回值为一时刻对象。<br>⑦设置运行频率：使用ros::Rate对象的sleep方法实现<br>ros::Rate rate(10);    //初始化ros::Rate对象，指定频率为10Hz<br>while (true)<br>{<br>ROS_INFO(“——————-“);<br>rate.sleep();    //休眠，休眠时间为0.1s，变相即设置运行频率为10H<br>}<br>⑧定时器：ROS 中内置了专门的定时器ros::Timer，可以实现与 ros::Rate类似的效果<br>Timer createTimer(Duration period, const TimerCallback&amp; callback, bool oneshot = false,bool autostart = true) const;<br>使用示例：ros::Timer timer = nh.createTimer(ros::Duration(0.5),doSomeThing);<br>void doSomeThing(const ros::TimerEvent &amp;event){<br>      ROS_INFO(“event:%s”,std::to_string(event.current_real.toSec()).c_str());<br>}</p>
<p>参数列表：period 时间间隔对象，表示定时器的时间间隔<br>callback 回调，当定时器的时间间隔完成后调用，输入为时间事件TimerEvent<br>oneshot 如果设置为 true,只执行一次回调函数，设置为 false,就循环执行。<br>autostart 如果为true，返回已经启动的定时器,设置为 false，需要手动启动，<br>即在代码对应的启动位置调用ros::Timer的start()方法，例如timer.start()<br>由于回调函数的存在， ros::spin()显然也是要添加的<br>5.关闭节点API：使用ros::shutdown()实现<br>除了代码实现，当节点接收到了关闭信息(ctrl + c等)或同名节点启动也会导致节点关闭<br>6.日志输出API：除了ROS_INFO之外，还有以下几种日志输出API<br>ROS_DEBUG(“hello,DEBUG”); //调试信息，不会输出到控制台<br>ROS_INFO(“hello,INFO”);     //标准消息，说明系统内正在执行的操作，白色字体<br>ROS_WARN(“Hello,WARN”);  //警告信息，程序存在异常但仍然可以执行，黄色字体<br>ROS_ERROR(“hello,ERROR”); //错误信息，此类错误会影响程序运行，红色字体<br>ROS_FATAL(“hello,FATAL”);   //严重错误，此类错误将阻止节点继续运行，红色字体</p>
<h1 id="自定义头文件、源文件和可执行文件的调用："><a href="#自定义头文件、源文件和可执行文件的调用：" class="headerlink" title="自定义头文件、源文件和可执行文件的调用："></a>自定义头文件、源文件和可执行文件的调用：</h1><p>当功能包由头文件和源文件组成，其中源文件和可执行文件为同一文件时，为了使源文件定义头文件的声明，需要包含头文件，格式为#include “../include/包名/头文件.h”。为了包含头文件时不抛出异常，可以配置.vscode 下 c_cpp_properties.json 的 includepath属性加上”/home/用户/工作空间/src/功能包/include/**”，可以通过pwd得到。<br>此时.h和.cpp的编写不做赘述，主要看一下CMakeLists.txt的配置：<br>为了完成头文件的配置，需要把L119的注释去掉：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">include</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>源文件的配置仍然不变，即add_executable,add_dependencies,target_link_libraries<br>当功能包由头文件、源文件和可执行文件共同组成时（即源文件只进行对头文件声明的定义，可执行文件才是程序入口），在CMakeLists.txt的配置上又有所不同：<br>为了完成头文件的配置，需要把L119的注释去掉：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">include</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>为了完成头文件和源文件的联立配置，需要声明一套C++库：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_library(库名</span><br><span class="line">  include/包名/头文件.h</span><br><span class="line">  src/源文件.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>接着将这个新声明的自定义库添加依赖和链接库：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_dependencies(库名 $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; </span><br><span class="line">$&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line">target_link_libraries(库名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>最后是可执行文件，仍为add_executable,add_dependencies,target_link_libraries<br>不同点在于配置链接库时需要添加之前新声明的自定义库：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(use_head</span><br><span class="line">  库名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h1 id="ROS元功能包："><a href="#ROS元功能包：" class="headerlink" title="ROS元功能包："></a>ROS元功能包：</h1><p>完成ROS中一个系统性的功能可能涉及到多个功能包，比如机器人导航模块下有地图、定位、路径规划等不同的子级功能包。为此，ROS中提供了一种方式可以将不同的功能包打包成一个具有相同工作目标的功能包集合，这个集合就是元功能包(metapackage)。<br>元功能包是ROS中的一个虚包，里面没有实质性的内容，但是它依赖了其他的软件包，通过这种方法可以把其他包组合起来，我们可以认为它是一本书的目录索引，告诉我们这个包集合中有哪些子包。<br>创建ROS元功能包的方法如下：<br>首先新建一个包，作为虚包，只需要包名而不需要依赖(roscpp rospy std_msgs)<br>然后:修改package.xml ,内容如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;exec_depend&gt;被集成的功能包&lt;/exec_depend&gt;</span><br><span class="line">.....</span><br><span class="line">&lt;export&gt;</span><br><span class="line">  &lt;metapackage /&gt;</span><br><span class="line">&lt;/export&gt;</span><br></pre></td></tr></table></figure><br>最后:修改 CMakeLists.txt,内容如下:<br>cmake_minimum_required(VERSION 3.0.2)<br>project(xxx)<br>find_package(catkin REQUIRED)<br>catkin_metapackage()<br>注意，所有的其他东西包括注释全都不要，只留这四行</p>
<h1 id="Launch文件的使用："><a href="#Launch文件的使用：" class="headerlink" title="Launch文件的使用："></a>Launch文件的使用：</h1><p>一个程序中可能需要启动多个节点，比如ROS内置的小乌龟案例，如果要控制乌龟运动，要启动roscore、乌龟界面节点、键盘控制节点。如果每次都调用 rosrun 逐一启动，显然效率低下，采用的优化策略便是使用roslaunch 命令集合 launch 文件启动管理节点。并且在后续教程中，也多次使用到了 launch 文件。<br>launch 文件是一个 XML 格式的文件，可以启动本地和远程的多个节点，还可以在参数服务器中设置参数，它可以简化节点的配置与启动，从而提高ROS程序的启动效率。<br>0.XML文件的基本格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">一个XML文档由一个或多个元素构成，一个元素又可以包含属性和内容两部分。元素是XML文档的基本结构单元，由开始标签和结束标签组成。元素可以包含子元素，也可以包含内容。开始标签用&lt;xxx&gt;表示，结束标签为开始标签加/组成&lt;/xxx&gt;。例如&lt;element&gt;数据&lt;/element&gt;，其中数据就是element元素的内容或子元素。</span><br><span class="line">元素也可以包含属性，属性用于提供关于元素的附加信息。属性出现在元素的开始标签中，位于元素名称之后，以等号（=）分隔属性名称和属性值。例如：&lt;element 属性名=&quot;属性值&quot;&gt;数据&lt;/element&gt;。如果一个元素在定义时不包含任何文本内容或其他子元素，则称其为自闭合元素，此时可以将语句简化为&lt;element 数据 /&gt; 。</span><br><span class="line">1.以 turtlesim 为例演示Launch文件的使用方法：</span><br><span class="line">1&gt;新建launch文件</span><br><span class="line">在功能包下添加 launch目录, 目录下新建 xxxx.launch 文件，编辑 launch 文件</span><br><span class="line">&lt;launch&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;myTurtle&quot; </span><br><span class="line">output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot;</span><br><span class="line">name=&quot;myTurtleContro&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br><span class="line">2&gt;调用 launch 文件</span><br><span class="line">roslaunch 包名 xxx.launch</span><br><span class="line">注意:roslaunch 命令执行launch文件时会自动启动roscore</span><br><span class="line">2.launch标签：</span><br><span class="line">&lt;launch&gt;标签是所有launch文件的根标签，充当其他标签的容器</span><br><span class="line">属性：deprecated = &quot;弃用声明&quot;，告知用户当前 launch 文件已经弃用</span><br><span class="line">子标签：所有其它标签都是launch的子标签</span><br><span class="line">示例：&lt;launch deprecated=”此文件已被弃用”&gt;</span><br><span class="line">&lt;node...&gt;</span><br><span class="line">&lt;/launch&gt;</span><br><span class="line">3.node标签：</span><br><span class="line">&lt;node&gt;标签用于指定ROS节点，但roslaunch命令不能保证按照node的声明顺序来启动节点，因为节点的启动是多进程的。</span><br><span class="line">属性：pkg=&quot;包名&quot;，确定节点所属的包名</span><br><span class="line">type=&quot;节点名&quot;，确定节点名(CMakeLists中定义的名称)</span><br><span class="line">name=&quot;节点称号”，确定节点称号(ros::init中定义的网络拓扑称号)</span><br><span class="line">output=&quot;log | screen&quot; (可选)，日志发送目标，可以设置为日志文件或屏幕</span><br><span class="line">args=&quot;xxx xxx xxx&quot; (可选)，将参数传递给节点，中间用空格分隔</span><br><span class="line">machine=&quot;机器名&quot;，在指定机器上启动节点</span><br><span class="line">respawn=&quot;true | false&quot; (可选)，如果节点意外退出，是否自动重启</span><br><span class="line">respawn_delay=&quot; N&quot; (可选)，如果respawn=true, 那么延迟 N 秒后启动节点</span><br><span class="line">required=&quot;true | false&quot; (可选)，该节点是否必须，如果为true,那么如果该节点	  退出，将杀死整个roslaunch</span><br><span class="line">ns=&quot;xxx&quot; (可选)，在指定命名空间xxx中启动节点，此时如果使用rosnode list	  查看的话，该节点的路径将会变为/xxx/节点名</span><br><span class="line">子标签：remap 重映射节点名称</span><br><span class="line">rosparam 参数设置</span><br><span class="line">param 参数设置</span><br><span class="line">示例：&lt;launch&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;myTurtle&quot; </span><br><span class="line">output=&quot;screen&quot; /&gt;</span><br><span class="line">  &lt;/launch&gt;</span><br><span class="line">4.include标签：</span><br><span class="line">如果不同的launch文件之间需要启动相同的节点，可以使用&lt;include&gt;标签将另一个xml格式的 launch 文件导入到当前文件，以此优化代码文件，实现代码复用，同时在当前文件下还可以在导入文件的基础上增加节点。</span><br><span class="line">属性：file=&quot;$(find 包名)/xxx(通常为launch)/xxx.launch&quot;，要包含的文件路径</span><br><span class="line">ns=&quot;xxx&quot; (可选)，在指定命名空间导入文件</span><br><span class="line">子标签：arg	将参数传递给被包含的文件</span><br><span class="line">示例：&lt;launch&gt;</span><br><span class="line">&lt;include file=&quot;$(find launch01_basic)launch/StartTurtle.launch&quot; /&gt;</span><br><span class="line">  &lt;/launch&gt;</span><br><span class="line">5.remap标签：</span><br><span class="line">用于话题重命名，以此改变节点订阅的话题</span><br><span class="line">属性：from=&quot;xxx&quot;，原始话题名称</span><br><span class="line">to=&quot;yyy&quot;，目标话题名称</span><br><span class="line">子标签：无</span><br><span class="line">示例：&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">&lt;remap from=&quot;/turtle1/cmd_vel&quot; to=&quot;/cmd_vel&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line">6.param标签：</span><br><span class="line">&lt;param&gt;标签主要用于在参数服务器上设置参数，参数源可以在标签中通过 value 指定，也可以通过外部文件加载。&lt;param&gt;标签可以放在&lt;launch&gt;下在可以放在&lt;node&gt;下，&lt;launch&gt;下相当于公有参数，&lt;node&gt;下相当于节点的私有参数。</span><br><span class="line">可以使用rosparam list查看设置的变量及其所在的位置。</span><br><span class="line">属性：name=&quot;命名空间/参数名&quot;，参数名称，可以包含命名空间</span><br><span class="line">value=&quot;xxx&quot; ，定义参数值</span><br><span class="line">type=&quot;str | int | double | bool&quot;，指定参数类型</span><br><span class="line">子标签：无</span><br><span class="line">示例：&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot; 		  output=&quot;screen&quot;&gt;</span><br><span class="line">&lt;param name=&quot;ParamB&quot; type=&quot;double&quot; value=&quot;3.14&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line">7.rosparam标签：</span><br><span class="line">&lt;rosparam&gt;标签可以从YAML文件导入参数，或将参数导出到 YAML文件，也可以用来删除参数，同样，&lt;rosparam&gt;也可以放在&lt;launch&gt;或者&lt;node&gt;下。</span><br><span class="line">YAML是一种数据序列化格式，用来确定数据组、名称及其对应的值。它使用缩进表示层级，</span><br><span class="line">由键值对组成数据，键和值之间以冒号分隔，且冒号后面必须有一个空格。</span><br><span class="line">属性：command=&quot;load | dump | delete&quot;，加载、导出或删除参数</span><br><span class="line">file=&quot;$(find 包名)/xxx/yyy....&quot;，加载或导出到的 yaml 文件，加载导出用</span><br><span class="line">需要注意的是，导出文件需要和调用文件分开，否则无法保证参数均被存储</span><br><span class="line">param=&quot;参数名称&quot;，删除参数用</span><br><span class="line">ns=&quot;命名空间&quot; (可选)</span><br><span class="line">子标签：无</span><br><span class="line">示例：</span><br><span class="line">&lt;rosparam command=&quot;load&quot; file=&quot;$(find RosLaunch)/launch/params.yaml&quot; /&gt;</span><br><span class="line">&lt;rosparam command=&quot;dump&quot; file=&quot;$(find RosLaunch)/launch/param.yaml&quot;/&gt;</span><br><span class="line">&lt;rosparam command=&quot;delete&quot; param=”bg_B”/&gt;</span><br><span class="line">8.group标签：</span><br><span class="line">&lt;group&gt;标签可以对节点分组，具有 ns 属性，可以让节点归属某个命名空间，从而实现节点的聚类。此外，将同名节点归于不同的命名空间可以避免重名问题。</span><br><span class="line">通过rosnode list可以发现同名节点之前附加上了命名空间路径从而实现区分。</span><br><span class="line">属性：ns=&quot;名称空间&quot; (可选)</span><br><span class="line">子标签：除了launch 标签外的其他标签</span><br><span class="line">示例：&lt;group ns=&quot;first&quot;&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;my_turtle&quot; 	 	  output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;/group&gt;</span><br><span class="line">9.arg标签：</span><br><span class="line">&lt;arg&gt;标签是用于动态传参，类似于函数的参数，可以增强launch文件的灵活性</span><br><span class="line">属性：name=&quot;参数名称&quot;，在launch文件中可以使用$(arg name)表示对应的参数值</span><br><span class="line">default=&quot;默认值&quot;，不传参时的参数默认值</span><br><span class="line">子标签：无</span><br><span class="line">传参方法：在roslaunch语句后添加键值对roslaunch 包名 xxx.launch yyy:=值</span><br><span class="line">示例：&lt;arg name=&quot;test&quot; default=”0.5” /&gt;</span><br><span class="line">      &lt;param name=&quot;param&quot; value=&quot;$(arg test)&quot; /&gt;</span><br><span class="line">  roslaunch RosLaunch arg.launch car_length:=0.6</span><br></pre></td></tr></table></figure></p>
<h1 id="重名问题："><a href="#重名问题：" class="headerlink" title="重名问题："></a>重名问题：</h1><p>1.功能包重名：<br> 虽然特定工作空间内的功能包不能重名，但是自定义工作空间的功能包与内置的功能包可以重名或者不同的自定义的工作空间中也可以出现重名的功能包，那么调用该名称功能包时，会调用哪一个呢？比如：自定义工作空间A存在功能包 turtlesim，自定义工作空间B也存在功能包 turtlesim，当然系统内置空间也存在turtlesim，如果调用turtlesim包，会调用哪个工作空间中的呢？<br>ROS会将当前启用的所有工作空间存放在环境变量ROS_PACKAGE_PATH中，通过查看echo $ROS_PACKAGE_PATH可以得到一个工作空间顺序，当不同工作空间的功能包重名时，会按照 ROS_PACKAGE_PATH 查找，并优先执行顺序在前的工作空间下的功能包，这被称为ROS的工作空间覆盖。<br>工作空间覆盖问题显然存在安全隐患，比如当前工作空间B优先级更高，意味着当程序调用 turtlesim 时，不会调用工作空间A也不会调用系统内置的 turtlesim，如果工作空间A在实现时有其他功能包依赖于自身的 turtlesim，而按照ROS工作空间覆盖的涉及原则，那么实际执行时将会调用工作空间B的turtlesim，从而导致执行异常。<br>ROS对于功能包重名暂无解决方法，故应选择主动避免。<br>2.节点重名：<br>在ROS中如果启动重名节点的话，之前已经存在的节点会被直接关闭，但是如果确实有这种需求，ROS提供了使用命名空间或名称重映射（起别名）的解决方法。要实现这两种解决办法还各有三种实现途径，分别是使用rosrun命令，修改launch文件或编码实现。<br>①使用rosrun命令：<br>1&gt;使用命名空间：rosrun 包名 同名节点 <strong>ns:=工作空间<br>2&gt;名称重映射:rosrun 包名 同名节点 </strong>name:=别名<br>3&gt;上述两种方法可以叠加：rosrun 包名 同名节点 <strong>ns:=工作空间 </strong>name:=别名<br>4&gt;观察修正结果：使用rosnode list，使用命名空间会在节点前加前缀，使用名称重映射则会直接将节点改名。<br>②修改launch文件：<br>介绍launch文件的使用语法时曾经讲过，在node标签中有name和ns两个属性，二者分别用于实现节点名称重映射与设置命名空间。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&gt;使用命名空间：&lt;node pkg=&quot;包名&quot; type=&quot;同名节点&quot; ns=&quot;工作空间&quot;/&gt;</span><br><span class="line">2&gt;名称重映射：&lt;node pkg=&quot;包名&quot; type=&quot;同名节点&quot; name=&quot;别名&quot; /&gt;</span><br><span class="line">3&gt;叠加：&lt;node pkg=&quot;包名&quot; type=&quot;同名节点&quot; name=&quot;别名&quot; ns=&quot;工作空间&quot;/&gt;</span><br></pre></td></tr></table></figure><br>③编码实现：<br>1&gt;使用命名空间：在代码初始化ROS节点时补充设置为节点添加时间戳后缀<br>ros::init(argc,argv,”xxx”,ros::init_options::AnonymousName);<br>3.话题重名：<br>ROS不同的节点之间通信都依赖于话题，话题名称也可能出现重复的情况。这种情况下，系统虽然不会抛出异常，但是可能导致订阅的消息非预期的，从而导致节点运行异常。这种情况下需要将两个节点的话题名称由相同修改为不同。<br>又或者，两个节点的话题名称虽然相同，但位于不同的工作空间下导致通信失败。这种情况下需要将两个节点的话题名称由不同修改为相同。<br>其解决方法仍然是话题名称重映射或为名称添加前缀。特殊的，对于话题而言，为名称添加前缀有全局、相对和私有三种方法。使用rostopic list查看话题，其中全局话题表示为/话题名，相对话题表示为/命名空间/话题名，私有话题表示为/命名空间/节点名/话题名<br>①使用rosrun命令：rosrun 包名 节点名 原话题名:=新话题名</p>
<p>②修改launch文件：使用node节点的remap属性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=”包名” type=”节点名” name=&quot;xxx&quot;&gt;</span><br><span class="line">    &lt;remap from=&quot;原话题名&quot; to=&quot;新话题名&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br></pre></td></tr></table></figure><br>③编码实现：<br>1&gt;全局话题：话题名以/开头，此时话题全名和节点名称无关<br>例如ros::Publisher pub = nh.advertise<std_msgs::String>(“/chatter”,1000);<br>此时话题全名为/chatter<br>2&gt;相对话题：话题名以非/开头，此时话题全名位于节点所在工作空间下与节点平齐<br>例如ros::Publisher pub = nh.advertise<std_msgs::String>(“chatter”,1000);<br>此时话题全名为/节点所处的工作空间名/chatter<br>2&gt;私有话题：节点句柄添加”~”元素时以非/开头的话题名<br>例如：ros::NodeHandle nh(“~”);<br>ros::Publisher pub = nh.advertise<std_msgs::String>(“chatter”,1000);<br>  此时话题全名为/节点所处的工作空间名/节点名/chatter<br>4.参数名称重名：<br>同理在ROS中参数名称也可能重名。关于参数重名的处理没有重映射实现，为了尽量的避免参数重名，都是使用为参数名添加前缀的方式，实现类似于话题名称，有全局、相对和私有三种类型之分。<br>①使用rosrun命令： rosrun 包名 节点名 _参数名:=参数值<br>值得注意的是，rosrun执行设置参数参数名使用的是私有类型。<br>②修改launch文件：在node标签外或内通过param标签来设置参数。在node标签外设置的参数是全局性质的，参数全名是/参数名，在node标签中设置的参数是私有性质的，参数全名是/命名空间/节点名称/参数名。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;param name=&quot;p1&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;t1&quot;&gt;</span><br><span class="line">  &lt;param name=&quot;p2&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br></pre></td></tr></table></figure><br>此时参数全名分别是 /p1和 /xxx/p2<br>③编码实现：<br>1&gt;全局变量：变量名以/开头，此时变量全名和节点名称无关<br>例如：ros::param::set(“/set_A”,100);<br>此时话题全名为/set_A<br>2&gt;相对变量：变量名以非/开头，此时变量全名位于节点所在工作空间下与节点平齐<br>例如：ros::param::set(“set_B”,100);<br>此时话题全名为/节点所处的工作空间名/set_B<br>3&gt;私有变量：变量名以~开头，此时变量全名位于节点下<br>例如：ros::param::set(“~set_C”,100);<br>  此时话题全名为/节点所处的工作空间名/节点名/set_C</p>
<h1 id="分布式通信："><a href="#分布式通信：" class="headerlink" title="分布式通信："></a>分布式通信：</h1><p>一个运行中的ROS系统可以包含分布在多台计算机上多个节点。如果要实现不同计算机间不同节点的通信，我们需要进行以下几步：<br>1.保证不同计算机处于同一网络中，最好分别设置固定IP。<br>2.配置文件修改：<br>分别修改不同计算机的 /etc/hosts 文件，在该文件中加入对方的IP地址和计算机名:<br>主机端:从机的IP    从机计算机名；从机端:主机的IP    主机计算机名<br>设置完毕，可以通过 ping 命令测试网络通信是否正常。<br>注：IP地址查看: ifconfig / 计算机名称查看: hostname<br>3.配置主机IP：向~/.bashrc中追加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ROS_MASTER_URI=http://主机IP:11311</span><br><span class="line">export ROS_HOSTNAME=主机IPCopy</span><br></pre></td></tr></table></figure><br>4.配置从机IP：向~/.bashrc中追加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ROS_MASTER_URI=http://主机IP:11311</span><br><span class="line">export ROS_HOSTNAME=从机IPCopy</span><br></pre></td></tr></table></figure><br>5.测试方法：主机启动roscore，而后双方分别启动节点测试通信是否正常即可</p>
<h1 id="ROS坐标变换TF："><a href="#ROS坐标变换TF：" class="headerlink" title="ROS坐标变换TF："></a>ROS坐标变换TF：</h1><p>机器人系统上，有多个传感器，如激光雷达、摄像头等，有的传感器是可以感知机器人周边的物体方位的，以协助机器人定位障碍物。可以直接将物体相对该传感器的方位信息，等价于物体相对于机器人系统或机器人其它组件的方位信息吗？显示是不行的，这中间需要一个转换过程，为此ROS提供了坐标变换模块TF来实现这个功能。<br>1.先介绍一下四元数的概念，四元数是由实部和虚部组成的扩展复数，一个四元数可以表示为 q = w + xi + yj + zk，其中 w 是实部，(x, y, z) 是虚部对应的旋转轴上的分量。通过四元数可以方便地表示旋转操作，一个四元数 q 可以表示为 q = cos(θ/2) + u <em> sin(θ/2)，其中 θ 是旋转角度，u 是单位旋转轴向量。例如，对于绕以 (1, 0, 0) 为轴，角度为 π/2 的旋转操作，可以构建四元数 q = cos(π/4) + i </em> sin(π/4)。四元数本身可以克服欧拉角带来的万向死锁问题。<br>2.ROS的坐标变化基于订阅发布模型，其对应的msg有：<br>geometry_msgs/TransformStamped和geometry_msgs/PointStamped<br>其中前者用于传输坐标系间的相对位置信息，后者用于传输某个坐标系内坐标点相对于原点的信息。在坐标变换中，频繁的需要使用到坐标系的相对关系以及坐标点信息。<br>1&gt;geometry_msgs/TransformStamped（坐标系间的相对位置信息）：<br>利用rosmsg info geometry_msgs/TransformStamped可以查看其包含以下内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header                  	//头信息</span><br><span class="line">  uint32 seq                                	//序列号</span><br><span class="line">  time stamp                                	//时间戳</span><br><span class="line">  string frame_id                           	//父坐标ID（创建）</span><br><span class="line">string child_frame_id                    	//子坐标ID（创建）</span><br><span class="line">geometry_msgs/Transform transform       //父子坐标的相对位置信息</span><br><span class="line">  geometry_msgs/Vector3 translation        	//子坐标相对于父坐标间的偏移</span><br><span class="line">    float64 x                                		//X方向</span><br><span class="line">    float64 y                                		//Y方向</span><br><span class="line">    float64 z                                		//Z方向</span><br><span class="line">  geometry_msgs/Quaternion rotation        	//子坐标相对于父坐标间的旋转</span><br><span class="line">    float64 x                                	//用四元数表示</span><br><span class="line">    float64 y                                </span><br><span class="line">    float64 z                                </span><br><span class="line">    float64 w</span><br></pre></td></tr></table></figure><br>2&gt;geometry_msgs/PointStamped（坐标点相对于原点的信息）：<br>利用rosmsg info geometry_msgs/PointStamped可以查看其包含以下内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header               	//头信息</span><br><span class="line">  uint32 seq                               		//序列号</span><br><span class="line">  time stamp                                	//时间戳</span><br><span class="line">  string frame_id                            	//所属坐标系的ID（查询）</span><br><span class="line">geometry_msgs/Point point                //坐标点相对于原点的偏移</span><br><span class="line">  float64 x                                		//X方向</span><br><span class="line">  float64 y										//Y方向</span><br><span class="line">  float64 z										//Z方向</span><br></pre></td></tr></table></figure><br>3.静态坐标变换（两个坐标系之间的相对位置固定）：<br>发布与订阅关系：坐标系的相对关系通过发布方发布，订阅方订阅发布的坐标系相对关系，再传入坐标点信息，然后借助于tf实现坐标变换，并将结果输出。<br>代码实现：<br>①创建项目功能包：<br>包括tf2 tf2_ros tf2_geometry_msgs roscpp rospy std_msgs geometry_msgs<br>②发布方实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;tf2_ros/static_transform_broadcaster.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/TransformStamped.h&quot;</span><br><span class="line">#include &quot;tf2/LinearMath/Quaternion.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;StaticTfPublisher&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建发布者对象</span><br><span class="line">tf2_ros::StaticTransformBroadcaster pub;</span><br><span class="line">// 组织被发布的消息：父子坐标系及其相对关系</span><br><span class="line">geometry_msgs::TransformStamped tfs;</span><br><span class="line">tfs.header.stamp = ros::Time::now();</span><br><span class="line">tfs.header.frame_id = &quot;base_link&quot;;</span><br><span class="line">tfs.child_frame_id = &quot;laser&quot;;</span><br><span class="line">tfs.transform.translation.x = 0.2;</span><br><span class="line">tfs.transform.translation.y = 0.0;</span><br><span class="line">tfs.transform.translation.z = 0.5;</span><br><span class="line">// 将欧拉角变为四元数</span><br><span class="line">tf2::Quaternion qtn;</span><br><span class="line">qtn.setRPY(0, 0, 0);</span><br><span class="line">tfs.transform.rotation.x = qtn.getX();</span><br><span class="line">tfs.transform.rotation.y = qtn.getY();</span><br><span class="line">tfs.transform.rotation.z = qtn.getZ();</span><br><span class="line">tfs.transform.rotation.w = qtn.getW();</span><br><span class="line">// 发布数据</span><br><span class="line">pub.sendTransform(tfs);</span><br><span class="line">// spin()回调</span><br><span class="line">ros::spin();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">③订阅方实现：</span><br><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;tf2_ros/transform_listener.h&quot;</span><br><span class="line">#include &quot;tf2_ros/buffer.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/PointStamped.h&quot;</span><br><span class="line">#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;StaticTfSubscriber&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建buffer和坐标变换监听对象，用于存储订阅得到的数据</span><br><span class="line">tf2_ros::Buffer buffer;</span><br><span class="line">tf2_ros::TransformListener listener(buffer);</span><br><span class="line">// 组织一个PointStamped对象表示在laser坐标系下的坐标</span><br><span class="line">geometry_msgs::PointStamped ps;</span><br><span class="line">ps.header.frame_id = &quot;laser&quot;;</span><br><span class="line">ps.header.stamp = ros::Time::now();</span><br><span class="line">ps.point.x = 2.0;</span><br><span class="line">ps.point.y = 3.0;</span><br><span class="line">ps.point.z = 5.0;</span><br><span class="line">ros::Rate rate(10);</span><br><span class="line">while (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">//try-catch避免缓存接收延迟而导致坐标转换失败</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">// 组织一个PointStamped对象表示在base_link坐标系下的坐标</span><br><span class="line">geometry_msgs::PointStamped ps_out;</span><br><span class="line">ps_out = buffer.transform(ps, &quot;base_link&quot;);</span><br><span class="line">// 得到结果并输出</span><br><span class="line">ROS_INFO(&quot;TF according to %s is:(%2f,%2f,%2f)&quot;,</span><br><span class="line">ps_out.header.frame_id.c_str(),</span><br><span class="line">ps_out.point.x,</span><br><span class="line">ps_out.point.y,</span><br><span class="line">ps_out.point.z);</span><br><span class="line">&#125;</span><br><span class="line">catch (const std::exception &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;Error:%s&quot;, e.what());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rate.sleep();</span><br><span class="line">ros::spinOnce();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>④总结：<br>可以看到此时发布方发布坐标间的相对位置关系，订阅方借助自身得到的以某一坐标系为基准的坐标值去订阅话题以实现TF坐标转换到另一坐标系为基准的坐标值。<br>⑤补充：<br>1&gt;ROS本身封装了专门的节点用于实现静态坐标系相对关系信息的发布，借助命令：<br>rosrun tf2_ros static_transform_publisher x偏移量 y偏移量 z偏移量 偏航角度 俯仰角度 翻滚角度 父级坐标系 子级坐标系<br>可以实现发布方代码的全流程，即发布父子坐标系的名字以及之间的相对关系<br>2&gt;可以借助于rviz来实现以图形化的形式显示坐标系关系，具体操作如下：<br>输入命令rviz后设置Fixed Frame为base_link;<br>点击左下的 add 按钮，在弹出的窗口中选择 TF 组件，即可显示坐标关系。<br>3&gt;使用rosrun tf2_tools view_frames.py可以生成坐标系树状关系结构的pdf<br>4.动态坐标变换（两个坐标系之间的相对位置不再固定）：<br>以turtlesim为例，该节点中窗体有一个世界坐标系(左下角为坐标系原点)，而乌龟本身为另一个坐标系，由于乌龟是可以运动的，所以世界坐标系与乌龟坐标系之间的相对位置不固定。假设有一个点相对于乌龟坐标系的值已知，那么把该点转换为世界坐标系的过程就是动态坐标变换。订阅 turtle1/pose,可以获取乌龟在世界坐标系的 x坐标、y坐标、偏移量以及线速度和角速度。<br>代码实现：<br>①创建项目功能包：<br>包括tf2 tf2_ros tf2_geometry_msgs roscpp rospy std_msgs geometry_msgs<br>②发布方实现：<br>void doPose(const turtlesim::Pose::ConstPtr &amp;pose)<br>{<br>static tf2_ros::TransformBroadcaster pub;<br>geometry_msgs::TransformStamped ts;<br>ts.header.frame_id = “world”;<br>ts.header.stamp = ros::Time::now();<br>ts.child_frame_id = “turtle1”;<br>ts.transform.translation.x = pose-&gt;x;<br>ts.transform.translation.y = pose-&gt;y;<br>ts.transform.translation.z = 0;<br>tf2::Quaternion qtn;<br>qtn.setRPY(0, 0, pose-&gt;theta);<br>ts.transform.rotation.x = qtn.getX();<br>ts.transform.rotation.y = qtn.getY();<br>ts.transform.rotation.z = qtn.getZ();<br>ts.transform.rotation.w = qtn.getW();<br>pub.sendTransform(ts);<br>}</p>
<p>int main(int argc, char *argv[])<br>{<br>// 初始化节点和节点句柄<br>ros::init(argc, argv, “DynamicTfPublisher”);<br>ros::NodeHandle nh;<br>// 订阅发布乌龟位姿的节点，以此得到动态坐标系（乌龟坐标系）的实时位置<br>// 然后在回调函数里利用TransformStamped发布两坐标系间的相对关系<br>ros::Subscriber sub = nh.subscribe(“/turtle1/pose”, 100, doPose);<br>ros::spin();<br>return 0;<br>}<br>③订阅方实现：<br>无论是静态坐标系还是动态坐标系，某一坐标系下的坐标点相对坐标原点的关系总是一样的，因而动态坐标系的订阅方实现与静态坐标系几乎没有不同，只需要把父子坐标系的名字改成需要考虑的即可。唯一值得注意的是此时组织的PointStamped对象的时间戳stamp不应该是ros::Time::now()而应该是ros::Time(0.0)，原因在于ROS会检验动态坐标系发布的时间戳和某一点相对于某一坐标的时间戳的差值，如果两者有较大的差别则ROS会认为此时前者的值在后者看来已经过时了，也就是此时的坐标变化不准确而失去意义，因而ROS会抛出异常并不再处理。可以看到如果我们把发布方和订阅方的时间戳都设置为ros::Time::now()，发布和订阅之间所产生的时间差将导致ROS抛出异常。而将其设置为ros::Time(0.0)后ROS会认为该信息对时间不敏感，也就能输出正常的结果了。<br>④总结：<br>可以看到此时发布方先订阅了乌龟位姿节点以获取动态的乌龟坐标系值，而后再发布动态坐标间的相对位置关系，订阅方借助自身得到的以某一坐标系为基准的坐标值去订阅话题以实现TF坐标转换到另一坐标系为基准的坐标值。同样我们可以使用rviz可视化的看到坐标系间的关系，可以看到此时乌龟坐标系是会随着键盘节点命令而运动的。<br>5.多坐标变换：<br>现有坐标系统，父级坐标系统 world,下有两子级系统 son1，son2，son1 相对于 world，以及 son2 相对于 world 的关系是已知的，求 son1原点在 son2中的坐标，又已知在 son1中一点的坐标，要求求出该点在 son2 中的坐标。<br>代码实现：<br>①创建项目功能包：<br>包括tf2 tf2_ros tf2_geometry_msgs roscpp rospy std_msgs geometry_msgs<br>②发布方实现：直接使用launch文件调用静态坐标系中提到的专用节点来发布坐标关系<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;son1&quot; 	args=&quot;0.2 0.8 0.3 0 0 0 /world /son1&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;son2&quot; 		args=&quot;0.5 0 0 0 0 0 /world /son2&quot; output=&quot;screen&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><br>③订阅方实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;tf2_ros/transform_listener.h&quot;</span><br><span class="line">#include &quot;tf2_ros/buffer.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/PointStamped.h&quot;</span><br><span class="line">#include &quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span><br><span class="line">#include &quot;geometry_msgs/TransformStamped.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;MultiTfSubscriber&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建buffer和坐标变换监听对象，用于存储订阅得到的数据</span><br><span class="line">tf2_ros::Buffer buffer;</span><br><span class="line">tf2_ros::TransformListener listener(buffer);</span><br><span class="line">// 组织一个PointStamped对象表示在son1坐标系下的坐标</span><br><span class="line">geometry_msgs::PointStamped ps_son1;</span><br><span class="line">ps_son1.header.frame_id = &quot;son1&quot;;</span><br><span class="line">ps_son1.header.stamp = ros::Time::now();</span><br><span class="line">ps_son1.point.x = 1.0;</span><br><span class="line">ps_son1.point.y = 2.0;</span><br><span class="line">ps_son1.point.z = 3.0;</span><br><span class="line">ros::Rate rate(10);</span><br><span class="line">while (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">// 坐标系的相对关系：son1相对于son2（son2为父坐标系，son1为子坐	标系），ros::Time(0)表示取时间戳相差最近的两个值</span><br><span class="line">geometry_msgs::TransformStamped son1Toson2 = 		buffer.lookupTransform(&quot;son2&quot;, &quot;son1&quot;, ros::Time(0));</span><br><span class="line">ROS_INFO(&quot;Father:%s,Son:%s,Offset:(%2f,%2f,%2f)&quot;,</span><br><span class="line">son1Toson2.header.frame_id.c_str(),</span><br><span class="line">son1Toson2.child_frame_id.c_str(),</span><br><span class="line">son1Toson2.transform.translation.x,</span><br><span class="line">son1Toson2.transform.translation.y,</span><br><span class="line">son1Toson2.transform.translation.z);</span><br><span class="line">// 坐标点的关系：组织PointStamped对象表示在son2坐标系下的坐标</span><br><span class="line">geometry_msgs::PointStamped ps_son2 </span><br><span class="line">= buffer.transform(ps_son1, &quot;son2&quot;);</span><br><span class="line">ROS_INFO(&quot;The location transformed according to %s is:</span><br><span class="line">(%2f,%2f,%2f)&quot;,</span><br><span class="line">ps_son2.header.frame_id.c_str(),</span><br><span class="line">ps_son2.point.x,</span><br><span class="line">ps_son2.point.y,</span><br><span class="line">ps_son2.point.z);</span><br><span class="line">&#125;</span><br><span class="line">catch (const std::exception &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;Error:%s&quot;, e.what());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rate.sleep();</span><br><span class="line">ros::spinOnce();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>④总结：<br>首先发布方需要发布son1和son2相对于world的坐标消息，然后需要订阅坐标发布消息，借助于tf2实现son1和son2的转换，最后还要实现坐标点的转换。</p>
<h1 id="rosbag："><a href="#rosbag：" class="headerlink" title="rosbag："></a>rosbag：</h1><p>机器人传感器获取到的信息，有时我们可能需要时时处理，有时可能只是采集数据，事后分析，在ROS中关于数据的留存以及读取实现，提供了专门的工具rosbag，它实现了数据的复用，方便调试和测试。rosbag的本质也是一个ros节点，当录制时，rosbag是一个订阅节点，可以订阅话题消息并将订阅到的数据写入磁盘文件；当重放时，rosbag是一个发布节点，可以读取磁盘文件，发布文件中的话题消息。<br>①命令行实现：<br>1&gt;创建rosbag记录：rosbag record -a -O 目标文件路径及名称（建议以.bag作为后缀）<br>   其中-a表示all，即记录所有节点的数据变化；-O指output，即此时rosbag为输出<br>此时ROS便会开始记录所有节点的变化，当按下ctrl+C时终止并保存数据至.bag<br>2&gt;查看存在的rosbag信息：rosbag info 目标文件路径及名称<br>3&gt;读取并回放rosbag的数据：rosbag play 目标文件路径及名称<br>②代码实现：<br>1&gt;写入实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;rosbag/bag.h&quot;</span><br><span class="line">#include &quot;std_msgs/String.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;WriteBag&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建rosbag对象，可以打开，写入和关闭</span><br><span class="line">rosbag::Bag bag;</span><br><span class="line">bag.open(&quot;hello.bag&quot;, rosbag::BagMode::Write);</span><br><span class="line">std_msgs::String msg;</span><br><span class="line">msg.data = &quot;hello,rosbag!&quot;;</span><br><span class="line">// 写入操作用到的话题，时间戳和具体内容</span><br><span class="line">bag.write(&quot;/chatter&quot;, ros::Time::now(), msg);</span><br><span class="line">bag.write(&quot;/chatter&quot;, ros::Time::now(), msg);</span><br><span class="line">bag.write(&quot;/chatter&quot;, ros::Time::now(), msg);</span><br><span class="line">bag.write(&quot;/chatter&quot;, ros::Time::now(), msg);</span><br><span class="line">bag.close();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">2&gt;读出实现：</span><br><span class="line">#include &quot;ros/ros.h&quot;</span><br><span class="line">#include &quot;rosbag/bag.h&quot;</span><br><span class="line">#include &quot;rosbag/view.h&quot;</span><br><span class="line">#include &quot;std_msgs/String.h&quot;</span><br><span class="line">#include &quot;std_msgs/Int32.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// 初始化节点和节点句柄</span><br><span class="line">ros::init(argc, argv, &quot;ReadBag&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">// 创建rosbag对象</span><br><span class="line">rosbag::Bag bag;</span><br><span class="line">bag.open(&quot;hello.bag&quot;, rosbag::BagMode::Read);</span><br><span class="line">// 读数据，rosbag::View以集合的方式返回一条消息，可以被迭代器迭代</span><br><span class="line">for (auto &amp;&amp;m : rosbag::View(bag))</span><br><span class="line">&#123;</span><br><span class="line">std::string topic = m.getTopic();</span><br><span class="line">ros::Time time = m.getTime();</span><br><span class="line">std_msgs::StringPtr p = m.instantiate&lt;std_msgs::String&gt;();</span><br><span class="line">if (p != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">ROS_INFO(&quot;Topic:%s,Stamp:%.2f,Message:%s&quot;,</span><br><span class="line">topic.c_str(),</span><br><span class="line">time.toSec(),</span><br><span class="line">p-&gt;data.c_str());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bag.close();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3&gt;结果：读出文件会输出写入文件的内容</p>
<h1 id="RQT工具箱："><a href="#RQT工具箱：" class="headerlink" title="RQT工具箱："></a>RQT工具箱：</h1><p>之前，在 ROS 中使用了一些实用的工具,比如: ros_bag 用于录制与回放、tf2_tools 可以生成 TF 树 ….. 这些工具大大提高了开发的便利性，但是也存在一些问题: 这些工具的启动和使用过程中涉及到一些命令操作，应用起来不够方便，在ROS中，提供了rqt工具箱，在调用工具时以图形化操作代替了命令操作，应用更便利，提高了操作效率。<br>呼出RQT工具箱：键入命令rqt<br>使用rqt提供的相关功能：既可以直接键入子命令（例如rqt_graph等），也可以在rqt的plugins中选择对应的功能。</p>
<h1 id="机器人系统仿真："><a href="#机器人系统仿真：" class="headerlink" title="机器人系统仿真："></a>机器人系统仿真：</h1><p>ROS中提供了系统的机器人仿真实现，通过仿真，可以实现大部分需求。利用ROS仿真，我们可以学会创建并显示机器人模型，搭建仿真环境，实现机器人模型与仿真环境的交互。<br>机器人的仿真涉及三个模块，URDF、Rviz和Gazebo。<br>1.模块简介：<br>①URDF：URDF是Unified Robot Description Format的缩写，直译为统一机器人描述格式，是一种可以以XML的方式描述机器人的结构和关节的文件。该文件可以被C++内置的解释器转换成可视化的机器人模型。<br>②Rviz：Rviz是ROS Visualization Tool的缩写，直译为ROS的三维可视化工具，它的主要目的是以三维方式显示ROS消息，可以将数据进行可视化表达。<br>③Gazebo：Gazebo是一款3D动态模拟器，用于显示机器人模型并创建仿真环境,能够在复杂的室内和室外环境中准确有效地模拟机器人。<br>④总结：机器人的系统仿真是一种集成实现，其中URDF用于创建机器人模型，Rviz用于以图形化的方式显示机器人各种传感器感知到的环境信息，Gazebo用于搭建仿真环境。<br>三者应用中，只是创建URDF意义不大，一般需要结合Gazebo或Rviz使用，在Gazebo或Rviz中可以将URDF 文件解析为图形化的机器人模型，一般的使用组合为:如果非仿真环境，那么使用URDF结合Rviz直接显示感知的真实环境信息；如果是仿真环境，那么需要使用URDF结合Gazebo搭建仿真环境，并结合Rviz显示感知的虚拟环境信息。<br>2.代码实现URDF集成Rviz：<br>①导入依赖和搭建架构：创建新的功能包并导入依赖包urdf与xacro，新建目录:<br>1&gt;urdf：再下分目录urdf和xacro，其中urdf存储urdf文件，xacro存储xacro文件<br>2&gt;meshes：存储机器人模型渲染文件stl<br>3&gt;config：存储配置文件rviz<br>4&gt;launch：存储launch启动文件<br>②编写URDF文件：URDF 文件是一个标准的 XML 文件，在 ROS 中预定义了一系列的标签用于描述机器人模型，具体可以分为以下四类：<br>1&gt;robot标签：根标签，类似于launch文件中的launch标签<br>a)name属性: 指定机器人模型的名称<br>b)子标签：其他标签都是robot子级标签<br>2&gt;link标签：连杆标签，用于描述机器人某个部件(也即刚体部分)的外观和物理属性，比如:机器人底座、轮子、激光雷达、摄像头等都对应了一个link。<br>一个连杆由以下几部分组成：连杆参考的基坐标，连杆的视觉形象（连杆的形状，连杆基于基坐标产生的偏移和旋转，连杆的颜色和透明度），连杆的碰撞属性和惯性矩阵。</p>
<p>a)name属性: 指定连杆的名称<br>b)visual子标签：指定连杆的外观(对应的数据是可视的)<br>geometry子标签：设置连杆的形状（注意其下只能同时存在以下一个标签）<br>box子标签：设置连杆的形状为立方体<br>size属性：设置立方体的长(x) 宽(y) 高(z)<br>cylinder子标签：设置连杆的形状为圆柱<br>radius属性：设置圆柱的半径<br>length属性：设置圆柱的高度<br>sphere子标签：设置连杆的形状为球<br>radius属性：设置球的半径<br>mesh子标签：自定义设置连杆的形状<br>filename属性：设置自定义文件所在的路径(格式:package://…)<br>origin子标签：设置连杆相对于坐标原点的偏移量与倾斜弧度<br>xyz属性:设置坐标偏移x y z<br>rpy属性:设置坐标旋转r p y (弧度)<br>material子标签：设置连杆的颜色和透明度<br>name属性：指定material的名称<br>color子标签：设置连杆的颜色和透明度<br>rgba属性：红绿蓝权重值与透明度[0,1]<br>c)collision子标签：指定连杆的碰撞属性，即碰撞体积的大小<br>d)Inertial子标签：指定连杆的惯性矩阵<br>3&gt;joint子标签：关节标签，用于连接机器人的两个连杆部件(分别称之为parent link与child link)，不同的关节有不同的运动形式: 他可以是任意旋转的云台、用螺丝螺母固定的结构、或是旋转受限的俯仰机构，这些都可以在joint标签下设置。需要注意的是，joint标签对应的数据在模型中是不可见的。<br>一个关节由以下几部分组成：父连杆与子连杆，关节相对于父连杆基坐标的偏移，关节的类型与旋转轴。需要注意的是此时关节的位置就是子连杆基坐标的位置。</p>
<p>a)name属性: 指定关节的名称<br>b)type 属性：指定关节的类型，分别可以设置为：<br>continuous: 旋转关节，可以绕单轴无限旋转<br>revolute: 旋转关节，类似于 continuous,但是有旋转角度限制<br>prismatic: 滑动关节，沿某一轴线移动的关节，有位置极限<br>planer: 平面关节，允许在平面正交方向上平移或旋转<br>floating: 浮动关节，允许进行平移、旋转运动<br>fixed: 固定关节，不允许运动的特殊关节<br>c)parent子标签：<br>link属性：父级连杆的名字<br>d)child子标签：<br>link属性：子级连杆的名字<br>e)origin子标签：<br>xyz属性: 关节相对于父连杆基坐标各轴线上的偏移量<br>rpy属性：关节相对于父连杆基坐标各轴线上的偏移弧度<br>f)axis子标签：<br>xyz属性: 设置关节围绕哪个关节轴（用向量表示）运动<br>4&gt;gazebo标签：集成gazebo需要使用的标签，会在之后详细解释<br>③URDF工具：<br>1&gt;命令check_urdf urdf文件可以检查复杂的urdf文件是否存在语法问题。如果不抛出异常，说明文件合法,否则非法。<br>2&gt;命令urdf_to_graphiz urdf文件可以查看urdf关节和连杆的树形模型结构<br>④编写launch文件解析URDF文件：<br>之前提到过URDF需要被Rviz解析才能出现图形化的机器人模型，这一过程可以通过编写launch文件实现，具体的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">//1.寻找urdf文件</span><br><span class="line">&lt;param name=&quot;xxx&quot; textfile=&quot;$(find 包名)/urdf/urdf/urdf文件&quot; /&gt;</span><br><span class="line">//2.启动rviz节点，调用上次存储的rviz状态配置文件.rviz</span><br><span class="line">//第一次载入时不加args，进入rviz后点击Add-&gt;RobotModel后Save Config</span><br><span class="line">&lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; </span><br><span class="line">args=&quot;-d $(find 包名)/config/xxx.rviz&quot;/&gt;</span><br><span class="line">//3.启动机器人状态和关节状态发布节点</span><br><span class="line">&lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; </span><br><span class="line">name=&quot;robot_state_publisher&quot; /&gt;</span><br><span class="line">&lt;node pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; </span><br><span class="line">name=&quot;joint_state_publisher&quot; /&gt;</span><br><span class="line">//4.启动图形化的控制关节运动节点 </span><br><span class="line">&lt;node pkg=&quot;joint_state_publisher_gui&quot; type=&quot;joint_state_publisher_gui&quot; 	name=&quot;joint_state_publisher_gui&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">⑤编写Xacro文件优化URDF文件的实现过程：</span><br><span class="line">前面URDF文件构建机器人模型的过程中，存在一些问题：</span><br><span class="line">在设计关节的位置时，需要按照一定的公式计算，公式是固定的，但是在URDF中依赖于人工计算，存在不便，容易计算失误，且当某些参数发生改变时，还需要重新计算。</span><br><span class="line">URDF 中的部分内容是高度重复的，驱动轮与支撑轮的设计实现，不同轮子只是部分参数不同，形状、颜色、翻转量都是一致的，在实际应用中，构建复杂的机器人模型时，更是易于出现高度重复的设计，按照一般的编程涉及到重复代码应该考虑封装。</span><br><span class="line">在编程语言中，可以通过变量结合函数直接解决上述问题，ROS则选择引入了Xacro。Xacro 是一种 XML 宏语言，是可编程的 XML。Xacro 可以声明变量，可以通过数学运算求解，使用流程控制控制执行顺序，还可以通过类似函数的实现，封装固定的逻辑，将逻辑中需要的可变的数据以参数的方式暴露出去，从而提高代码复用率以及程序的安全性。</span><br><span class="line">由于Xacro也是一种XML格式文件，因而其基本编写逻辑与URDF无异，但是Xacro文件额外提供了属性、宏和文件包含的XML语句，具体的：</span><br><span class="line">1&gt;属性：类似于变量定义，用于封装URDF中的一些字段，比如PI值，小车的尺寸等</span><br><span class="line">属性定义：&lt;xacro:property name=&quot;xxxx&quot; value=&quot;yyyy&quot; /&gt;</span><br><span class="line">属性调用：$&#123;属性名称&#125;</span><br><span class="line">算数运算：$&#123;数学表达式&#125;</span><br><span class="line">2&gt;宏：类似于函数实现，提高代码复用率</span><br><span class="line">宏定义：&lt;xacro:macro name=&quot;宏名称&quot; params=&quot;参数列表(空格分隔)&quot;&gt;</span><br><span class="line">    .....</span><br><span class="line">    参数调用格式: $&#123;参数名&#125;</span><br><span class="line">&lt;/xacro:macro&gt;</span><br><span class="line">宏调用：&lt;xacro:宏名称 参数1=xxx 参数2=xxx/&gt;</span><br><span class="line">3&gt;文件包含：类似于include，将不同部件封装为单独的xacro文件再将它们集成。</span><br><span class="line">文件包含语句：&lt;xacro:include filename=”xxx.xacro&quot; /&gt;</span><br><span class="line">需要注意的是文件的包含是有顺序的，当某一文件需要调用另一文件的东西时，该文件	在文件包含中必须位于另一文件之后。一般来说会有一个总文件专门整合各部分Xacro。</span><br><span class="line">需要注意的是Xacro文件本身是不能被Rviz直接解析的，需要先将Xacro文件编译为URDF文件，为此Xacro文件的根标签robot中必须包含命名空间声明属性的语句:</span><br><span class="line">xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;</span><br><span class="line">此外，还需要修改launch文件的param属性为：</span><br><span class="line">&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro </span><br><span class="line">$(find 包名)/urdf/xacro/xxx.xacro&quot; /&gt;</span><br><span class="line">⑥使用Arbotix在Rviz中实现控制机器人模型运动：</span><br><span class="line">通过 URDF 结合 rviz 可以创建并显示机器人模型，不过当前实现的只是静态模型，而使用 Arbotix 可以实现对机器人模型的运动控制。Arbotix 是一款控制电机、舵机的控制板，并提供相应的 ros 功能包，这个功能包的功能不仅可以驱动真实的 Arbotix 控制板，它还提供一个差速控制器，通过接受速度控制指令更新机器人的 joint 状态，从而帮助我们实现机器人在 rviz 中的运动。这个差速控制器在 arbotix_python 程序包中，完整的 arbotix 程序包还包括多种控制器，分别对应 dynamixel 电机、多关节机械臂以及不同形状的夹持器。</span><br><span class="line">使用Arbotix的方法是在原有静态机器人模型的基础上添加 Arbotix 相关的配置文件和节点。在config文件夹下添加配置文件WheelController.yaml如下：</span><br><span class="line">controllers: &#123;</span><br><span class="line">   # 单控制器设置</span><br><span class="line">   base_controller: &#123;</span><br><span class="line">       type: diff_controller,	#类型: 差速控制器</span><br><span class="line">       base_frame_id: base_footprint, #参考坐标</span><br><span class="line">       base_width: 0.2,#两个轮子之间的间距</span><br><span class="line">       ticks_meter: 2000, #控制频率</span><br><span class="line">       #PID控制参数，使机器人车轮快速达到预期速度</span><br><span class="line">       Kp: 12, </span><br><span class="line">       Kd: 12, </span><br><span class="line">       Ki: 0, </span><br><span class="line">       Ko: 50, </span><br><span class="line">       accel_limit: 1.0 #加速限制</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这段配置文件是一个差速控制器，规定了控制器的相关参数设置，例如配置差速轮的间距和PID控制参数。</span><br><span class="line">而后在原静态模型launch文件中添加配置 arbotix 节点如下：</span><br><span class="line">&lt;node name=&quot;arbotix&quot; pkg=&quot;arbotix_python&quot; type=&quot;arbotix_driver&quot; </span><br><span class="line">output=&quot;screen&quot;&gt;</span><br><span class="line">&lt;rosparam command=&quot;load&quot; </span><br><span class="line">file=&quot;$(find 包名)/config/WheelController.yaml&quot; /&gt;</span><br><span class="line">&lt;param name=&quot;sim&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br><span class="line">可以看到Arbotix是一个节点，在节点中载入之前配置的文件WheelController.yaml，同时设置环境为仿真环境。</span><br><span class="line">启动该launch文件，在rviz里选择坐标系Fixed Frame为odom（里程计），Add添加odometry，选择odometry的话题Topic为/odom，/odom会自动呼出速度控制话题/cmd_vel，也就是说我们可以发布 cmd_vel 话题消息控制小车运动了，该实现策略有多种，可以另行编写节点，或者更简单些可以直接通过如下命令发布消息:</span><br><span class="line">rostopic pub -r 10 /cmd_vel geometry_msgs/Twist &#x27;&#123;linear: &#123;x: 0.2, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 0.5&#125;&#125;&#x27;</span><br><span class="line">现在，小车就可以运动起来了。</span><br><span class="line">3.代码实现URDF集成Gazebo：</span><br><span class="line">①导入依赖和搭建架构：创建新的功能包并导入依赖包 urdf、xacro、gazebo_ros、gazebo_ros_control、gazebo_plugins，新建目录:</span><br><span class="line">1&gt;urdf：再下分目录urdf、xacro和Gazebo，其中urdf存储urdf文件，xacro存储xacro文件，Gazebo存储连杆配置文件（虽然也是Xacro文件，但前两者是建立模型时使用的文件，后者则是配置连杆功能时使用的文件）</span><br><span class="line">2&gt;launch：存储launch启动文件</span><br><span class="line">3&gt;worlds：存储在Gazebo中构建的世界模型</span><br><span class="line">②编写建立模型的URDF和Xacro文件：整体过程与URDF集成Rviz时大体一致，但由于Gazebo基于仿真环境，因此连杆link必须启用碰撞检测collision和惯性力学计算标签inertial ，此外，Gazebo下的颜色设置也需要使用专门的标签gazebo：</span><br><span class="line">&lt;gazebo reference=&quot;base_link&quot;&gt;</span><br><span class="line">&lt;material&gt;Gazebo/Black&lt;/material&gt;	#设置颜色为黑色</span><br><span class="line">&lt;/gazebo&gt;</span><br><span class="line">1&gt;collision标签：如果机器人link是标准的几何体形状，那么collision的设置只需要和 visual的设置一致即可（除了不需要设置颜色）。</span><br><span class="line">2&gt;inertial标签：惯性矩阵是一个非常专业的概念，在Gazebo中如果胡乱设置会导致仿真出现各种问题，基本形状的惯性矩阵可以直接使用下述Xacro文件的宏计算获得：</span><br><span class="line">&lt;!-- 球体惯性矩阵：m为质量，r为半径--&gt;</span><br><span class="line">    &lt;xacro:macro name=&quot;sphere_inertial_matrix&quot; params=&quot;m r&quot;&gt;</span><br><span class="line">        &lt;inertial&gt;</span><br><span class="line">            &lt;mass value=&quot;$&#123;m&#125;&quot; /&gt;</span><br><span class="line">            &lt;inertia ixx=&quot;$&#123;2*m*r*r/5&#125;&quot; ixy=&quot;0&quot; ixz=&quot;0&quot;</span><br><span class="line">                iyy=&quot;$&#123;2*m*r*r/5&#125;&quot; iyz=&quot;0&quot; </span><br><span class="line">                izz=&quot;$&#123;2*m*r*r/5&#125;&quot; /&gt;</span><br><span class="line">        &lt;/inertial&gt;</span><br><span class="line">&lt;/xacro:macro&gt;</span><br><span class="line">&lt;!-- 圆柱惯性矩阵：m为质量，r为半径，h为高度--&gt;</span><br><span class="line">&lt;xacro:macro name=&quot;cylinder_inertial_matrix&quot; params=&quot;m r h&quot;&gt;</span><br><span class="line">        &lt;inertial&gt;</span><br><span class="line">            &lt;mass value=&quot;$&#123;m&#125;&quot; /&gt;</span><br><span class="line">            &lt;inertia ixx=&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot; ixy = &quot;0&quot; ixz = &quot;0&quot;</span><br><span class="line">                iyy=&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot; iyz = &quot;0&quot;</span><br><span class="line">                izz=&quot;$&#123;m*r*r/2&#125;&quot; /&gt; </span><br><span class="line">        &lt;/inertial&gt;</span><br><span class="line">&lt;/xacro:macro&gt;</span><br><span class="line">&lt;!-- 立方体惯性矩阵：m为质量，l为长度，w为宽度，h为高度--&gt;</span><br><span class="line"> &lt;xacro:macro name=&quot;Box_inertial_matrix&quot; params=&quot;m l w h&quot;&gt;</span><br><span class="line">       &lt;inertial&gt;</span><br><span class="line">               &lt;mass value=&quot;$&#123;m&#125;&quot; /&gt;</span><br><span class="line">               &lt;inertia ixx=&quot;$&#123;m*(h*h + l*l)/12&#125;&quot; ixy = &quot;0&quot; ixz = &quot;0&quot;</span><br><span class="line">                   iyy=&quot;$&#123;m*(w*w + l*l)/12&#125;&quot; iyz= &quot;0&quot;</span><br><span class="line">                   izz=&quot;$&#123;m*(w*w + h*h)/12&#125;&quot; /&gt;</span><br><span class="line">       &lt;/inertial&gt;</span><br><span class="line">   &lt;/xacro:macro&gt;</span><br><span class="line">再次强调：原则上除了base_footprint外，机器人的每个刚体部分都需要设置惯性矩阵，且惯性矩阵必须经上述计算严谨得出。具体在调用时，只需要使用对应的宏即可，例如：</span><br><span class="line">&lt;xacro:cylinder_inertial_matrix m=xxx r=xxx h=xxx /&gt;</span><br><span class="line">即可返回一个正确的惯性标签。</span><br><span class="line">3&gt;Gazebo标签：Gazebo是一种修饰标签，它依赖于其他已有的标签存在，其属性reference的值就是依赖标签的名字，它只起修饰reference所指向的标签的作用。例如上例就是修饰名字为base_link的连杆颜色为黑色，之后还会提到修饰某个连杆为雷达、摄像头、里程计等。</span><br><span class="line">③编写控制机器人运动的URDF和Xacro文件：至此gazebo 中已经可以显示静态机器人模型了，那么如何像在rviz中一样控制机器人运动呢？在此，需要涉及到ros中的组件: ros_control。ros_control是一组软件包，它包含了控制器接口，控制器管理器，传输和硬件接口。它是一套机器人控制的中间件，是一套规范，不同的机器人平台只要按照这套规范实现，那么就可以保证与ROS 程序兼容，通过这套规范，实现了一种可插拔的架构设计，大大提高了程序设计的效率与灵活性。gazebo 已经实现了 ros_control 的相关接口，如果需要在 gazebo 中控制机器人运动，直接调用相关接口即可。编写Xacro文件如下：</span><br><span class="line">&lt;robot name=&quot;my_car_move&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;</span><br><span class="line">    &lt;!-- 传动实现:用于连接控制器与关节 --&gt;</span><br><span class="line">    &lt;xacro:macro name=&quot;joint_trans&quot; params=&quot;joint_name&quot;&gt;</span><br><span class="line">        &lt;!-- Transmission is important to link the joints and the controller --&gt;</span><br><span class="line">        &lt;transmission name=&quot;$&#123;joint_name&#125;_trans&quot;&gt;</span><br><span class="line">            &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;</span><br><span class="line">            &lt;joint name=&quot;$&#123;joint_name&#125;&quot;&gt;      											&lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface</span><br><span class="line">&lt;/hardware	Interface&gt;</span><br><span class="line">            &lt;/joint&gt;</span><br><span class="line">            &lt;actuator name=&quot;$&#123;joint_name&#125;_motor&quot;&gt;</span><br><span class="line">                &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface</span><br><span class="line">&lt;/hardwareInterface&gt;</span><br><span class="line">                &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;</span><br><span class="line">            &lt;/actuator&gt;</span><br><span class="line">        &lt;/transmission&gt;</span><br><span class="line">    &lt;/xacro:macro&gt;</span><br><span class="line">    &lt;!-- 每一个驱动轮都需要配置传动装置 --&gt;</span><br><span class="line">    &lt;xacro:joint_trans joint_name=&quot;left_wheel2base_link&quot; /&gt;</span><br><span class="line">    &lt;xacro:joint_trans joint_name=&quot;right_wheel2base_link&quot; /&gt;</span><br><span class="line">    &lt;!-- 控制器 --&gt;</span><br><span class="line">    &lt;gazebo&gt;</span><br><span class="line">        &lt;plugin name=&quot;differential_drive_controller&quot; </span><br><span class="line">filename=&quot;libgazebo_ros_diff_drive.so&quot;&gt;</span><br><span class="line">            &lt;rosDebugLevel&gt;Debug&lt;/rosDebugLevel&gt;</span><br><span class="line">            &lt;publishWheelTF&gt;true&lt;/publishWheelTF&gt;</span><br><span class="line">            &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;</span><br><span class="line">            &lt;publishTf&gt;1&lt;/publishTf&gt;</span><br><span class="line">            &lt;publishWheelJointState&gt;true&lt;/publishWheelJointState&gt;</span><br><span class="line">            &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;</span><br><span class="line">            &lt;updateRate&gt;100.0&lt;/updateRate&gt;</span><br><span class="line">            &lt;legacyMode&gt;true&lt;/legacyMode&gt;</span><br><span class="line">            &lt;leftJoint&gt;left_wheel2base_link&lt;/leftJoint&gt;</span><br><span class="line">            &lt;rightJoint&gt;right_wheel2base_link&lt;/rightJoint&gt; </span><br><span class="line">            &lt;wheelSeparation&gt;$&#123;base_link_radius*2&#125;&lt;/wheelSeparation&gt; </span><br><span class="line">            &lt;wheelDiameter&gt;$&#123;wheel_radius * 2&#125;&lt;/wheelDiameter&gt;            </span><br><span class="line">&lt;broadcastTF&gt;1&lt;/broadcastTF&gt;</span><br><span class="line">            &lt;wheelTorque&gt;30&lt;/wheelTorque&gt;</span><br><span class="line">            &lt;wheelAcceleration&gt;1.8&lt;/wheelAcceleration&gt;</span><br><span class="line">            &lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;</span><br><span class="line">            &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt; </span><br><span class="line">            &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;</span><br><span class="line">            &lt;robotBaseFrame&gt;base_footprint&lt;/robotBaseFrame&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/gazebo&gt;</span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure><br>一些重要标签：xacro:joint_trans宏用于绑定左右轮的关节，leftJoint和rightJoint用于绑定左右轮的连杆名称，wheelSeparation用于设置车轮间距，wheelDiameter用于设置车轮直径，commandTopic用于设置运动控制话题名，odometryTopic用于设置里程计话题名，robotBaseFrame用于设置根坐标系名。</p>
<p>④编写修饰模型的URDF和Xacro文件：<br>1&gt;里程计：里程计用于获取机器人相对出发点坐标系的位姿状态(XYZ坐标以及朝向)<br>可以通过 Rviz 显示机器人的里程计信息以及运动朝向<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;!-- 启动 rviz --&gt;</span><br><span class="line">    &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 关节以及机器人状态发布节点 --&gt;</span><br><span class="line">    &lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; /&gt;</span><br><span class="line">    &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><br>2&gt;雷达：和里程计直接与机器人控制节点集成不同，ROS中设置雷达的方式是把一个连杆组件修饰为仿真雷达，也就是使用gazebo reference的方法，具体Xacro文件如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;robot name=&quot;my_sensors&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;</span><br><span class="line">  &lt;gazebo reference=&quot;laser（想要修饰为雷达的连杆名）&quot;&gt;</span><br><span class="line">    &lt;sensor type=&quot;ray&quot; name=&quot;rplidar&quot;&gt;</span><br><span class="line">      &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;</span><br><span class="line">      &lt;visualize&gt;true&lt;/visualize&gt;</span><br><span class="line">      &lt;update_rate&gt;5.5&lt;/update_rate&gt;</span><br><span class="line">      &lt;ray&gt;</span><br><span class="line">        &lt;scan&gt;</span><br><span class="line">          &lt;horizontal&gt;</span><br><span class="line">            &lt;samples&gt;360&lt;/samples&gt;</span><br><span class="line">            &lt;resolution&gt;1&lt;/resolution&gt;</span><br><span class="line">            &lt;min_angle&gt;-3&lt;/min_angle&gt;</span><br><span class="line">            &lt;max_angle&gt;3&lt;/max_angle&gt;</span><br><span class="line">          &lt;/horizontal&gt;</span><br><span class="line">        &lt;/scan&gt;</span><br><span class="line">        &lt;range&gt;</span><br><span class="line">          &lt;min&gt;0.10&lt;/min&gt;</span><br><span class="line">          &lt;max&gt;30.0&lt;/max&gt;</span><br><span class="line">          &lt;resolution&gt;0.01&lt;/resolution&gt;</span><br><span class="line">        &lt;/range&gt;</span><br><span class="line">        &lt;noise&gt;</span><br><span class="line">          &lt;type&gt;gaussian&lt;/type&gt;</span><br><span class="line">          &lt;mean&gt;0.0&lt;/mean&gt;</span><br><span class="line">          &lt;stddev&gt;0.01&lt;/stddev&gt;</span><br><span class="line">        &lt;/noise&gt;</span><br><span class="line">      &lt;/ray&gt;</span><br><span class="line">      &lt;plugin name=&quot;gazebo_rplidar&quot; filename=&quot;libgazebo_ros_laser.so&quot;&gt;</span><br><span class="line">        &lt;topicName&gt;/scan&lt;/topicName&gt;</span><br><span class="line">        &lt;frameName&gt;laser&lt;/frameName&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/sensor&gt;</span><br><span class="line">  &lt;/gazebo&gt;</span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure><br>一些重要标签：sensor type为传感器类型，pose为偏移，update_rate为数据更新频率，<br>samples为光线数，resolution为分辨率，min/max_angle为雷达非死区范围，noise为噪声（高斯噪声，均值和标准差），topicName为话题名称。<br>3&gt;摄像头：ROS中设置摄像头的方式与雷达一致，即把一个连杆组件修饰为仿真摄像头：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;robot name=&quot;my_sensors&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;</span><br><span class="line">  &lt;gazebo reference=&quot;camera（想要修饰为摄像头的连杆名）&quot;&gt;</span><br><span class="line">    &lt;sensor type=&quot;camera&quot; name=&quot;camera_node&quot;&gt;</span><br><span class="line">      &lt;update_rate&gt;30.0&lt;/update_rate&gt; &lt;!-- 更新频率 --&gt;</span><br><span class="line">      &lt;!-- 摄像头基本信息设置 --&gt;</span><br><span class="line">      &lt;camera name=&quot;head&quot;&gt;</span><br><span class="line">        &lt;horizontal_fov&gt;1.3962634&lt;/horizontal_fov&gt;</span><br><span class="line">        &lt;image&gt;</span><br><span class="line">          &lt;width&gt;1280&lt;/width&gt;</span><br><span class="line">          &lt;height&gt;720&lt;/height&gt;</span><br><span class="line">          &lt;format&gt;R8G8B8&lt;/format&gt;</span><br><span class="line">        &lt;/image&gt;</span><br><span class="line">        &lt;clip&gt;</span><br><span class="line">          &lt;near&gt;0.02&lt;/near&gt;</span><br><span class="line">          &lt;far&gt;300&lt;/far&gt;</span><br><span class="line">        &lt;/clip&gt;</span><br><span class="line">        &lt;noise&gt;</span><br><span class="line">          &lt;type&gt;gaussian&lt;/type&gt;</span><br><span class="line">          &lt;mean&gt;0.0&lt;/mean&gt;</span><br><span class="line">          &lt;stddev&gt;0.007&lt;/stddev&gt;</span><br><span class="line">        &lt;/noise&gt;</span><br><span class="line">      &lt;/camera&gt;</span><br><span class="line">      &lt;plugin name=&quot;gazebo_camera&quot; filename=&quot;libgazebo_ros_camera.so&quot;&gt;</span><br><span class="line">        &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;</span><br><span class="line">        &lt;updateRate&gt;0.0&lt;/updateRate&gt;</span><br><span class="line">        &lt;cameraName&gt;/camera&lt;/cameraName&gt;</span><br><span class="line">        &lt;imageTopicName&gt;image_raw&lt;/imageTopicName&gt;</span><br><span class="line">        &lt;cameraInfoTopicName&gt;camera_info&lt;/cameraInfoTopicName&gt;</span><br><span class="line">        &lt;frameName&gt;camera&lt;/frameName&gt;</span><br><span class="line">        &lt;hackBaseline&gt;0.07&lt;/hackBaseline&gt;</span><br><span class="line">        &lt;distortionK1&gt;0.0&lt;/distortionK1&gt;</span><br><span class="line">        &lt;distortionK2&gt;0.0&lt;/distortionK2&gt;</span><br><span class="line">        &lt;distortionK3&gt;0.0&lt;/distortionK3&gt;</span><br><span class="line">        &lt;distortionT1&gt;0.0&lt;/distortionT1&gt;</span><br><span class="line">        &lt;distortionT2&gt;0.0&lt;/distortionT2&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/sensor&gt;</span><br><span class="line">  &lt;/gazebo&gt;</span><br><span class="line">&lt;/robot&gt;</span><br></pre></td></tr></table></figure><br>⑤整合各部分Xacro文件：<br>分析我们需要包含的文件，首先是惯性矩阵计算的Xacro文件InertialAlgorithm.xacro，然后是形成机器人静态模型的各Xacro文件，例如底盘、摄像头与雷达等，最后是修饰机器人模型所需的Xacro文件。然后创建一个Xacro文件将它们全部包含进来，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;robot name=&quot;my_car_camera&quot;</span><br><span class="line">xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;</span><br><span class="line">&lt;!-- 引入建立机器人模型所需的Xacro文件 --&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;InertialAlgorithm.xacro&quot;/&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;XacroExerciseCarBase1.xacro&quot; /&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;XacroExerciseCamera1.xacro&quot; /&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;XacroExerciseLaser1.xacro&quot; /&gt;</span><br><span class="line">&lt;!-- 引入控制机器人运动所需的Xacro文件 --&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;gazebo/WheelMove.xacro&quot;/&gt;</span><br><span class="line">&lt;!-- 引入修饰机器人模型所需的Xacro文件 --&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;gazebo/Laser.xacro&quot;/&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;gazebo/Camera.xacro&quot;/&gt;</span><br><span class="line">&lt;xacro:include filename=&quot;gazebo/Kinect.xacro&quot;/&gt;</span><br><span class="line">&lt;/robot&gt;</span><br><span class="line">⑥编写launch文件解析URDF和Xacro文件，并启动Gazebo：</span><br><span class="line">&lt;launch&gt;</span><br><span class="line">&lt;!-- 将 Urdf 文件的内容加载到参数服务器 --&gt;</span><br><span class="line">&lt;param name=&quot;robot_description&quot; </span><br><span class="line">command=&quot;$(find xacro)/xacro $(find 包名)/urdf/Xacro整合文件.xacro&quot; /&gt;</span><br><span class="line">&lt;!-- 启动 gazebo，方法是启动对应launch文件并载入world文件--&gt;</span><br><span class="line">&lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;</span><br><span class="line">&lt;arg name=&quot;world_name&quot; value=&quot;$(find 包名)/worlds/xxx.world&quot; /&gt;</span><br><span class="line">&lt;/include&gt;</span><br><span class="line">&lt;!-- 在 gazebo 中显示机器人模型，需要结合第一步Urdf的param名字 --&gt;</span><br><span class="line">&lt;node pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; name=&quot;model&quot; 	</span><br><span class="line">args=&quot;-urdf -model mycar -param robot_description&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br><span class="line">⑦编写launch文件启动Rviz监测机器人在Gazebo仿真环境下的状态：</span><br><span class="line">之前的文件都是为了启动Gazebo仿真小车的，而状态的监测需要使用Rviz，为此编写专门启动Rviz用来检测机器人状态的launch文件：</span><br><span class="line">&lt;launch&gt;</span><br><span class="line">&lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; </span><br><span class="line">args=&quot;-d $(find UrdfTest)/config/ShowMyCar.rviz&quot;/&gt;</span><br><span class="line">&lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; </span><br><span class="line">type=&quot;joint_state_publisher&quot; /&gt;</span><br><span class="line">&lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; </span><br><span class="line">type=&quot;robot_state_publisher&quot; /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><br>⑧Gazebo仿真文件.world搭建：<br>之前提到过world文件可以在Gazebo中载入已经搭建好的一个仿真环境。<br>那么怎么创建一个新的仿真环境呢？实现方式有三种:分别是直接添加内置组件创建仿真环境，手动绘制仿真环境和直接下载使用官方或第三方提供的仿真环境插件，我们分别来看看<br>1&gt;直接添加内置组件：在Gazebo上方有基本形状和光照，直接导入即可。<br>2&gt;手动绘制仿真环境：点击Edit/Building Editor即可自定义设计仿真环境。<br>3&gt;使用插件：下载官方库git clone <a target="_blank" rel="noopener" href="https://github.com/osrf/gazebo_models并将得到的gazebo_models文件夹内容复制到">https://github.com/osrf/gazebo_models并将得到的gazebo_models文件夹内容复制到</a> /usr/share/gazebo-*/models中，此时重启 Gazebo，选择左侧菜单栏的insert就可以选择并插入相关道具了。<br>绘制好新的仿真环境后，选择File/Save World As即可得到一个world文件了。<br>4.总结：主要介绍了ROS中仿真实现涉及的三大知识点:URDF(Xacro)，Rviz和Gazebo<br>其中URDF 是用于描述机器人模型的 xml 文件，可以使用不同的标签具代表不同含义，xacro 则是对 URDF 的优化实现。容易混淆的是Rviz与Gazebo，在此我们着重比较以下二者的区别:rviz是三维可视化工具，强调通过插件把已有的数据可视化显示，也就是说它需要已有数据的支持，这些数据可以通过话题、参数的形式发布后被Rviz订阅，而后Rviz对其完成可视化的渲染，以此让开发者更容易理解数据的意义；gazebo是三维物理仿真平台，强调的是创建一个虚拟的仿真环境，不需要数据，而是创造数据。我们可以在gazebo中创建一个仿真机器人的运动功能和传感器数据的虚拟世界，而这些数据就可以放到rviz中显示，所以gazebo和rviz经常配合使用。综上，如果你手上已经有机器人硬件平台，并且在上边可以完成需要的功能，用rviz应该就可以满足开发需求。如果你手上没有机器人硬件，或者想在仿真环境中做一些算法、应用的测试，gazebo+rviz应该是你需要的。</p>
<h1 id="机器人导航："><a href="#机器人导航：" class="headerlink" title="机器人导航："></a>机器人导航：</h1><p>amcl通过传感器获取的信息，将这些特征点与全局地图相匹配，从而大致获取机器人的位姿信息。</p>
<p>rosrun nodelet nodelet load nodelet_tutorial_math/Plus mymanager <strong>name:=n1 _value:=100<br> rosrun nodelet nodelet load nodelet_tutorial_math/Plus mymanager </strong>name:=n2 _value:=-50 /n2/in:=/n1/out</p>
<h1 id="Action通信："><a href="#Action通信：" class="headerlink" title="Action通信："></a>Action通信：</h1><p>假设要求机器人导航到某个目标点,此过程需要一个节点A发布目标信息，然后一个节点B接收到请求并控制移动，最终响应目标达成状态信息。乍一看，这好像是服务通信，因为需求中要A发送目标，B执行并返回结果，是一个典型的基于请求响应的应答模式，不过如果只是使用基本的服务通信实现，存在一个问题：导航是一个过程，是耗时操作，如果使用服务通信，那么只有在导航结束时，才会产生响应结果，而在导航过程中，节点A是不会获取到任何反馈的，从而可能出现程序”假死”的现象，过程的不可控意味着不良的用户体验，以及逻辑处理的缺陷(比如:导航中止的需求无法实现)。更合理的方案应该是:导航过程中，可以连续反馈当前机器人状态信息，当导航终止时再返回最终的执行结果。这个过程在ROS中被action通信优化。action通信一般适用于耗时的请求响应场景,用以获取连续的状态反馈，是一种特殊的服务通信。在ROS中提供了actionlib功能包集，用于实现 action 通信。action通信是一种类似于服务通信的实现，其实现模型也包含请求和响应，但是不同的是，在请求和响应的过程中，服务端还可以连续的反馈当前任务进度，客户端可以接收连续反馈，并且还可以取消任务。</p>
<p>goal:目标任务;<br>cacel:取消任务;<br>status:服务端状态;<br>result:最终执行结果(只会发布一次);<br>feedback:连续反馈(可以发布多次)。<br>尝试用代码实现下述Action通信过程：创建两个ROS节点作为服务器和客户端，客户端可以向服务器发送目标数据N，服务器会计算 1 到 N 之间所有整数的和并返回给客户端，假设服务器每累加一次耗时0.1s，为了良好的用户体验，需要服务器在计算过程中，每累加一次就给客户端响应一次百分比格式的执行进度。<br>类似于话题和服务通信，当使用自定义通讯格式进行action通讯时，需要进行以下操作：<br>1.定义action文件：在小src同级下创建action文件夹并创建xxx.action文件，在其中以类似结构体的格式输入需要定义的自定义通讯格式构成。在action文件中，数据组成分为三部分:请求目标值、最终响应结果、连续反馈值，三者之间使用—-分割，例如:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int32 num</span><br><span class="line">---</span><br><span class="line">int32 result</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>float64 progress_bar<br>2.编辑package.xml：<br>这里简单介绍一下package文件的构成，package的核心代码如下：<br>①依赖的构建工具</p>
<p><buildtool_depend>catkin</buildtool_depend><br>②指定构建此软件包所需的软件包 （编译依赖）</p>
<p><build_depend>roscpp</build_depend></p>
<p><build_depend>rospy</build_depend></p>
<p><build_depend>std_msgs</build_depend><br>③指定根据这个包构建库所需要的包（编译外部依赖）</p>
<p><build_export_depend>roscpp</build_export_depend></p>
<p><build_export_depend>rospy</build_export_depend></p>
<p><build_export_depend>std_msgs</build_export_depend><br>④运行该程序包中的代码所需的程序包（执行依赖）</p>
<p><exec_depend>roscpp</exec_depend></p>
<p><exec_depend>rospy</exec_depend></p>
<p><exec_depend>std_msgs</exec_depend><br>我们要在编译依赖中添加<build_depend>message_generation</build_depend><br>在执行依赖中添加<exec_depend>message_runtime</exec_depend><br>3.编辑CMakeLists.txt：<br>L10：取消注释并修改编译依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L51：取消注释并配置msg源文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  xxx.msg</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L71：取消注释使自定义消息格式依赖于 std_msgs：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>L108：取消注释并修改执行依赖为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>4.编译：此时C++调用的中间文件位于(…/工作空间/devel/include/包名/xxx.h)<br>Python调用的中间文件位于(…/工作空间/devel/lib/python3/dist-packages/包名/msg/xxx.py)，之后要想使用这一自定义通讯格式就需要包含这个头文件。</p>
<h1 id="代码实现C-话题通讯："><a href="#代码实现C-话题通讯：" class="headerlink" title="代码实现C++话题通讯："></a>代码实现C++话题通讯：</h1><p><em>1.如果使用自定义格式，需要添加c_cpp_properties.json 的 includepath属性如下：<br> “/xxx/yyy工作空间/devel/include/*</em>“ //配置 head 文件的路径<br>2.包含通讯所需格式的头文件：<br>对于ROS官方提供的基本格式需要包含#include “std_msgs/xxx.h”<br>对于自定义的格式需要包含#include “包名/xxx.h”（即自定义格式经编译得到的头文件）<br>3.发布方实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Publisher”);<br>ros::NodeHandle nh;<br>②创建发布者对象：（发布者和订阅者的话题topic需要一致）<br>官方格式：ros::Publisher pub = nh.advertise<std_msgs::xxx>(“topic”, 10);<br>自定义格式：ros::Publisher pub = nh.advertise&lt;包名::xxx&gt;(“topic”, 10);<br>③编辑要发送的数据：<br>创建对象：std_msgs::xxx/包名::xxx msg;<br>4.订阅方实现：<br>①初始化ros节点并创建节点句柄：<br>ros::init(argc, argv, “Publisher”);<br>ros::NodeHandle nh;<br>②创建订阅者对象：<br>官方：ros::Subscriber sub = nh.subscribe<std_msgs::xxx>(“topic”,10,doMsg);<br>自定义：ros::Subscriber sub = nh.subscribe&lt;包名::xxx&gt;(“topic”,10,doMsg);<br>③循环调用回调函数：ros::spin();<br>④搭建回调函数doMsg：void doMsg(const 包名::xxx::ConstPtr &amp;msg){}</p>
<h1 id="动态参数："><a href="#动态参数：" class="headerlink" title="动态参数："></a>动态参数：</h1><h1 id="pluginlib的使用："><a href="#pluginlib的使用：" class="headerlink" title="pluginlib的使用："></a>pluginlib的使用：</h1><h1 id="nodelet的使用："><a href="#nodelet的使用：" class="headerlink" title="nodelet的使用："></a>nodelet的使用：</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.lolcheng.top">沈畅</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lolcheng.top/2023/12/05/ROS/">https://www.lolcheng.top/2023/12/05/ROS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lolcheng.top" target="_blank">随风的神秘小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ROS/">ROS</a></div><div class="post_share"><div class="social-share" data-image="https://www.lolcheng-picbed.top/img/ROS.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/04/LQR/" title="LQR线性二次型调节器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/lqr.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LQR线性二次型调节器</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/13/spider/" title="爬虫学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/spider.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">爬虫学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">沈畅</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.lolcheng-picbed.top/img/qq.png" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #1169EE;"></i></a><a class="social-icon" href="https://www.lolcheng-picbed.top/img/wechat.png" target="_blank" title="Wechat"><i class="fa-brands fa-weixin" style="color: #1AE642;"></i></a><a class="social-icon" href="https://github.com/lolcheng" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/406219866" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili" style="color: #11EEEE;"></i></a><a class="social-icon" href="mailto:1397799304@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">贵客来访,未曾远迎，失敬失敬！我是小屋的主人随风，想知道我的更多资料欢迎点击关于查看~（推荐采用夜间模式查看本站哦！）</div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8vscode%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%BA%94%E7%94%A8%E4%B8%80%E4%B8%AAros%E9%A1%B9%E7%9B%AE%EF%BC%9A"><span class="toc-text">使用vscode创建并应用一个ros项目：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ros%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%EF%BC%9A"><span class="toc-text">ros文件的基本架构：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%9D%E9%A2%98%E9%80%9A%E8%AE%AF%EF%BC%9A"><span class="toc-text">话题通讯：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">服务通信：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0C-%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%AE%AF%EF%BC%9A"><span class="toc-text">代码实现C++服务通讯：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9A"><span class="toc-text">参数服务器：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84ROS%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-text">常用的ROS命令行命令：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E5%B0%8F%E6%B5%B7%E9%BE%9F%E8%BF%9B%E8%A1%8C%E5%A4%8D%E4%B9%A0%E6%A8%A1%E6%8B%9F%EF%BC%9A"><span class="toc-text">用小海龟进行复习模拟：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E6%96%87%E4%BB%B6%E3%80%81%E6%BA%90%E6%96%87%E4%BB%B6%E5%92%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9A"><span class="toc-text">自定义头文件、源文件和可执行文件的调用：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ROS%E5%85%83%E5%8A%9F%E8%83%BD%E5%8C%85%EF%BC%9A"><span class="toc-text">ROS元功能包：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Launch%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-text">Launch文件的使用：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">重名问题：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">分布式通信：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ROS%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2TF%EF%BC%9A"><span class="toc-text">ROS坐标变换TF：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rosbag%EF%BC%9A"><span class="toc-text">rosbag：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RQT%E5%B7%A5%E5%85%B7%E7%AE%B1%EF%BC%9A"><span class="toc-text">RQT工具箱：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%EF%BC%9A"><span class="toc-text">机器人系统仿真：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%EF%BC%9A"><span class="toc-text">机器人导航：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Action%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">Action通信：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0C-%E8%AF%9D%E9%A2%98%E9%80%9A%E8%AE%AF%EF%BC%9A"><span class="toc-text">代码实现C++话题通讯：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-text">动态参数：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pluginlib%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-text">pluginlib的使用：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nodelet%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-text">nodelet的使用：</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 沈畅</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer src="/js/cursor.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.lolcheng.top/categories/机器人/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🤖 机器人 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.lolcheng.top/categories/人工智能/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🧠 人工智能 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.lolcheng.top/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🔬 嵌入式 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.lolcheng.top/categories/控制理论/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 控制理论 (12)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.lolcheng.top/categories/编程语言学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💻 编程语言学习 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.lolcheng.top/categories/编译进化/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🧬 编译进化 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.lolcheng.top/categories/数据收集与处理/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🔢 数据收集与处理 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://www.lolcheng.top/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = '2695db4e50830126ecac269d88eab6e4';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/12/05/ROS/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/ROS.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-12-05</span><a class="blog-slider__title" href="2023/12/05/ROS/" alt="">ROS学习</a><div class="blog-slider__text">有关于ROS方面的相关知识</div><a class="blog-slider__button" href="2023/12/05/ROS/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/09/13/PID/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/pid.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-13</span><a class="blog-slider__title" href="2022/09/13/PID/" alt="">PID控制</a><div class="blog-slider__text">有关于PID控制方面的相关知识</div><a class="blog-slider__button" href="2022/09/13/PID/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/03/15/opencv/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/opencv.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-15</span><a class="blog-slider__title" href="2024/03/15/opencv/" alt="">OpenCV学习</a><div class="blog-slider__text">有关于OpenCV方面的相关知识</div><a class="blog-slider__button" href="2024/03/15/opencv/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/10/14/DeepLearning/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/DeepLearning.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-14</span><a class="blog-slider__title" href="2023/10/14/DeepLearning/" alt="">深度学习</a><div class="blog-slider__text">有关于人工智能深度学习方面的相关知识，文章部分内容引用自吴恩达老师</div><a class="blog-slider__button" href="2023/10/14/DeepLearning/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/09/17/C#/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/CSharp.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" href="2023/09/17/C#/" alt="">C#学习</a><div class="blog-slider__text">有关于C#方面的相关知识</div><a class="blog-slider__button" href="2023/09/17/C#/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/07/09/peripheral/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/stm32.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-09</span><a class="blog-slider__title" href="2023/07/09/peripheral/" alt="">STM32F4外设学习</a><div class="blog-slider__text">有关于STM32F4外设方面的相关知识</div><a class="blog-slider__button" href="2023/07/09/peripheral/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/07/17/DesignMode/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/DesignMode.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-17</span><a class="blog-slider__title" href="2023/07/17/DesignMode/" alt="">设计模式学习</a><div class="blog-slider__text">有关于设计模式方面的相关知识</div><a class="blog-slider__button" href="2023/07/17/DesignMode/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/08/16/bezier/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.lolcheng-picbed.top/img/bezier.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-16</span><a class="blog-slider__title" href="2023/08/16/bezier/" alt="">曲线插值与拟合算法</a><div class="blog-slider__text">有关于曲线插值与拟合算法方面的相关知识</div><a class="blog-slider__button" href="2023/08/16/bezier/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '0.5s');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '0.5s');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>